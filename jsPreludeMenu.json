{
  "Just": "// Just :: a -> Maybe a\nconst Just = x => ({\n    type: \"Maybe\",\n    Nothing: false,\n    Just: x\n});",
  "Left": "// Left :: a -> Either a b\nconst Left = x => ({\n    type: \"Either\",\n    Left: x\n});",
  "Node": "// Node :: a -> [Tree a] -> Tree a\nconst Node = v =>\n    // Constructor for a Tree node which connects a\n    // value of some kind to a list of zero or\n    // more child trees.\n    xs => ({\n        type: \"Node\",\n        root: v,\n        nest: xs || []\n    });",
  "Nothing": "// Nothing :: Maybe a\nconst Nothing = () => ({\n    type: \"Maybe\",\n    Nothing: true\n});",
  "Right": "// Right :: b -> Either a b\nconst Right = x => ({\n    type: \"Either\",\n    Right: x\n});",
  "Tuple": "// Tuple (,) :: a -> b -> (a, b)\nconst Tuple = a =>\n    b => ({\n        type: \"Tuple\",\n        \"0\": a,\n        \"1\": b,\n        length: 2\n    });",
  "Tuple3": "// Tuple3 (,,) :: a -> b -> c -> (a, b, c)\nconst Tuple3 = a => b => c => ({\n    type: \"Tuple3\",\n    \"0\": a,\n    \"1\": b,\n    \"2\": c,\n    length: 3\n});",
  "TupleN": "// TupleN :: a -> b ...  -> (a, b ... )\nconst TupleN = (...args) => {\n    // A Tuple of an arbitrary number of items.\n    const n = args.length;\n\n    return 2 < n ? Object.assign(\n        args.reduce((a, x, i) => Object.assign(a, {\n            [i]: x\n        }), {\n            type: `Tuple${n}`,\n            length: n\n        })\n    ) : args.reduce((f, x) => f(x), Tuple);\n};",
  "abs": "// abs :: Num -> Num\nconst abs =\n    // Absolute value of a given number - without the sign.\n    x => Math.abs(x);",
  "add": "// add (+) :: Num a => a -> a -> a\nconst add = a =>\n    // Curried addition.\n    b => a + b;",
  "all": "// all :: (a -> Bool) -> [a] -> Bool\nconst all = p =>\n    // True if p(x) holds for every x in xs.\n    xs => [...xs].every(p);",
  "allSame": "// allSame :: [a] -> Bool\nconst allSame = xs =>\n    2 > xs.length || (\n        h => xs.slice(1).every(x => h === x)\n    )(xs[0]);",
  "allTree": "// allTree :: (a -> Bool) -> Tree a -> Bool\nconst allTree = p =>\n    // True if p holds for all nodes of the\n    // tree to which allTree(p) is applied.\n    foldTree(\n        x => xs => p(x) && xs.every(Boolean)\n    );",
  "and": "// and :: [Bool] -> Bool\nconst and = xs =>\n    // True unless any value in xs is false.\n    [...xs].every(Boolean);",
  "any": "// any :: (a -> Bool) -> [a] -> Bool\nconst any = p =>\n    // True if p(x) holds for at least\n    // one item in xs.\n    xs => [...xs].some(p);",
  "anyTree": "// anyTree :: (a -> Bool) -> Tree a -> Bool\nconst anyTree = p =>\n    // True if p holds for any node of the\n    // tree to which anyTree(p) is applied.\n    foldTree(x => xs => p(x) || xs.some(Boolean));",
  "ap (<*>)": "// ap (<*>) :: Monad m => m (a -> b) -> m a -> m b\nconst ap = mf =>\n    // Applies wrapped functions to wrapped values,\n    // for example applying a list of functions to a list\n    // of values or applying:\n    // Just(f) to Just(x),  Right(f) to Right(x),\n    // f(x) to g(x) etc.\n    mx => ({\n        \"Either\": () => apLR,\n        \"Maybe\": () => apMay,\n        \"Node\": () => apTree,\n        \"Tuple\": () => apTuple,\n        \"List\": () => apList,\n        \"(a -> b)\": () => apFn\n    })[typeName(mx) || \"List\"]()(mf)(mx);",
  "apFn": "// apFn :: (a -> b -> c) -> (a -> b) -> (a -> c)\nconst apFn = f =>\n    // Applicative instance for functions.\n    // f(x) applied to g(x).\n    g => x => f(x)(\n        g(x)\n    );",
  "apLR (<*>)": "// apLR (<*>) :: Either e (a -> b) -> Either e a -> Either e b\nconst apLR = flr =>\n    // Either a Left value, or the application of a\n    // function in Either to a value in Either.\n    liftA2LR(x => x)(flr);",
  "apList (<*>)": "// apList (<*>) :: [(a -> b)] -> [a] -> [b]\nconst apList = fs =>\n    // The sequential application of each of a list\n    // of functions to each of a list of values.\n    // apList([x => 2 * x, x => 20 + x])([1, 2, 3])\n    //     -> [2, 4, 6, 21, 22, 23]\n    xs => fs.flatMap(f => xs.map(f));",
  "apMay (<*>)": "// apMay (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\nconst apMay = mf =>\n    // Just an application of Maybe a function to\n    // to Maybe a value, or Nothing.\n    liftA2May(x => x)(mf);",
  "apTree (<*>)": "// apTree (<*>) :: Tree (a -> b) -> Tree a -> Tree b\nconst apTree = tf =>\n    // A new tree derived by applying each of a tree\n    // of functions to each node value in another tree.\n    liftA2Tree(\n        x => x\n    )(tf);",
  "apTuple (<*>)": "// apTuple (<*>) :: Monoid m => (m, (a -> b)) -> (m, a) -> (m, b)\nconst apTuple = tpl =>\n    liftA2Tuple(x => x)(tpl);",
  "append (<>)": "// append (<>) :: [a] -> [a] -> [a]\nconst append = xs =>\n    // Two lists joined into one.\n    ys => xs.concat(ys);",
  "appendFile": "// appendFile :: FilePath -> String -> IO Bool\nconst appendFile = fp =>\n    // The file at fp updated with a new string\n    // appended to its existing contents.\n    txt => {\n        const\n            oFullPath = ObjC.wrap(fp)\n            .stringByStandardizingPath,\n            ref = Ref();\n\n        return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            oFullPath\n            .stringByStandardizingPath, ref\n        ) ? (\n                0 === ref[0] ? (() => {\n                    const\n                        oData = ObjC.wrap(txt)\n                        .dataUsingEncoding($.NSUTF8StringEncoding),\n                        h = $.NSFileHandle.fileHandleForWritingAtPath(\n                            oFullPath\n                        );\n\n                    return (\n                        h.seekToEndOfFile,\n                        h.writeData(oData),\n                        h.closeFile,\n                        true\n                    );\n                })() : false\n            ) : doesDirectoryExist(takeDirectory(ObjC.unwrap(fp))) ? (\n                writeFile(oFullPath)(txt),\n                true\n            ) : false;\n    };",
  "appendFileMay": "// appendFileMay :: FilePath -> String -> Maybe IO FilePath\nconst appendFileMay = strPath =>\n    // Just the fully-expanded file path of\n    // any file at found strPath, after it has been\n    // updated by appending the given string, or\n    // Nothing if no file is found at that path,\n    // or the file is found but can not be updated.\n    txt => {\n        const\n            oFullPath = ObjC.wrap(strPath)\n            .stringByStandardizingPath,\n            strFullPath = ObjC.unwrap(oFullPath),\n            ref = Ref();\n\n        return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            oFullPath\n            .stringByStandardizingPath, ref\n        ) ? (\n                0 === ref[0] ? (() => {\n                    const\n                        oData = ObjC.wrap(txt)\n                        .dataUsingEncoding($.NSUTF8StringEncoding),\n                        h = $.NSFileHandle\n                        .fileHandleForWritingAtPath(oFullPath);\n\n                    return (\n                        h.seekToEndOfFile,\n                        h.writeData(oData),\n                        h.closeFile, {\n                            Nothing: false,\n                            Just: strFullPath\n                        }\n                    );\n                })() : Nothing()\n                // Text appending to directory is undefined\n            ) : doesDirectoryExist(takeDirectory(strFullPath)) ? (\n                writeFile(oFullPath)(txt),\n                Just(strFullPath)\n            ) : Nothing();\n    };",
  "appendGen": "// appendGen (++) :: Gen [a] -> Gen [a] -> Gen [a]\nconst appendGen = xs =>\n// A new generator composed from the\n// concatenation of two existing generators.\n    function *(ys) {\n        for (const vs of [xs, ys]) {\n            let nxt = vs.next();\n\n            while (!nxt.done) {\n                yield nxt.value;\n                nxt = vs.next();\n            }\n        }\n    };",
  "apply ($)": "// apply ($) :: (a -> b) -> a -> b\nconst apply = f =>\n    // Application operator.\n    x => f(x);",
  "applyN": "// applyN :: Int -> (a -> a) -> a -> a\nconst applyN = n =>\n    // The value of n applications of f to x.\n    // (Church numeral n)\n    f => x => Array.from({\n        length: n\n    }, () => f)\n    .reduce((a, g) => g(a), x);",
  "approxRatio": "// approxRatio :: Float -> Float -> Ratio\nconst approxRatio = epsilon =>\n    // A ratio derived by approximation\n    // (at granularity epsilon) to the float n.\n    n => {\n        const\n            gcde = (e, x, y) => {\n                const gcd1 = (a, b) => b < e ? (\n                    a\n                ) : gcd1(b, a % b);\n\n                return gcd1(abs(x), abs(y));\n            },\n            c = gcde(\n                Boolean(epsilon) ? (\n                    epsilon\n                ) : (1 / 10000), 1, abs(n)\n            ),\n            r = ratio(quot(abs(n))(c))(quot(1, c));\n\n        return {\n            type: \"Ratio\",\n            n: r.n * signum(n),\n            d: r.d\n        };\n    };",
  "argvLength": "// argvLength :: Function -> Int\nconst argvLength = f =>\n    f.length;",
  "assocs": "// assocs :: Map k a -> [(k, a)]\nconst assocs = m =>\n    Object.entries(m).map(\n        kv => Tuple(...kv)\n    );",
  "base64decode": "// base64decode :: String -> String\nconst base64decode = s =>\n    ObjC.unwrap(\n        $.NSString.alloc.initWithDataEncoding(\n            $.NSData.alloc.initWithBase64EncodedStringOptions(\n                s, 0\n            ),\n            $.NSUTF8StringEncoding\n        )\n    );",
  "base64encode": "// base64encode :: String -> String\nconst base64encode = s =>\n    ObjC.unwrap(\n        $.NSString.stringWithString(s)\n        .dataUsingEncoding(\n            $.NSUTF8StringEncoding\n        )\n        .base64EncodedStringWithOptions(0)\n    );",
  "bimap": "// bimap :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)\nconst bimap = f =>\n    // Tuple instance of bimap.\n    // A tuple of the application of f and g to the\n    // first and second values respectively.\n    g => tpl => 2 !== tpl.length ? (\n        bimapN(f)(g)(tpl)\n    ) : Tuple(f(tpl[0]))(\n        g(tpl[1])\n    );",
  "bimapLR": "// bimapLR :: (a -> b) -> (c -> d) -> ֵEither ֵֵa c -> Either b d\nconst bimapLR = f =>\n    // Instance of bimap for Either values.\n    // Either the application of f to a Left value,\n    // or the application of g to a Right value.\n    g => lr => lr.Left ? (\n        Left(f(lr.Left))\n    ) : Right(g(lr.Right));",
  "bimapN": "// bimapN :: (a -> b) -> (c -> d) -> TupleN -> TupleN\nconst bimapN = f =>\n    // An n-tuple instance of bimap.\n    // An n-tuple of unchanged dimension in which\n    // the final value is an application of g\n    // and the penultimate value is an application of f.\n    g => tpln => {\n        const n = tpln.length;\n\n        return 1 < n ? (\n            TupleN(\n                ...Array.from(tpln).slice(0, n - 2),\n                f(tpln[n - 2]), g(tpln[n - 1])\n            )\n        ) : null;\n    };",
  "bind (>>=)": "// bind (>>=) :: Monad m => m a -> (a -> m b) -> m b\nconst bind = m =>\n    // Two computations sequentially composed,\n    // with any value produced by the first\n    // passed as an argument to the second.\n    mf => Array.isArray(m) ? (\n        bindList(m)(mf)\n    ) : (\n        ({\n            \"Either\": () => bindLR,\n            \"Maybe\": () => bindMay,\n            \"Tuple\": () => bindTuple,\n            \"function\": () => bindFn\n        })[m.type || typeof m]()(m)(mf)\n    );",
  "bindFn (>>=)": "// bindFn (>>=) :: (a -> b) -> (b -> a -> c) -> a -> c\nconst bindFn = f =>\n    // Binary operator applied over f x and x.\n    op => x => op(f(x))(x);",
  "bindLR (>>=)": "// bindLR (>>=) :: Either a ->\n// (a -> Either b) -> Either b\nconst bindLR = m =>\n    mf => m.Left ? (\n        m\n    ) : mf(m.Right);",
  "bindList (>>=)": "// bindList (>>=) :: [a] -> (a -> [b]) -> [b]\nconst bindList = xs =>\n    mf => [...xs].flatMap(mf);",
  "bindMay (>>=)": "// bindMay (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\nconst bindMay = mb =>\n    // Nothing if mb is Nothing, or the application of the\n    // (a -> Maybe b) function mf to the contents of mb.\n    mf => mb.Nothing ? (\n        mb\n    ) : mf(mb.Just);",
  "bindTuple (>>=)": "// bindTuple (>>=) :: Monoid a => (a, a) -> (a -> (a, b)) -> (a, b)\nconst bindTuple = tpl =>\n    f => {\n        const t2 = f(tpl[1]);\n\n        return Tuple(\n            mappend(tpl[0])(t2[0])\n        )(\n            t2[1]\n        );\n    };",
  "bool": "// bool :: a -> a -> Bool -> a\nconst bool = f =>\n    t => p => p ? t : f;",
  "break": "// break :: (a -> Bool) -> [a] -> ([a], [a])\nconst break_ = p =>\n    xs => {\n        const i = xs.findIndex(p);\n\n        return -1 !== i ? (\n            Tuple(xs.slice(0, i))(\n                xs.slice(i)\n            )\n        ) : Tuple(xs)([]);\n    };",
  "breakOn": "// breakOn :: String -> String -> (String, String)\nconst breakOn = pat =>\n    // Needle -> Haystack -> (prefix before match, match + rest)\n    src => 0 < pat.length ? (() => {\n        const xs = src.split(pat);\n\n        return 1 < xs.length ? Tuple(\n            xs[0], src.slice(xs[0].length)\n        ) : Tuple(src)(\"\");\n    })() : null;",
  "breakOnAll": "// breakOnAll :: String -> String -> [(String, String)]\nconst breakOnAll = pat =>\n    src => \"\" !== pat ? (\n        src.split(pat)\n        .reduce((a, _, i, xs) =>\n            0 < i ? (\n                a.concat([\n                    Tuple(xs.slice(0, i).join(pat))(\n                        pat + xs.slice(i).join(pat)\n                    )\n                ])\n            ) : a, [])\n    ) : null;",
  "breakOnMay": "// breakOnMay :: String -> String -> Maybe (String, String)\nconst breakOnMay = pat =>\n    // Needle -> Haystack ->\n    // maybe (prefix before match, match + rest)\n    src => Boolean(pat) ? (() => {\n        const xs = src.split(pat);\n\n        return Just(0 < xs.length ? Tuple(\n            xs[0], src.slice(xs[0].length)\n        ) : Tuple(src)(\"\"));\n    })() : Nothing();",
  "bulleted": "// bulleted :: String -> String -> String\nconst bulleted = strTab =>\n    s => s.split(/[\\n\\r]+/u).map(\n        x => \"\" !== x ? (\n            `${strTab}- ${x}`\n        ) : x\n    )\n    .join(\"\\n\");",
  "cartesianProduct": "// cartesianProduct :: [a] -> [b] -> [[a, b]]\nconst cartesianProduct = xs =>\n    ys => [...xs].flatMap(\n        x => [...ys].flatMap(\n            y => [\n                [x].concat(y)\n            ]\n        )\n    );",
  "caseOf": "// caseOf :: [(a -> Bool, b)] -> b -> a ->  b\nconst caseOf = pvs =>\n    // List of (Predicate, value) tuples ->\n    // Default value -> Value to test -> Output value\n    otherwise => x => {\n        const mb = pvs.reduce((a, pv) =>\n            a.Nothing ? (\n                pv[0](x) ? Just(pv[1]) : a\n            ) : a, Nothing());\n\n        return mb.Nothing ? otherwise : mb.Just;\n    };",
  "catMaybes": "// catMaybes :: [Maybe a] -> [a]\nconst catMaybes = mbs =>\n    mbs.flatMap(m => m.Nothing ? [] : [m.Just]);",
  "ceiling": "// ceiling :: Num -> Int\nconst ceiling = x => {\n    // The least integer not less than x.\n    const\n        nr = properFraction(x),\n        n = nr[0];\n\n    return 0 < nr[1] ? 1 + n : n;\n};",
  "center": "// center :: Int -> Char -> String -> String\nconst center = n =>\n    // Size of space -> filler Char ->\n    // String -> Centered String\n    c => s => {\n        const gap = n - s.length;\n\n        return 0 < gap ? (() => {\n            const pre = c.repeat(Math.floor(gap / 2));\n\n            return pre + s + pre + c.repeat(gap % 2);\n        })() : s;\n    };",
  "chars": "// chars :: String -> [Char]\nconst chars = s =>\n    s.split(\"\");",
  "chop": "// chop :: ([a] -> (b, [a])) -> [a] -> [b]\nconst chop = f =>\n    // A segmentation of xs by tail recursion with a\n    // function which returns a (prefix, residue) tuple.\n    xs => {\n        const go = ys =>\n            0 < ys.length ? (() => {\n                const [b, bs] = Array.from(f(ys));\n\n                return [b].concat(go(bs));\n            })() : [];\n\n        return go([...xs]);\n    };",
  "chr": "// chr :: Int -> Char\nconst chr = x =>\n    // The character at unix code-point x.\n    String.fromCodePoint(x);",
  "chunksOf": "// chunksOf :: Int -> [a] -> [[a]]\nconst chunksOf = n => {\n    // xs split into sublists of length n.\n    // The last sublist will be short if n\n    // does not evenly divide the length of xs .\n    const go = xs => {\n        const chunk = xs.slice(0, n);\n\n        return 0 < chunk.length ? (\n            [chunk].concat(\n                go(xs.slice(n))\n            )\n        ) : [];\n    };\n\n    return go;\n};",
  "combine": "// combine (</>) :: FilePath -> FilePath -> FilePath\nconst combine = fp =>\n    // Two paths combined with a path separator.\n    // Just the second path if that starts with\n    // a path separator.\n    fp1 => Boolean(fp) && Boolean(fp1) ? (\n        \"/\" === fp1.slice(0, 1) ? (\n            fp1\n        ) : \"/\" === fp.slice(-1) ? (\n            fp + fp1\n        ) : `${fp}/${fp1}`\n    ) : fp + fp1;",
  "compare": "// compare :: a -> a -> Ordering\nconst compare = a =>\n  b => a < b ? -1 : (a > b ? 1 : 0);",
  "comparing": "// comparing :: (a -> b) -> (a -> a -> Ordering)\nconst comparing = f =>\n    x => y => {\n        const\n            a = f(x),\n            b = f(y);\n\n        return a < b ? -1 : (a > b ? 1 : 0);\n    };",
  "compose (<<<)": "// compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\nconst compose = (...fs) =>\n    // A function defined by the right-to-left\n    // composition of all the functions in fs.\n    fs.reduce(\n        (f, g) => x => f(g(x)),\n        x => x\n    );",
  "composeList": "// composeList :: [(a -> a)] -> (a -> a)\nconst composeList = fs =>\n    fs.reduce(\n        (f, g) => x => f(g(x)),\n        x => x\n    );",
  "composeListR": "// composeListR :: [(a -> a)] -> (a -> a)\nconst composeListR = fs =>\n    x => fs.reduce((a, f) => f(a), x);",
  "composeR (>>>)": "// composeR (>>>) :: (a -> b) -> (b -> c) -> a -> c\nconst composeR = f =>\n    g => x => f(g(x));",
  "concat": "// concat :: [[a]] -> [a]\n// concat :: [String] -> String\nconst concat = xs =>\n    0 < xs.length || Array.isArray(xs) ? (\n        (\n            xs.every(x => \"string\" === typeof x) ? (\n                \"\"\n            ) : []\n        ).concat(...xs)\n    ) : xs;",
  "concatMap": "// concatMap :: (a -> [b]) -> [a] -> [b]\nconst concatMap = f =>\n    // Concatenated results of a map of f over xs.\n    // f is any function which returns a list value.\n    // Any empty lists returned are filtered out by\n    // the concatenation.\n    xs => xs.flatMap(f);",
  "cons": "// cons :: a -> [a] -> [a]\nconst cons = x =>\n// A list constructed from the item x,\n// followed by the existing list xs.\n    xs => Array.isArray(xs) ? (\n        [x].concat(xs)\n    ) : \"GeneratorFunction\" !== xs.constructor.constructor.name ? (\n        x + xs\n    ) : (\n        function *() {\n            yield x;\n            let nxt = xs.next();\n\n            while (!nxt.done) {\n                yield nxt.value;\n                nxt = xs.next();\n            }\n        }());",
  "constant": "// constant :: a -> b -> a\nconst constant = k =>\n    _ => k;",
  "copyFileLR": "// copyFileLR :: FilePath -> FilePath -> Either String IO ()\nconst copyFileLR = fpFrom =>\n    fpTo => {\n        const fpTargetFolder = takeDirectory(fpTo);\n\n        return doesFileExist(fpFrom) ? (\n            doesDirectoryExist(fpTargetFolder) ? (() => {\n                const\n                    e = $(),\n                    blnCopied = ObjC.unwrap(\n                        $.NSFileManager.defaultManager\n                        .copyItemAtPathToPathError(\n                            $(fpFrom).stringByStandardizingPath,\n                            $(fpTo).stringByStandardizingPath,\n                            e\n                        )\n                    );\n\n                return blnCopied ? (\n                    Right(fpTo)\n                ) : Left(ObjC.unwrap(e.localizedDescription));\n\n            })() : Left(\n                `Target folder not found: ${fpTargetFolder}`\n            )\n        ) : Left(`Source file not found: ${fpFrom}`);\n    };",
  "createDirectoryIfMissingLR": "// createDirectoryIfMissingLR :: Bool -> FilePath\n// -> Either String FilePath\nconst createDirectoryIfMissingLR = blnParents =>\n    dirPath => {\n        const fp = filePath(dirPath);\n\n        return doesPathExist(fp) ? (\n            Right(fp)\n        ) : (() => {\n            const\n                e = $(),\n                blnOK = $.NSFileManager\n                .defaultManager[\n                    \"createDirectoryAtPath\" + (\n                        \"WithIntermediateDirectories\"\n                    ) + \"AttributesError\"\n                ](fp, blnParents, void 0, e);\n\n            return blnOK ? (\n                Right(fp)\n            ) : Left(e.localizedDescription);\n        })();\n    };",
  "curry": "// curry :: ((a, b) -> c) -> a -> b -> c\nconst curry = f =>\n    a => b => f(a, b);",
  "curryN": "// curryN :: Curry a b => a -> b\nconst curryN = f =>\n    // A curried function derived from a\n    // function over a tuple of any order.\n    (...args) => {\n        const\n            go = xs => f.length <= xs.length ? (\n                f(...xs)\n            ) : (...ys) => go(xs.concat(ys));\n\n        return go(args);\n    };",
  "cycle": "// cycle :: [a] -> Generator [a]\nconst cycle = function *(xs) {\n    // An infinite repetition of xs,\n    // from which an arbitrary prefix\n    // may be taken.\n    const lng = xs.length;\n    let i = 0;\n\n    while (true) {\n        yield xs[i];\n        i = (1 + i) % lng;\n    }\n};",
  "decodedPath": "// decodedPath :: Percent Encoded String -> FilePath\nconst decodedPath = decodeURI;",
  "degrees": "// degrees :: Float x => Radians x -> Degrees x\nconst degrees = r =>\n    (180 / Math.PI) * r;",
  "delete": "// delete :: Eq a => a -> [a] -> [a]\nconst delete_ = x => {\n    // xs with first instance of x (if any) removed.\n    const go = xs =>\n        0 < xs.length ? (\n            (x === xs[0]) ? (\n                xs.slice(1)\n            ) : [xs[0]].concat(go(xs.slice(1)))\n        ) : [];\n\n    return go;\n};",
  "deleteAt": "// deleteAt :: Int -> [a] -> [a]\nconst deleteAt = i =>\n    xs => i <= xs.length ? (() => {\n        const lr = splitAt(i)(xs);\n\n        return lr[0].concat(lr[1].slice(1));\n    })() : xs;",
  "deleteBy": "// deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]\nconst deleteBy = fEq =>\n    x => {\n        const go = xs => 0 < xs.length ? (\n            fEq(x)(xs[0]) ? (\n                xs.slice(1)\n            ) : [xs[0]].concat(go(xs.slice(1)))\n        ) : [];\n\n        return go;\n    };",
  "deleteFirst": "// deleteFirst :: a -> [a] -> [a]\nconst deleteFirst = x => {\n    const go = xs => 0 < xs.length ? (\n        x === xs[0] ? (\n            xs.slice(1)\n        ) : [xs[0]].concat(go(xs.slice(1)))\n    ) : [];\n\n    return go;\n};",
  "deleteFirstsBy": "// deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst deleteFirstsBy = fEq =>\n    // The first list purged of the first instance of\n    // each predicate-matching element in the second list.\n    foldl(flip(deleteBy(fEq)));",
  "deleteKey": "// deleteKey :: String -> Dict -> Dict\nconst deleteKey = k =>\n    // A new dictionary, without the key k.\n    dct => {\n        const dct2 = Object.assign({}, dct);\n\n        return (delete dct2[k], dct2);\n    };",
  "dictFromList": "// dictFromList :: [(k, v)] -> Dict\nconst dictFromList = kvs =>\n    Object.fromEntries(kvs);",
  "difference": "// difference :: Eq a => [a] -> [a] -> [a]\nconst difference = xs =>\n    ys => {\n        const s = new Set(ys);\n\n        return xs.filter(x => !s.has(x));\n    };",
  "differenceGen": "// differenceGen :: Gen [a] -> Gen [a] -> Gen [a]\nconst differenceGen = ga =>\n    function *(gb) {\n        // All values of generator stream ga except any\n        // already seen in generator stream gb.\n        const\n            stream = zipGen(ga)(gb),\n            sb = new Set([]);\n\n        let xy = take(1)(stream);\n\n        while (0 < xy.length) {\n            const [x, y] = Array.from(xy[0]);\n\n            sb.add(y);\n            if (!sb.has(x)) {\n                yield x;\n            }\n            xy = take(1)(stream);\n        }\n    };",
  "digitToInt": "// digitToInt :: Char -> Int\nconst digitToInt = c => {\n    const\n        ord = x => x.codePointAt(0),\n        oc = ord(c);\n\n    return 48 > oc || 102 < oc ? (\n        null\n    ) : (() => {\n        const\n            dec = oc - ord(\"0\"),\n            hexu = oc - ord(\"A\"),\n            hexl = oc - ord(\"a\");\n\n        return 9 >= dec ? (\n            dec\n        ) : 0 <= hexu && 5 >= hexu ? (\n            10 + hexu\n        ) : 0 <= hexl && 5 >= hexl ? (\n            10 + hexl\n        ) : null;\n    })();\n};",
  "div": "// div :: Int -> Int -> Int\nconst div = x =>\n    y => Math.floor(x / y);",
  "divMod": "// divMod :: Int -> Int -> (Int, Int)\nconst divMod = n => d => {\n    // Integer division, truncated toward negative infinity,\n    // and integer modulus such that:\n    // (x `div` y)*y + (x `mod` y) == x\n    const [q, r] = [Math.trunc(n / d), n % d];\n\n    return signum(n) === signum(-d) ? (\n        Tuple(q - 1)(r + d)\n    ) : Tuple(q)(r);\n};",
  "doesDirectoryExist": "// doesDirectoryExist :: FilePath -> IO Bool\nconst doesDirectoryExist = fp => {\n    const ref = Ref();\n\n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            $(fp)\n            .stringByStandardizingPath, ref\n        ) && ref[0];\n};",
  "doesFileExist": "// doesFileExist :: FilePath -> IO Bool\nconst doesFileExist = fp => {\n    const ref = Ref();\n\n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            $(fp)\n            .stringByStandardizingPath, ref\n        ) && 1 !== ref[0];\n};",
  "doesPathExist": "// doesPathExist :: FilePath -> IO Bool\nconst doesPathExist = fp =>\n    $.NSFileManager.defaultManager\n    .fileExistsAtPath(\n        $(fp).stringByStandardizingPath\n    );",
  "dot": "// dot (.) :: (b -> c) -> (a -> b) -> a -> c\nconst dot = f =>\n    // The composition of two functions.\n    g => x => f(g(x));",
  "draw": "// draw :: Tree String -> [String]\nconst draw = node => {\n    // shift :: String -> String -> [String] -> [String]\n    const shifted = (first, other, xs) => (\n        [first].concat(\n            Array.from({\n                length: xs.length - 1\n            }, () => other)\n        ).map(\n            (y, i) => y.concat(xs[i])\n        )\n    );\n    // drawSubTrees :: [Tree String] -> [String]\n    const drawSubTrees = xs => {\n        const lng = xs.length;\n\n        return 0 < lng ? (\n            1 < lng ? (\n                [\"│\"].concat(\n                    shifted(\"├─ \", \"│  \", draw(xs[0]))\n                )\n            ).concat(\n                drawSubTrees(xs.slice(1))\n            ) : [\"│\"].concat(\n                shifted(\"└─ \", \"   \", draw(xs[0]))\n            )\n        ) : [];\n    };\n\n    return node.root.split(\"\\n\").concat(\n        drawSubTrees(node.nest)\n    );\n};",
  "drawForest": "// drawForest :: [Tree String] -> String\nconst drawForest = trees =>\n    trees.map(drawTree).join(\"\\n\");",
  "drawTree": "// drawTree :: Tree String -> String\nconst drawTree = tree =>\n    draw(tree).join(\"\\n\");",
  "drawTree2": "// drawTree2 :: Bool -> Bool -> Tree String -> String\nconst drawTree2 = blnCompact => blnPruned => tree => {\n    // Tree design and algorithm inspired by the Haskell snippet at:\n    // https://doisinkidney.com/snippets/drawing-trees.html\n    const\n        // Lefts, Middle, Rights\n        lmrFromStrings = xs => {\n            const [ls, rs] = Array.from(splitAt(\n                Math.floor(xs.length / 2)\n            )(xs));\n\n            return TupleN(ls, rs[0], rs.slice(1));\n        },\n        stringsFromLMR = lmr =>\n        Array.from(lmr).reduce((a, x) => a.concat(x), []),\n        fghOverLMR = (f, g, h) => lmr => {\n            const [ls, m, rs] = Array.from(lmr);\n\n            return TupleN(ls.map(f), g(m), rs.map(h));\n        };\n    const lmrBuild = (f, w) => wsTree => {\n        const\n            leftPad = n => s => \" \".repeat(n) + s,\n            xs = wsTree.nest,\n            lng = xs.length,\n            [nChars, x] = Array.from(wsTree.root);\n\n        // ------------------ LEAF NODE ------------------\n        return 0 === lng ? (\n            TupleN([], \"─\".repeat(w - nChars) + x, [])\n\n            // --------- NODE WITH SINGLE CHILD ----------\n        ) : 1 === lng ? (() => {\n            const indented = leftPad(1 + w);\n\n            return fghOverLMR(\n                indented,\n                z => `${\"─\".repeat(w - nChars)}${x}-${z}`,\n                indented\n            )(f(xs[0]));\n\n            // ----------- NODE WITH CHILDREN ------------\n        })() : (() => {\n            const\n                cFix = y => ys => y + ys,\n                treeFix = (l, m, r) => compose(\n                    stringsFromLMR,\n                    fghOverLMR(cFix(l), cFix(m), cFix(r))\n                ),\n                _x = \"─\".repeat(w - nChars) + x,\n                indented = leftPad(w),\n                lmrs = xs.map(f);\n\n            return fghOverLMR(\n                indented,\n                s => _x + ({\n                    \"┌\": \"┬\",\n                    \"├\": \"┼\",\n                    \"│\": \"┤\",\n                    \"└\": \"┴\"\n                })[s[0]] + s.slice(1),\n                indented\n            )(lmrFromStrings(\n                intercalate(\n                    blnCompact ? [] : [\"│\"]\n                )(\n                    [treeFix(\" \", \"┌\", \"│\")(lmrs[0])]\n                    .concat(init(lmrs.slice(1)).map(\n                        treeFix(\"│\", \"├\", \"│\")\n                    ))\n                    .concat([treeFix(\"│\", \"└\", \" \")(\n                        lmrs[lmrs.length - 1]\n                    )])\n                )\n            ));\n        })();\n    };\n    const\n        measuredTree = fmapTree(\n            v => {\n                const s = ` ${v} `;\n\n                return Tuple(s.length)(s);\n            })(tree),\n        levelWidths = levels(measuredTree)\n        .reduce(\n            (a, level) => a.concat(maximum(level.map(fst))),\n            []\n        ),\n        treeLines = stringsFromLMR(\n            levelWidths.reduceRight(\n                lmrBuild, x => x\n            )(measuredTree)\n        );\n\n    return unlines(\n        blnPruned ? (\n            treeLines.filter(\n                s => s.split(\"\")\n                .some(c => !\" │\".includes(c))\n            )\n        ) : treeLines\n    );\n};",
  "drop": "// drop :: Int -> [a] -> [a]\n// drop :: Int -> Generator [a] -> Generator [a]\n// drop :: Int -> String -> String\nconst drop = n =>\n    xs => Infinity > length(xs) ? (\n        xs.slice(n)\n    ) : (take(n)(xs), xs);",
  "dropAround": "// dropAround :: (a -> Bool) -> [a] -> [a]\n// dropAround :: (Char -> Bool) -> String -> String\nconst dropAround = p =>\n    xs => dropWhile(p)(\n        dropWhileEnd(p)(xs)\n    );",
  "dropFileName": "// dropFileName :: FilePath -> FilePath\nconst dropFileName = fp =>\n    \"\" !== fp ? (() => {\n        const\n            xs = (fp.split(\"/\"))\n            .slice(0, -1);\n\n        return 0 < xs.length ? (\n            `${xs.join(\"/\")}/`\n        ) : \"./\";\n    })() : \"./\";",
  "dropLength": "// dropLength :: [a] -> [b] -> [b]\nconst dropLength = xs =>\n    ys => {\n        const go = (x, y) =>\n            0 < x.length ? (\n                0 < y.length ? (\n                    go(x.slice(1), y.slice(1))\n                ) : []\n            ) : y;\n\n        return go(xs, ys);\n    };",
  "dropLengthMaybe": "// dropLengthMaybe :: [a] -> [b] -> Maybe [b]\nconst dropLengthMaybe = xs =>\n    ys => {\n        const go = (x, y) =>\n            0 < x.length ? (\n                0 < y.length ? (\n                    go(x.slice(1), y.slice(1))\n                ) : Nothing()\n            ) : Just(y);\n\n        return go(xs, ys);\n    };",
  "dropWhile": "// dropWhile :: (a -> Bool) -> [a] -> [a]\n// dropWhile :: (Char -> Bool) -> String -> String\nconst dropWhile = p =>\n    // The suffix remainining after takeWhile p xs.\n    xs => {\n        const n = xs.length;\n\n        return xs.slice(\n            0 < n ? until(\n                i => n === i || !p(xs[i])\n            )(i => 1 + i)(0) : 0\n        );\n    };",
  "dropWhileEnd": "// dropWhileEnd :: (a -> Bool) -> [a] -> [a]\n// dropWhileEnd :: (Char -> Bool) -> String -> [Char]\nconst dropWhileEnd = p =>\n    // xs without the longest suffix for which\n    // p returns true for all elements.\n    xs => xs.slice(\n        0,\n        1 + until(\n            i => (0 >= i) || !p(xs[i])\n        )(\n            x => x - 1\n        )(xs.length - 1)\n    );",
  "dropWhileGen": "// dropWhileGen :: (a -> Bool) -> Gen [a] -> [a]\nconst dropWhileGen = p =>\n    xs => {\n        let\n            nxt = xs.next(),\n            v = nxt.value;\n\n        while (!nxt.done && p(v)) {\n            nxt = xs.next();\n            v = nxt.value;\n        }\n\n        return cons(v)(xs);\n    };",
  "either": "// either :: (a -> c) -> (b -> c) -> Either a b -> c\nconst either = fl =>\n    // Application of the function fl to the\n    // contents of any Left value in e, or\n    // the application of fr to its Right value.\n    fr => e => e.Left ? (\n        fl(e.Left)\n    ) : fr(e.Right);",
  "elem": "// elem :: Eq a => a -> [a] -> Bool\nconst elem = x =>\n    // True if xs contains an instance of x.\n    xs => {\n        const t = xs.constructor.name;\n\n        return \"Array\" !== t ? (\n            xs[\"Set\" !== t ? \"includes\" : \"has\"](x)\n        ) : xs.some(eq(x));\n    };",
  "elemAtMay": "// elemAtMay :: Int -> Dict -> Maybe (String, a)\n// elemAtMay :: Int -> [a] -> Maybe a\nconst elemAtMay = i =>\n    // Just the item at the indexed position in an array,\n    // or in the lexically sorted key-values of a dict,\n    // or Nothing, if the index is out of range.\n    obj => {\n        const\n            vs = Array.isArray(obj) ? (\n                obj\n            ) : Object.entries(obj).sort(\n                (a, b) => b[0].localeCompare(a[0])\n            );\n\n        return (0 <= i) && (i < vs.length) ? (\n            Just(vs[i])\n        ) : Nothing();\n    };",
  "elemIndex": "// elemIndex :: Eq a => a -> [a] -> Maybe Int\nconst elemIndex = x =>\n    // Just the index of x in xs, if it is found,\n    // or Nothing, if xs does not contain x.\n    xs => {\n        const i = xs.indexOf(x);\n\n        return -1 === i ? (\n            Nothing()\n        ) : Just(i);\n    };",
  "elemIndices": "// elemIndices :: Eq a => a -> [a] -> [Int]\nconst elemIndices = x =>\n    // The indices at which x occurs in xs.\n    xs => [...xs].flatMap(\n        (y, i) => y === x ? (\n            [i]\n        ) : []\n    );",
  "elems": "// elems :: Map k a -> [a]\n// elems :: Set a -> [a]\nconst elems = x =>\n    \"Set\" !== x.constructor.name ? (\n        Object.values(x)\n    ) : Array.from(x.values());",
  "encodedPath": "// encodedPath :: FilePath -> Percent Encoded String\nconst encodedPath = encodeURI;",
  "enumFrom": "// enumFrom :: Enum a => a -> [a]\nconst enumFrom = function* (x) {\n    // A non-finite succession of enumerable\n    // values, starting with the value x.\n    let v = x;\n\n    while (true) {\n        yield v;\n        v = succ(v);\n    }\n};",
  "enumFromPairs": "// enumFromPairs :: String -> [(String, Int)] -> Dict\nconst enumFromPairs = enumName =>\n    kvs => {\n        const\n            iMax = kvs[kvs.length - 1][1],\n            iMin = kvs[0][1];\n\n        return kvs.reduce(\n            (a, kv) => Object.assign(\n                a, {\n                    [kv[0]]: {\n                        \"type\": \"enum\",\n                        \"name\": enumName,\n                        \"key\": kv[0],\n                        \"max\": iMax,\n                        \"min\": iMin,\n                        \"value\": kv[1]\n                    },\n                    [kv[1]]: kv[0]\n                }\n            ), {}\n        );\n    };",
  "enumFromThen": "// enumFromThen :: Int -> Int -> Gen [Int]\nconst enumFromThen = x =>\n    // A non-finite stream of integers,\n    // starting with x and y, and continuing\n    // with the same interval.\n    function* (y) {\n        const d = y - x;\n        let v = y + d;\n\n        yield x;\n        yield y;\n        while (true) {\n            yield v;\n            v = d + v;\n        }\n    };",
  "enumFromThenTo": "// enumFromThenTo :: Int -> Int -> Int -> [Int]\nconst enumFromThenTo = m =>\n    // Integer values enumerated from m to n\n    // with a step defined by (nxt - m).\n    nxt => n => {\n        const d = nxt - m;\n\n        return Array.from({\n            length: (Math.floor(n - nxt) / d) + 2\n        }, (_, i) => m + (d * i));\n    };",
  "enumFromThenToChar": "// enumFromThenToChar :: Char -> Char -> Char -> [Char]\nconst enumFromThenToChar = x1 =>\n    x2 => y => {\n        const [i1, i2, iY] = Array.from([x1, x2, y])\n            .map(x => x.codePointAt(0)),\n            d = i2 - i1;\n\n        return Array.from({\n            length: (Math.floor(iY - i2) / d) + 2\n        }, (_, i) => String.fromCodePoint(i1 + (d * i)));\n    };",
  "enumFromTo": "// enumFromTo :: Int -> Int -> [Int]\nconst enumFromTo = m =>\n    n => !isNaN(m) ? (\n        Array.from({\n            length: 1 + n - m\n        }, (_, i) => m + i)\n    ) : enumFromTo_(m)(n);",
  "enumFromToChar": "// enumFromToChar :: Char -> Char -> [Char]\nconst enumFromToChar = m => n => {\n    const [intM, intN] = [m, n].map(\n        x => x.codePointAt(0)\n    );\n\n    return Array.from({\n        length: Math.floor(intN - intM) + 1\n    }, (_, i) => String.fromCodePoint(intM + i));\n};",
  "enumFromTo_": "// enumFromTo_ :: Enum a => a -> a -> [a]\nconst enumFromTo_ = m => n => {\n    const [x, y] = [m, n].map(fromEnum),\n        b = x + (isNaN(m) ? 0 : m - x);\n\n    return Array.from({\n        length: 1 + (y - x)\n    }, (_, i) => toEnum(m)(b + i));\n};",
  "eq (==)": "// eq (==) :: Eq a => a -> a -> Bool\nconst eq = a =>\n    // True when a and b are equivalent in the terms\n    // defined below for their shared data type.\n    b => {\n        const t = typeof a;\n\n        return t !== typeof b ? (\n            false\n        ) : \"object\" !== t ? (\n            \"function\" !== t ? (\n                a === b\n            ) : a.toString() === b.toString()\n        ) : (() => {\n            const kvs = Object.entries(a);\n\n            return kvs.length !== Object.keys(b).length ? (\n                false\n            ) : kvs.every(([k, v]) => eq(v)(b[k]));\n        })();\n    };",
  "eqDate": "// eqDate :: Date -> Date -> Bool\nconst eqDate = dte =>\n    // True if the date parts of two date-time objects\n    // (ignoring the time parts) are the same.\n    dte1 => {\n        const dayOnly = dateTime =>\n            new Date(dateTime).setUTCHours(0, 0, 0, 0);\n\n        return dayOnly(dte) === dayOnly(dte1);\n    };",
  "evalJSLR": "// evalJSLR :: String -> Either String a\nconst evalJSLR = s => {\n    try {\n        // eslint-disable-next-line no-eval\n        return Right(eval(`(${s})`));\n    } catch (e) {\n        return Left(e.message);\n    }\n};",
  "evalJSMay": "// evalJSMay :: String -> Maybe a\nconst evalJSMay = s => {\n    try {\n        // eslint-disable-next-line no-eval\n        return Just(eval(`(${s})`));\n    } catch (e) {\n        return Nothing();\n    }\n};",
  "even": "// even :: Int -> Bool\nconst even = n =>\n    // True if 2 is a factor of n.\n    0 === n % 2;",
  "exp": "// exp :: Float -> Float\nconst exp = Math.exp;",
  "fTable": "// fTable :: String -> (a -> String) ->\n// (b -> String) -> (a -> b) -> [a] -> String\nconst fTable = s =>\n    // Heading -> x display function ->\n    //           fx display function ->\n    //    f -> values -> tabular string\n    xShow => fxShow => f => xs => {\n        const\n            ys = xs.map(xShow),\n            w = Math.max(...ys.map(y => [...y].length)),\n            table = zipWith(\n                a => b => `${a.padStart(w, \" \")} -> ${b}`\n            )(ys)(\n                xs.map(x => fxShow(f(x)))\n            ).join(\"\\n\");\n\n        return `${s}\\n${table}`;\n    };",
  "fType": "// fType :: (a -> f b) -> f\nconst fType = g => {\n    const s = g.toString();\n\n    return s.includes(\"Left\") ? (\n        Right\n    ) : s.includes(\"Nothing\") ? (\n        Just\n    ) : s.includes(\"Node\") ? (\n        flip(Node)([])\n    ) : x => [x];\n};",
  "fanArrow (&&&)": "// fanArrow (&&&) :: (a -> b) -> (a -> c) -> (a -> (b, c))\nconst fanArrow = f =>\n    // A function from x to a tuple of (f(x), g(x))\n    // ((,) . f <*> g)\n    g => x => Tuple(f(x))(\n        g(x)\n    );",
  "filePath": "// filePath :: String -> FilePath\nconst filePath = s =>\n    // The given file path with any tilde expanded\n    // to the full user directory path.\n    ObjC.unwrap(ObjC.wrap(s)\n        .stringByStandardizingPath);",
  "filePathTree": "// filePathTree :: filePath -> [Tree String] -> Tree FilePath\nconst filePathTree = fpAnchor => trees => {\n    const go = fp => tree => {\n        const path = `${fp}/${tree.root}`;\n\n        return Node(path)(\n            tree.nest.map(go(path))\n        );\n    };\n\n    return Node(fpAnchor)(\n      trees.map(go(fpAnchor))\n    );\n};",
  "fileSize": "// fileSize :: FilePath -> Either String Int\nconst fileSize = fp =>\n    bindLR(fileStatus(fp))(\n        dct => Right(ObjC.unwrap(dct.NSFileSize))\n    );",
  "fileStatus": "// fileStatus :: FilePath -> Either String Dict\nconst fileStatus = fp => {\n    const\n        e = $(),\n        dct = $.NSFileManager.defaultManager\n        .attributesOfItemAtPathError(\n            ObjC.wrap(fp).stringByStandardizingPath,\n            e\n        );\n\n    return dct.isNil() ? (\n        Left(ObjC.unwrap(e.localizedDescription))\n    ) : Right(ObjC.deepUnwrap(dct));\n};",
  "fileUTI": "// fileUTI :: FilePath -> Either String String\nconst fileUTI = fp => {\n    // ObjC.import('AppKit')\n    const\n        e = $(),\n        uti = $.NSWorkspace.sharedWorkspace\n        .typeOfFileError(fp, e);\n\n    return uti.isNil() ? (\n        Left(ObjC.unwrap(e.localizedDescription))\n    ) : Right(ObjC.unwrap(uti));\n};",
  "filter": "// filter :: (a -> Bool) -> [a] -> [a]\nconst filter = p =>\n    // The elements of xs which match\n    // the predicate p.\n    xs => [...xs].filter(p);",
  "filterGen": "// filterGen :: (a -> Bool) -> Gen [a] -> Gen [a]\nconst filterGen = p => xs => {\n    // Non-finite stream of values which are\n    // drawn from gen, and satisfy p\n    const go = function* () {\n        let x = xs.next();\n\n        while (!x.done) {\n            const v = x.value;\n\n            if (p(v)) {\n                yield v;\n            }\n            x = xs.next();\n        }\n    };\n\n    return go(xs);\n};",
  "filterTree": "// filterTree (a -> Bool) -> Tree a -> [a]\nconst filterTree = p =>\n    // List of all values in the tree\n    // which match the predicate p.\n    foldTree(x => xs => concat(\n        p(x) ? [\n            [x], ...xs\n        ] : xs\n    ));",
  "filteredSubTrees": "// filteredSubTrees :: (Tree a -> Bool) -> Tree a -> [Tree a]\nconst filteredSubTrees = p => {\n    const go = tree => (\n        p(tree.root) ? (\n            [tree]\n        ) : []\n    ).concat(tree.nest.flatMap(go));\n\n    return go;\n};",
  "filteredTree": "// filteredTree (a -> Bool) -> Tree a -> Tree a\nconst filteredTree = p =>\n    // A tree including only those children\n    // which either match the predicate p, or have\n    // descendants which match the predicate p.\n    foldTree(x => xs =>\n        Node(x)(xs.filter(\n            tree => (0 < tree.nest.length) || (\n                p(tree.root)\n            )\n        ))\n    );",
  "find": "// find :: (a -> Bool) -> [a] -> Maybe a\nconst find = p =>\n    // Just the first element in xs which\n    // matches the predicate p, or\n    // Nothing if no match is found.\n    xs => xs.constructor.constructor.name !== (\n        \"GeneratorFunction\"\n    ) ? (() => {\n        const\n            ys = list(xs),\n            i = ys.findIndex(p);\n\n        return -1 !== i ? (\n            Just(ys[i])\n        ) : Nothing();\n    })() : findGen(p)(xs);",
  "findGen": "// findGen :: (a -> Bool) -> Gen [a] -> Maybe a\nconst findGen = p =>\n    // Just the first match for the predicate p\n    // in the generator stream xs, or Nothing\n    // if no match is found.\n    xs => {\n        const\n            mb = until(tpl => {\n                const nxt = tpl[0];\n\n                return nxt.done || p(nxt.value);\n            })(\n                tpl => Tuple(tpl[1].next())(\n                    tpl[1]\n                )\n            )(Tuple(xs.next())(xs))[0];\n\n        return mb.done ? (\n            Nothing()\n        ) : Just(mb.value);\n    };",
  "findIndex": "// findIndex :: (a -> Bool) -> [a] -> Maybe Int\nconst findIndex = p =>\n    //  Just the index of the first element in\n    //  xs for which p(x) is true, or\n    //  Nothing if there is no such element.\n    xs => {\n        const i = [...xs].findIndex(p);\n\n        return -1 !== i ? (\n            Just(i)\n        ) : Nothing();\n    };",
  "findIndexR": "// findIndexR :: (a -> Bool) -> [a] -> Maybe Int\nconst findIndexR = p =>\n    //  Just the index of the last element in\n    //  xs for which p(x) is true, or\n    //  Nothing if there is no such element.\n    xs => {\n        const i = reverse([...xs]).findIndex(p);\n\n        return -1 !== i ? (\n            Just(xs.length - (1 + i))\n        ) : Nothing();\n    };",
  "findIndices": "// findIndices :: (a -> Bool) -> [a] -> [Int]\n// findIndices :: (String -> Bool) -> String -> [Int]\nconst findIndices = p =>\n    xs => {\n        const ys = [...xs];\n\n        return ys.flatMap(\n            (y, i) => p(y, i, ys) ? (\n                [i]\n            ) : []\n        );\n    };",
  "findTree": "// findTree :: (a -> Bool) -> Tree a -> Maybe Tree a\nconst findTree = p => {\n    // The first of any nodes in the tree which match the predicate p\n    // (For all matches, see treeMatches)\n    const go = tree =>\n        p(tree.root) ? (\n            Just(tree)\n        ) : (() => {\n            const\n                xs = tree.nest,\n                lng = xs.length;\n\n            return 0 < lng ? until(\n                tpl => lng <= tpl[0] || !tpl[1].Nothing\n            )(\n                tpl => Tuple(1 + tpl[0])(\n                    go(xs[tpl[0]])\n                )\n            )(\n                Tuple(0)(\n                    Nothing()\n                )\n            )[1] : Nothing();\n        })();\n\n    return go;\n};",
  "first": "// first :: (a -> b) -> ((a, c) -> (b, c))\nconst first = f =>\n    // A simple function lifted to one which applies\n    // to a tuple, transforming only its first item.\n    xy => {\n        const tpl = Tuple(f(xy[0]))(xy[1]);\n\n        return Array.isArray(xy) ? (\n            Array.from(tpl)\n        ) : tpl;\n    };",
  "flatten": "// flatten :: NestedList a -> [a]\nconst flatten = nest =>\n    nest.flat(Infinity);",
  "flattenTree": "// flattenTree :: Tree a -> [a]\nconst flattenTree = tree => {\n    const\n        go = (xs, node) => [node.root].concat(\n            node.nest.reduceRight(go, xs)\n        );\n\n    return go([], tree);\n};",
  "flip": "// flip :: (a -> b -> c) -> b -> a -> c\nconst flip = op =>\n    // The binary function op with\n    // its arguments reversed.\n    1 < op.length ? (\n        (a, b) => op(b, a)\n    ) : (x => y => op(y)(x));",
  "floor": "// floor :: Num -> Int\nconst floor = x => {\n    const\n        nr = (\n            \"Ratio\" !== x.type ? (\n                properFraction\n            ) : properFracRatio\n        )(x),\n        n = nr[0];\n\n    return 0 > nr[1] ? n - 1 : n;\n};",
  "fmap (<$>)": "// fmap (<$>) :: Functor f => (a -> b) -> f a -> f b\nconst fmap = f =>\n    // f mapped over the given functor.\n    x => ({\n        \"Either\": () => fmapLR,\n        \"List\": () => map,\n        \"Maybe\": () => fmapMay,\n        \"Node\": () => fmapTree,\n        \"String\": () => map,\n        \"Tuple\": () => fmapTuple\n    })[typeName(x)]()(f)(x);",
  "fmapGen <$>": "// fmapGen <$> :: (a -> b) -> Gen [a] -> Gen [b]\nconst fmapGen = f =>\n    function* (gen) {\n        let v = take(1)(gen);\n\n        while (0 < v.length) {\n            yield f(v[0]);\n            v = take(1)(gen);\n        }\n    };",
  "fmapLR (<$>)": "// fmapLR (<$>) :: (a -> b) -> Either a a -> Either a b\nconst fmapLR = f => lr =>\n    undefined === lr.Left ? (\n        Right(f(lr.Right))\n    ) : lr;",
  "fmapMay (<$>)": "// fmapMay (<$>) :: (a -> b) -> Maybe a -> Maybe b\nconst fmapMay = f => mb =>\n    mb.Nothing ? (\n        mb\n    ) : Just(f(mb.Just));",
  "fmapTree (<$>)": "// fmapTree :: (a -> b) -> Tree a -> Tree b\nconst fmapTree = f => {\n    // A new tree. The result of a\n    // structure-preserving application of f\n    // to each root in the existing tree.\n    const go = t => Node(\n        f(t.root)\n    )(\n        t.nest.map(go)\n    );\n\n    return go;\n};",
  "fmapTuple (<$>)": "// fmapTuple (<$>) :: (a -> b) -> (a, a) -> (a, b)\nconst fmapTuple = f => tpl =>\n    Tuple(tpl[0])(\n        f(tpl[1])\n    );",
  "foldMapTree": "// foldMapTree :: Monoid m => (a -> m) -> Tree a -> m\nconst foldMapTree = f => {\n    // Result of mapping each element of the tree to\n    // a monoid, and combining with mappend.\n    const go = tree =>\n        0 < tree.nest.length ? (\n            mappend(\n                f(tree.root)\n            )(\n                foldl1(mappend)(\n                    tree.nest.map(go)\n                )\n            )\n        ) : f(tree.root);\n\n    return go;\n};",
  "foldTree": "// foldTree :: (a -> [b] -> b) -> Tree a -> b\nconst foldTree = f => {\n    // The catamorphism on trees. A summary\n    // value obtained by a depth-first fold.\n    const go = tree => f(\n        root(tree)\n    )(\n        nest(tree).map(go)\n    );\n\n    return go;\n};",
  "foldl": "// foldl :: (a -> b -> a) -> a -> [b] -> a\nconst foldl = f =>\n    a => xs => [...xs].reduce(\n        (x, y) => f(x)(y),\n        a\n    );",
  "foldl1": "// foldl1 :: (a -> a -> a) -> [a] -> a\nconst foldl1 = f =>\n    // Left to right reduction of the non-empty list xs,\n    // using the binary operator f, with the head of xs\n    // as the initial acccumulator value.\n    xs => (\n        ys => 1 < ys.length ? ys.slice(1)\n        .reduce(uncurry(f), ys[0]) : ys[0]\n    )(list(xs));",
  "foldl1May": "// foldl1May :: (a -> a -> a) -> [a] -> Maybe a\nconst foldl1May = f =>\n    xs => (\n        ys => 0 < ys.length ? (\n            Just(ys.slice(1)\n                .reduce(uncurry(f), ys[0]))\n        ) : Nothing()\n    )(list(xs));",
  "foldlTree": "// foldlTree :: (b -> a -> b) -> b -> Tree a -> b\nconst foldlTree = f =>\n    // A top-down left-right\n    // accumulating traversal.\n    acc => node => {\n        const go = (a, x) =>\n            x.nest.reduce(go, f(a)(x.root));\n\n        return go(acc, node);\n    };",
  "foldr": "// foldr :: (a -> b -> b) -> b -> [a] -> b\nconst foldr = f =>\n    // Note that that the Haskell signature of foldr differs from that of\n    // foldl - the positions of accumulator and current value are reversed\n    acc => xs => [...xs].reduceRight(\n        (a, x) => f(x)(a),\n        acc\n    );",
  "foldr1": "// foldr1 :: (a -> a -> a) -> [a] -> a\nconst foldr1 = f =>\n    xs => (ys => 0 < ys.length ? (\n        init(ys).reduceRight(\n            uncurry(f),\n            last(ys)\n        )\n    ) : [])(list(xs));",
  "foldr1May": "// foldr1May :: (a -> a -> a) -> [a] -> Maybe a\nconst foldr1May = f =>\n    // Nothing if xs is empty, or Just a right\n    // fold of f over the list using the last\n    // item of xs as the initial accumulator value.\n    xs => (\n        ys => 0 < ys.length ? (\n            Just(ys.slice(0, -1)\n                .reduceRight(uncurry(f), ys.slice(-1)[0]))\n        ) : Nothing()\n    )(list(xs));",
  "foldrTree": "// foldrTree :: (a -> b -> b) -> b -> Tree a -> b\nconst foldrTree = f =>\n    acc => node => {\n        const go = (a, x) =>\n            f(x.root)(\n                x.nest.reduceRight(go, a)\n            );\n\n        return go(acc, node);\n    };",
  "fromEnum": "// fromEnum :: Enum a => a -> Int\nconst fromEnum = x =>\n    typeof x !== \"string\" ? (\n        x.constructor === Object ? (\n            x.value\n        ) : parseInt(Number(x), 10)\n    ) : x.codePointAt(0);",
  "fromLeft": "// fromLeft :: a -> Either a b -> a\nconst fromLeft = def =>\n    // The contents of a 'Left' value, or otherwise a default value.\n    lr => isLeft(lr) ? lr.Left : def;",
  "fromMaybe": "// fromMaybe :: a -> Maybe a -> a\nconst fromMaybe = def =>\n    mb => mb.Nothing ? def : mb.Just;",
  "fromRight": "// fromRight :: b -> Either a b -> b\nconst fromRight = def =>\n    // The contents of a 'Right' value or otherwise a default value.\n    lr => isRight(lr) ? (\n        lr.Right\n    ) : def;",
  "fst": "// fst :: (a, b) -> a\nconst fst = tpl =>\n    // First member of a pair.\n    tpl[0];",
  "ft": "// ft :: (Int, Int) -> [Int]\nconst ft = m =>\n    n => Array.from({\n        length: 1 + n - m\n    }, (_, i) => m + i);",
  "gcd": "// gcd :: Int -> Int -> Int\nconst gcd = x =>\n    y => {\n        const\n            _gcd = (a, b) => (0 === b ? a : _gcd(b, a % b)),\n            absolute = Math.abs;\n\n        return _gcd(absolute(x), absolute(y));\n    };",
  "genericIndexMay": "// genericIndexMay :: [a] -> Int -> Maybe a\nconst genericIndexMay = xs =>\n    i => (i < xs.length && 0 <= i) ? (\n        Just(xs[i])\n    ) : Nothing();",
  "getCurrentDirectory": "// getCurrentDirectory :: IO FilePath\nconst getCurrentDirectory = () =>\n    ObjC.unwrap(\n        $.NSFileManager.defaultManager\n        .currentDirectoryPath\n    );",
  "getDirectoryContents": "// getDirectoryContents :: FilePath -> IO [FilePath]\nconst getDirectoryContents = fp =>\n    ObjC.deepUnwrap(\n        $.NSFileManager.defaultManager\n        .contentsOfDirectoryAtPathError(\n            $(fp)\n            .stringByStandardizingPath, null\n        )\n    );",
  "getDirectoryContentsLR": "// getDirectoryContentsLR :: FilePath ->\n// Either String IO [FilePath]\nconst getDirectoryContentsLR = fp => {\n    const\n        error = $(),\n        xs = $.NSFileManager.defaultManager\n        .contentsOfDirectoryAtPathError(\n            $(fp).stringByStandardizingPath,\n            error\n        );\n\n    return xs.isNil() ? (\n        Left(ObjC.unwrap(error.localizedDescription))\n    ) : Right(ObjC.deepUnwrap(xs));\n};",
  "getHomeDirectory": "// getHomeDirectory :: IO FilePath\nconst getHomeDirectory = () =>\n    ObjC.unwrap($.NSHomeDirectory());",
  "getTemporaryDirectory": "// getTemporaryDirectory :: IO FilePath\nconst getTemporaryDirectory = () =>\n    ObjC.unwrap($.NSTemporaryDirectory());",
  "group": "// group :: Eq a => [a] -> [[a]]\nconst group = xs => {\n    // A list of lists, each containing only equal elements,\n    // such that the concatenation of these lists is xs.\n    const go = ys =>\n        0 < ys.length ? (() => {\n            const\n                h = ys[0],\n                i = ys.findIndex(y => h !== y);\n\n            return i !== -1 ? (\n                [ys.slice(0, i)].concat(go(ys.slice(i)))\n            ) : [ys];\n        })() : [];\n    const v = go(list(xs));\n\n    return \"string\" === typeof xs ? (\n        v.map(x => x.join(\"\"))\n    ) : v;\n};",
  "groupBy": "// groupBy :: (a -> a -> Bool) -> [a] -> [[a]]\nconst groupBy = fEq =>\n    // Typical usage: groupBy(on(eq)(f), xs)\n    xs => (ys => 0 < ys.length ? (() => {\n        const\n            tpl = ys.slice(1).reduce(\n                (gw, x) => {\n                    const\n                        gps = gw[0],\n                        wkg = gw[1];\n\n                    return fEq(wkg[0])(x) ? (\n                        Tuple(gps)(wkg.concat([x]))\n                    ) : Tuple(gps.concat([wkg]))([x]);\n                },\n                Tuple([])([ys[0]])\n            ),\n            v = tpl[0].concat([tpl[1]]);\n\n        return \"string\" !== typeof xs ? (\n            v\n        ) : v.map(x => x.join(\"\"));\n    })() : [])(list(xs));",
  "groupSortBy": "// groupSortBy :: (a -> a -> Ordering) -> [a] -> [[a]]\nconst groupSortBy = f =>\n    xs => compose(\n        groupBy(a => b => 0 === f(a)(b)),\n        sortBy(f)\n    )(list(xs));",
  "groupSortOn": "// groupSortOn :: Ord b => (a -> b) -> [a] -> [[a]]\nconst groupSortOn = f =>\n    compose(\n        map(map(snd)),\n        groupBy(on(eq)(fst)),\n        sortBy(comparing(fst)),\n        map(fanArrow(f)(identity))\n    );",
  "gt": "// gt :: Ord a => a -> a -> Bool\nconst gt = x => y =>\n    \"Tuple\" === x.type ? (\n        x[0] > y[0]\n    ) : (x > y);",
  "head": "// head :: [a] -> a\nconst head = xs => (\n    ys => ys.length ? (\n        ys[0]\n    ) : undefined\n)(list(xs));",
  "headDef": "// headDef :: a -> [a] -> a\nconst headDef = v =>\n    // The first item of a non-empty list,\n    // or a default value if the list is empty.\n    xs => 0 < xs.length ? (\n        xs[0]\n    ) : v;",
  "headMay": "// headMay :: [a] -> Maybe a\nconst headMay = xs =>\n    // Just the first item of xs, or\n    // Nothing if xs is an empty list.\n    0 < xs.length ? (\n        Just(xs[0])\n    ) : Nothing();",
  "identity": "// identity :: a -> a\nconst identity = x =>\n    // The identity function.\n    x;",
  "if_": "// if_ :: Bool -> a -> a -> a\nconst if_ = bln => \n    x => y => bln ? (\n        x\n    ) : y;",
  "indented": "// indented :: String -> String -> String\nconst indented = strIndent =>\n    s => s.split(/[\\r\\n]/u)\n    .map(\n        x => \"\" !== x ? strIndent + x : x\n    )\n    .join(\"\\n\");",
  "index": "// index (!!) :: [a] -> Int -> Maybe a\n// index (!!) :: Generator (Int, a) -> Int -> Maybe a\n// index (!!) :: String -> Int -> Maybe Char\nconst index = xs =>\n    i => {\n        const s = xs.constructor.constructor.name;\n\n        return \"GeneratorFunction\" !== s ? (() => {\n            const v = xs[i];\n\n            return undefined !== v ? Just(v) : Nothing();\n        })() : (take(i)(xs), xs.next().value);\n    };",
  "indexForest": "// indexForest :: [Tree (a,  { nodeSum :: Int })] -> Int ->\n// Maybe Tree (a, { nodeSum :: Int })\nconst indexForest = trees =>\n    // Index into a forest of measured trees.\n    // (see measuredTree)\n    i => 0 < trees.length ? (() => {\n        const\n            headNode = trees[0],\n            headSize = headNode.root[1].nodeSum;\n\n        return i > (headSize - 1) ? (\n            indexForest(trees.slice(1))(i - headSize)\n        ) : indexTree(headNode)(i);\n    })() : Nothing();",
  "indexOf": "// indexOf :: Eq a => [a] -> [a] -> Maybe Int\n// indexOf :: String -> String -> Maybe Int\nconst indexOf = needle =>\n    haystack => \"string\" !== typeof haystack ? (\n        findIndex(xs => isPrefixOf(needle)(xs))(\n            tails(haystack)\n        )\n    ) : (() => {\n        const i = haystack.indexOf(needle);\n\n        return -1 !== i ? (\n            Just(i)\n        ) : Nothing();\n    })();",
  "indexTree": "// indexTree :: Tree (a,  { nodeSum :: Int }) -> Int ->\n// Maybe Tree (a,  { nodeSum :: Int })\nconst indexTree = tree =>\n    // Index into a measured tree. (see measuredTree)\n    i => 0 !== i ? (\n        i > (tree.root[1].nodeSum - 1) ? (\n            Nothing()\n        ) : indexForest(tree.nest)(i - 1)\n    ) : Just(tree);",
  "indexedTree": "// indexedTree :: Int -> Tree a -> Tree (a, Int)\nconst indexedTree = rootIndex =>\n    // A tree in which each root value \n    // is paired with a top-down\n    // left-right index, where the root node \n    // starts at the supplied rootIndex;\n    tree => {\n        const go = n => node =>\n            second(\n                Node(\n                    Tuple(node.root)(n)\n                )\n            )(\n                mapAccumL(go)(1 + n)(\n                    node.nest\n                )\n            );\n\n        return snd(go(rootIndex)(tree));\n    };",
  "init": "// init :: [a] -> [a]\nconst init = xs => (\n// All elements of a list except the last.\n    ys => 0 < ys.length ? (\n        ys.slice(0, -1)\n    ) : null\n)(list(xs));",
  "initMay": "// initMay :: [a] -> Maybe [a]\nconst initMay = xs => (\n    0 < ys.length ? (\n        Just(ys.slice(0, -1))\n    ) : Nothing()\n)(list(xs));",
  "inits": "// inits :: [a] -> [[a]]\n// inits :: String -> [String]\nconst inits = xs =>\n    // All prefixes of the argument,\n    // shortest first.\n    [\n        []\n    ].concat((list(xs))\n        .map((_, i, ys) => ys.slice(0, 1 + i)));",
  "insert": "// insert :: Ord a => a -> [a] -> [a]\nconst insert = x =>\n    ys => {\n        const [pre, post] = Array.from(\n            break_(y => y >= x)(ys)\n        );\n\n        return [...pre, x, ...post];\n    };",
  "insertBy": "// insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]\nconst insertBy = cmp =>\n    x => xs => {\n        const go = y => ys =>\n            0 < ys.length ? (\n                0 < cmp(y)(ys[0]) ? (\n                    cons(ys[0])(\n                        go(y)(ys.slice(1))\n                    )\n                ) : cons(y)(ys)\n            ) : [y];\n\n        return go(x)(list(xs));\n    };",
  "insertDict": "// insertDict :: String -> a -> Dict -> Dict\nconst insertDict = k => v => dct =>\n    Object.assign({}, dct, {\n        [k]: v\n    });",
  "intToDigit": "// intToDigit :: Int -> Char\nconst intToDigit = n =>\n    n >= 0 && n < 16 ? (\n        \"0123456789ABCDEF\".charAt(n)\n    ) : \"?\";",
  "intercalate": "// intercalate :: [a] -> [[a]] -> [a]\n// intercalate :: String -> [String] -> String\nconst intercalate = sep => xs =>\n    0 < xs.length && \"string\" === typeof sep &&\n    \"string\" === typeof xs[0] ? (\n        xs.join(sep)\n    ) : concat(intersperse(sep)(xs));",
  "intercalateS": "// intercalateS :: String -> [String] -> String\nconst intercalateS = s =>\n    // The concatenation of xs\n    // interspersed with copies of s.\n    xs => xs.join(s);",
  "intersect": "// intersect :: (Eq a) => [a] -> [a] -> [a]\nconst intersect = xs =>\n    // The intersection of lists xs and ys.\n    ys => xs.filter(x => ys.includes(x));",
  "intersectBy": "// intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst intersectBy = eqFn =>\n    // The intersection of the lists xs and ys\n    // in terms of the equality defined by eq.\n    xs => ys => {\n        const zs = list(ys);\n\n        return list(xs).filter(\n            x => zs.some(eqFn(x))\n        );\n    };",
  "intersectListsBy": "// intersectListsBy :: (a -> a -> Bool) -> [[a]] -> [a]\nconst intersectListsBy = eqFn => xs =>\n    foldr1(\n        (a => x => intersectBy(eqFn)(a)(x))\n    )(list(xs));",
  "intersection": "// intersection :: Ord a => Set a -> Set a -> Set a\nconst intersection = s => s1 =>\n    new Set([...s].filter(x => s1.has(x)));",
  "intersperse": "// intersperse :: a -> [a] -> [a]\n// intersperse :: Char -> String -> String\nconst intersperse = sep => xs => {\n    // intersperse(0, [1,2,3]) -> [1, 0, 2, 0, 3]\n    const bln = \"string\" === typeof xs;\n\n    return xs.length > 1 ? (\n        (bln ? concat : x => x)(\n            (bln ? (\n                xs.split(\"\")\n            ) : xs)\n            .slice(1)\n            .reduce((a, x) => a.concat([sep, x]), [xs[0]])\n        )) : xs;\n};",
  "isAlpha": "// isAlpha :: Char -> Bool\nconst isAlpha = c =>\n    (/[A-Za-z\\u00C0-\\u00FF]/u).test(c);",
  "isAlphaNum": "// isAlphaNum :: Char -> Bool\nconst isAlphaNum = c => {\n    const n = c.codePointAt(0);\n\n    return (48 <= n && 57 >= n) || (\n        (/[A-Za-z\\u00C0-\\u00FF]/u).test(c)\n    );\n};",
  "isChar": "// isChar :: a -> Bool\nconst isChar = x =>\n    (\"string\" === typeof x) && (1 === x.length);",
  "isDigit": "// isDigit :: Char -> Bool\nconst isDigit = c => {\n    const n = c.codePointAt(0);\n\n    return 48 <= n && 57 >= n;\n};",
  "isInfixOf": "// isInfixOf :: (Eq a) => [a] -> [a] -> Bool\n// isInfixOf :: String -> String -> Bool\nconst isInfixOf = needle => haystack =>\n    \"string\" !== typeof haystack ? (() => {\n        const\n            lng = needle.length,\n            go = xs => lng <= xs.length ? (\n                isPrefixOf(needle)(xs) || go(xs.slice(1))\n            ) : false;\n\n        return go(haystack);\n    })() : haystack.includes(needle);",
  "isLeft": "// isLeft :: Either a b -> Bool\nconst isLeft = lr =>\n    ('Either' === lr.type) && (undefined !== lr.Left);",
  "isLower": "// isLower :: Char -> Bool\nconst isLower = c =>\n    /[a-z]/.test(c);",
  "isMaybe": "// isMaybe :: a -> Bool\nconst isMaybe = x =>\n    'Maybe' === x.type;",
  "isNull": "// isNull :: [a] -> Bool\n// isNull :: String -> Bool\nconst isNull = xs =>\n    1 > xs.length;",
  "isPrefixOf": "// isPrefixOf :: [a] -> [a] -> Bool\n// isPrefixOf :: String -> String -> Bool\nconst isPrefixOf = xs =>\n    // True if and only if xs is a prefix of ys.\n    ys => {\n        const go = (xs, ys) => {\n            const intX = xs.length;\n            return 0 < intX ? (\n                ys.length >= intX ? xs[0] === ys[0] && go(\n                    xs.slice(1), ys.slice(1)\n                ) : false\n            ) : true;\n        };\n        return 'string' !== typeof xs ? (\n            go(xs, ys)\n        ) : ys.startsWith(xs);\n    };",
  "isRight": "// isRight :: Either a b -> Bool\nconst isRight = lr =>\n  ('undefined' !== typeof lr) && \n  ('Either' === lr.type) && (undefined !== lr.Right);",
  "isSortedBy": "// isSortedBy :: (a -> a -> Bool) -> [a] -> Bool\nconst isSortedBy = p =>\n    // True if all adjacent pairs of elements in\n    // the list return True under the predicate p.\n    xs => xs.length < 2 || all(x => x < 1)(\n        zipWith_(p)(\n            xs\n        )(tail(xs))\n    );",
  "isSpace": "// isSpace :: Char -> Bool\nconst isSpace = c =>\n    // True if c is a white space character.\n    /\\s/.test(c);",
  "isSubsequenceOf": "// isSubsequenceOf :: Eq a => [a] -> [a] -> Bool\n// isSubsequenceOf :: String -> String -> Bool\nconst isSubsequenceOf = xs =>\n    // True if xs is a sub-sequence of ys.\n    ys => {\n        const go = a => b =>\n            0 < a.length ? (\n                0 < b.length ? (\n                    go(\n                        a[0] === b[0] ? (\n                            a.slice(1)\n                        ) : a\n                    )(b.slice(1))\n                ) : false\n            ) : true;\n        return go(list(xs))(\n            list(ys)\n        );\n    };",
  "isSubsetOf": "// isSubsetOf :: Ord a => Set a -> Set a -> Bool\nconst isSubsetOf = a => b => {\n    for (let x of a) {\n        if (!b.has(x)) return false;\n    }\n    return true;\n};",
  "isSuffixOf": "// isSuffixOf :: Eq a => [a] -> [a] -> Bool\n// isSuffixOf :: String -> String -> Bool\nconst isSuffixOf = ns => hs =>\n    'string' !== typeof hs ? (\n        (xs, ys) => bindMay(\n            dropLengthMaybe(xs)(ys)\n        )(d => eq(xs)(dropLength(d)(ys)))\n    )(list(ns), list(hs)) : hs.endsWith(ns);",
  "isUpper": "// isUpper :: Char -> Bool\nconst isUpper = c =>\n    // True if c is an upper case character.\n    /[A-Z]/.test(c);",
  "iso8601Local": "// iso8601Local :: Date -> String\nconst iso8601Local = dte =>\n    new Date(dte - (6E4 * dte.getTimezoneOffset()))\n    .toISOString();",
  "iterate": "// iterate :: (a -> a) -> a -> Gen [a]\nconst iterate = f =>\n    // An infinite list of repeated applications of f to x.\n    function* (x) {\n        let v = x;\n        while (true) {\n            yield(v);\n            v = f(v);\n        }\n    };",
  "iterateUntil": "// iterateUntil :: (a -> Bool) -> (a -> a) -> a -> [a]\nconst iterateUntil = p =>\n    f => function*(x) {\n        let v = x;\n        while (!p(v)) {\n            yield(v);\n            v = f(v);\n        }\n    };",
  "join": "// join :: Monad m => m (m a) -> m a\nconst join = x =>\n    bind(x)(identity);",
  "jsonFromTree": "// jsonFromTree :: Tree a -> String\nconst jsonFromTree = tree => {\n    // A recursive [root, nest] JSON format,\n    // in which `root` is a value string, and `nest`\n    // is a possibly empty list of [`root`, `nest`] pairs.\n    const go = node => [node.root, node.nest.map(go)];\n    return JSON.stringify(go(tree));\n};",
  "jsonLog": "// jsonLog :: a -> IO ()\nconst jsonLog = (...args) =>\n    console.log(\n        args\n        .map(JSON.stringify)\n        .join(' -> ')\n    );",
  "jsonParseLR": "// jsonParseLR :: String -> Either String a\nconst jsonParseLR = s => {\n    // Either a message, or a JS value obtained\n    // from a successful parse of s.\n    try {\n        return Right(JSON.parse(s));\n    } catch (e) {\n        return Left(\n            `${e.message} (line:${e.line} col:${e.column})`\n        );\n    }\n};",
  "justifyLeft": "// justifyLeft :: Int -> Char -> String -> String\nconst justifyLeft = n =>\n    // The string s, followed by enough padding (with\n    // the character c) to reach the string length n.\n    c => s => n > s.length ? (\n        s.padEnd(n, c)\n    ) : s;",
  "justifyRight": "// justifyRight :: Int -> Char -> String -> String\nconst justifyRight = n =>\n    // The string s, preceded by enough padding (with\n    // the character c) to reach the string length n.\n    c => s => n > s.length ? (\n        s.padStart(n, c)\n    ) : s;",
  "kCompose": "// kCompose (>=>) :: Monad m => \n// [(a -> m a)] -> (a -> m a)\nconst kCompose = (...fs) =>\n    // Left Right composition of a sequence\n    // of functions which lift a raw value\n    // of the same type into the same monad.\n    x => 0 < fs.length ? (\n        fs.slice(1).reduce(\n            (m, f) => bind(m)(f),\n            fs[0](x)\n        )\n    ) : x;",
  "keys": "// keys :: Dict -> [String]\nconst keys = Object.keys;",
  "kleisliCompose (>=>)": "// kleisliCompose (>=>) :: Monad m => (a -> m b) ->\n// (b -> m c) -> (a -> m c)\nconst kleisliCompose = f =>\n    // Kleisli composition of two functions which\n    // each lift their values into the same monad.\n    g => x => bind(f(x))(g);",
  "last": "// last :: [a] -> a\nconst last = xs =>\n    // The last item of a list.\n    0 < xs.length ? (\n        xs.slice(-1)[0]\n    ) : null;",
  "lastMay": "// lastMay :: [a] -> Maybe a\nconst lastMay = xs => (\n    ys => 0 < ys.length ? (\n        Just(ys.slice(-1)[0])\n    ) : Nothing()\n)(list(xs));",
  "lcm": "// lcm :: Int -> Int -> Int\nconst lcm = x =>\n    // The smallest positive integer divisible\n    // without remainder by both x and y.\n    y => (x === 0 || y === 0) ? (\n        0\n    ) : Math.abs(Math.floor(x / gcd(x)(y)) * y);",
  "le": "// le :: Ord a => a -> a -> a\nconst le = x =>\n    // True if x <= y;\n    y => x <= y;",
  "lefts": "// lefts :: [Either a b] -> [a]\nconst lefts = xs =>\n    xs.flatMap(\n        x => ('Either' === x.type) && (\n            undefined !== x.Left\n        ) ? [x.Left] : []\n    );",
  "length": "// length :: [a] -> Int\nconst length = xs =>\n    // Returns Infinity over objects without finite\n    // length. This enables zip and zipWith to choose\n    // the shorter argument when one is non-finite,\n    // like cycle, repeat etc\n    'GeneratorFunction' !== xs.constructor\n    .constructor.name ? (\n        xs.length\n    ) : Infinity;",
  "levelNodes": "// levelNodes :: Tree a -> [[Tree a]]\nconst levelNodes = tree =>\n  iterateUntil(xs => 1 > xs.length)(\n    xs => xs.flatMap(x => x.nest)\n  )([tree]);",
  "levels": "// levels :: Tree a -> [[a]]\nconst levels = tree =>\n    // A list of lists, grouping the \n    // root values of each level \n    // of the tree.\n    cons([tree.root])(\n        tree.nest\n        .map(levels)\n        .reduce(\n            uncurry(zipWithLong(append)),\n            []\n        )\n    );",
  "liftA2": "// liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\nconst liftA2 = f =>\n    // Lift a binary function to actions.\n    // liftA2 f a b = fmap f a <*> b\n    a => b => ({\n        '(a -> b)': () => liftA2Fn,\n        'Either': () => liftA2LR,\n        'Maybe': () => liftA2May,\n        'Tuple': () => liftA2Tuple,\n        'Node': () => liftA2Tree,\n        'List': () => liftA2List,\n        'Bottom': () => liftA2List\n    } [typeName(a) || 'List']())(f)(a)(b);",
  "liftA2Fn": "// liftA2Fn :: (a0 -> b -> c) -> (a -> a0) -> (a -> b) -> a -> c\nconst liftA2Fn = op =>\n    // Lift a binary function to a composition\n    // over two other functions.\n    // liftA2 (*) (+ 2) (+ 3) 7 == 90\n    f => g => x => op(f(x))(\n        g(x)\n    );",
  "liftA2LR": "// liftA2LR :: (a -> b -> c) -> Either d a -> Either d b -> Either d c\nconst liftA2LR = f =>\n    // The binary function f lifted to a\n    // function over two Either values.\n    a => b => bindLR(a)(\n        x => bindLR(b)(\n            compose(Right, f(x))\n        )\n    );",
  "liftA2List": "// liftA2List :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst liftA2List = op =>\n    // The binary operator f lifted to a function over two\n    // lists. op applied to each pair of arguments in the\n    // cartesian product of xs and ys.\n    xs => ys => list(xs).flatMap(\n        x => list(ys).map(op(x))\n    );",
  "liftA2May": "// liftA2May :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\nconst liftA2May = f =>\n    a => b => a.Nothing ? (\n        a\n    ) : b.Nothing ? (\n        b\n    ) : Just(f(a.Just)(b.Just));",
  "liftA2Tree": "// liftA2Tree :: (a -> b -> c) -> Tree a -> Tree b -> Tree c\nconst liftA2Tree = f =>\n    tx => ty => {\n        const go = t =>\n            Node(f(t.root)(ty.root))(\n                Boolean(ty.nest) ? (\n                    ty.nest.map(\n                        fmapTree(f(t.root))\n                    )\n                    .concat(t.nest.map(go))\n                ) : []\n            );\n        return go(tx);\n    };",
  "liftA2Tuple": "// liftA2Tuple :: Monoid m =>\n// (a -> b -> c) -> (m, a) -> (m, b) -> (m, c)\nconst liftA2Tuple = f =>\n    a => b => Tuple(mappend(a[0])(b[0]))(\n        f(a[1])(b[1])\n    );",
  "lines": "// lines :: String -> [String]\nconst lines = s =>\n// A list of strings derived from a single\n// string delimited by newline and or CR.\n    0 < s.length ? (\n        s.split(/[\\r\\n]+/u)\n    ) : [];",
  "list": "// list :: StringOrArrayLike b => b -> [a]\nconst list = xs =>\n    // xs itself, if it is an Array,\n    // or an Array derived from xs.\n    Array.isArray(xs) ? (\n        xs\n    ) : Array.from(xs || []);",
  "listDirectory": "// listDirectory :: FilePath -> [FilePath]\nconst listDirectory = fp =>\n    ObjC.unwrap(\n        $.NSFileManager.defaultManager\n        .contentsOfDirectoryAtPathError(\n            ObjC.wrap(fp)\n            .stringByStandardizingPath,\n            null\n        ))\n    .map(ObjC.unwrap);",
  "listFromMaybe": "// listFromMaybe :: Maybe a -> [a]\nconst listFromMaybe = mb =>\n    // A singleton list derived from a Just value, \n    // or an empty list derived from Nothing.\n    mb.Nothing ? [] : [mb.Just];",
  "listFromTree": "// listFromTree :: Tree a -> [a]\nconst listFromTree = tree => {\n    const go = x => [\n      x.root,\n      ...[].concat.apply([], x.nest.map(go))\n    ];\n    return go(tree);\n};",
  "listFromTuple": "// listFromTuple :: (a, a ...) -> [a]\nconst listFromTuple = tpl =>\n    Array.from(tpl);",
  "listToMaybe": "// listToMaybe :: [a] -> Maybe a\nconst listToMaybe = xs =>\n    // Nothing if xs is empty, or Just the head of xs.\n    0 < xs.length ? (\n        Just(xs[0])\n    ) : Nothing();",
  "log": "// log :: Float -> Float\nconst log = Math.log;",
  "lookup": "// lookup :: Eq a => a -> Container -> Maybe b\nconst lookup = k =>\n    // Just of value of the key k in m,\n    // or Nothing if m does not contain k.\n    m => (Array.isArray(m) ? (\n        lookupTuples\n    ) : lookupDict)(k)(m);",
  "lookupDict": "// lookupDict :: a -> Dict -> Maybe b\nconst lookupDict = k =>\n    dct => {\n        const v = dct[k];\n        return undefined !== v ? (\n            Just(v)\n        ) : Nothing();\n    };",
  "lookupTuples": "// lookupTuples :: Eq a => a -> [(a, b)] -> Maybe b\nconst lookupTuples = k =>\n    kvs => {\n        const i = kvs.findIndex(kv => k === kv[0]);\n        return -1 !== i ? (\n            Just(kvs[i][1])\n        ) : Nothing();\n    };",
  "lt": "// lt (<) :: Ord a => a -> a -> Bool\nconst lt = a => \n    b => a < b;",
  "mReturn": "// mReturn :: First-class m => (a -> b) -> m (a -> b)\nconst mReturn = x =>\n    // Not required in JS, which has first functions by default.\n    // Included only for comparison with AS, which has to derive\n    // first class functions by lifting 'handlers' into 'scripts'\n    // as anonymous |λ|() functions.\n    // In JS, mReturn is just an alias of identity.\n    identity(x);",
  "map": "// map :: (a -> b) -> [a] -> [b]\nconst map = f =>\n    // The list obtained by applying f\n    // to each element of xs.\n    // (The image of xs under f).\n    xs => [...xs].map(f);",
  "mapAccumL": "// mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\nconst mapAccumL = f =>\n    // A tuple of an accumulation and a list \n    // obtained by a combined map and fold,\n    // with accumulation from left to right.\n    acc => xs => [...xs].reduce((a, x) => {\n        const pair = f(a[0])(x);\n        return Tuple(pair[0])(a[1].concat(pair[1]));\n    }, Tuple(acc)([]));",
  "mapAccumL_Tree": "// mapAccumL_Tree :: (acc -> x -> (acc, y)) ->\n// acc -> Tree -> (acc, Tree)\nconst mapAccumL_Tree = f => {\n    const go = a => x => {\n        const\n            pair = f(a)(root(x)),\n            tpl = mapAccumL(go)(pair[0])(nest(x));\n        return Tuple(tpl[0])(\n            Node(pair[1])(tpl[1])\n        );\n    };\n    return go;\n};",
  "mapAccumR": "// mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\nconst mapAccumR = f =>\n    // A tuple of an accumulation and a list \n    // obtained by a combined map and fold,\n    // with accumulation from right to left.\n    acc => xs => [...xs].reduceRight((a, x) => {\n        const pair = f(a[0])(x);\n        return Tuple(pair[0])(\n            [pair[1]].concat(a[1])\n        );\n    }, Tuple(acc)([]));",
  "mapFromList": "// mapFromList :: [(String, a)] -> Dict\nconst mapFromList = kvs =>\n    Object.fromEntries(kvs);",
  "mapKeys": "// mapKeys :: (Key -> Key) -> IntMap a -> IntMap a\nconst mapKeys = f =>\n    // A function mapped over the keys of a record,\n    // defining a new record.\n    dct => Object.fromEntries(\n        Object.entries(dct)\n        .map(kv => [f(kv[0]), kv[1]])\n    );",
  "mapMaybe": "// mapMaybe :: (a -> Maybe b) -> [a] -> [b]\nconst mapMaybe = mf =>\n    // A filtered map, retaining only the contents\n    // of Just values. (Nothing values discarded).\n    xs => list(xs).reduce(\n        (a, x) => maybe(a)(\n            j => a.concat(j)\n        )(mf(x)),\n        []\n    );",
  "mapMaybeGen": "// mapMaybeGen :: (a -> Maybe b) -> Gen [a] -> Gen [b]\nconst mapMaybeGen = mf =>\n    // A filtered map over a generator, returning only the\n    // contents of Just values. (Nothing values discarded).\n    function*(gen) {\n        let v = take(1, gen);\n        while (0 < v.length) {\n            let mb = mf(v[0]);\n            if (!mb.Nothing) yield mb.Just;\n            v = take(1, gen);\n        }\n    };",
  "mappend (<>)": "// mappend (<>) :: Monoid a => a -> a -> a\nconst mappend = a =>\n    // Associative operation \n    // defined for various monoids.\n    ({\n        '(a -> b)': () => mappendFn,\n        'List': () => append,\n        'Maybe': () => mappendMaybe,\n        'Num': () => mappendOrd,\n        'String': () => append,\n        'Tuple': () => mappendTuple\n    })[typeName(a)]()(a);",
  "mappendComparing (<>)": "// mappendComparing (<>) :: (a -> a -> Bool)\n// (a -> a -> Bool) -> (a -> a -> Bool)\nconst mappendComparing = cmp =>\n    cmp1 => a => b => {\n        const x = cmp(a)(b);\n        return 0 !== x ? (\n            x\n        ) : cmp1(a)(b);\n    };",
  "mappendFn (<>)": "// mappendFn (<>) :: Monoid b => (a -> b) -> (a -> b) -> (a -> b)\nconst mappendFn = f =>\n    g => x => mappend(f(x))(\n        g(x)\n    );",
  "mappendMaybe (<>)": "// mappendMaybe (<>) :: Maybe a -> Maybe a -> Maybe a\nconst mappendMaybe = a =>\n     b => a.Nothing ? (\n        b\n    ) : b.Nothing ? (\n        a\n    ) : Just(\n        mappend(a.Just)(\n            b.Just\n        )\n    );",
  "mappendOrd (<>)": "// mappendOrd (<>) :: Ordering -> Ordering -> Ordering\nconst mappendOrd = x =>\n    y => 0 !== x ? (\n        x\n    ) : y;",
  "mappendTuple (<>)": "// mappendTuple (<>) :: (a, b) -> (a, b) -> (a, b)\nconst mappendTuple = t => t1 =>\n    Tuple(\n        mappend(t[0])(t1[0])\n    )(\n        mappend(t[1])(t1[1])\n    );",
  "matching": "// matching :: [a] -> (a -> Int -> [a] -> Bool)\nconst matching = pat => {\n    // A sequence-matching function for findIndices etc\n    // findIndices(matching([2, 3]), [1, 2, 3, 1, 2, 3])\n    // -> [1, 4]\n    const\n        lng = pat.length,\n        bln = 0 < lng,\n        h = bln ? pat[0] : undefined;\n    return x => i => src =>\n        bln && h == x && eq(pat)(\n            src.slice(i, lng + i)\n        );\n};",
  "max": "// max :: Ord a => a -> a -> a\nconst max = a =>\n    // b if its greater than a,\n    // otherwise a.\n    b => gt(b)(a) ? (\n        b\n    ) : a;",
  "maxBound": "// maxBound :: a -> a\nconst maxBound = x => {\n    const e = x.enum;\n    return Boolean(e) ? (\n        e[e[x.max]]\n    ) : {\n        'number': Number.MAX_SAFE_INTEGER,\n        'string': String.fromCodePoint(0x10FFFF),\n        'boolean': true\n    }[typeof x];\n};",
  "maximum": "// maximum :: Ord a => [a] -> a\nconst maximum = xs => (\n    // The largest value in a non-empty list.\n    ys => 0 < ys.length ? (\n        ys.slice(1).reduce(\n            (a, y) => y > a ? (\n                y\n            ) : a, ys[0]\n        )\n    ) : undefined\n)(list(xs));",
  "maximumBy": "// maximumBy :: (a -> a -> Ordering) -> [a] -> a\nconst maximumBy = f =>\n    xs => {\n        const ys = list(xs);\n        return 0 < ys.length ? (\n            ys.slice(1).reduce(\n                (a, y) => 0 < f(y)(a) ? (\n                    y\n                ) : a,\n                ys[0]\n            )\n        ) : undefined;\n    };",
  "maximumByMay": "// maximumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\nconst maximumByMay = f =>\n    xs => (\n        ys => ys.length > 0 ? (\n            Just(ys.slice(1)\n                .reduce((a, y) => 0 < f(a)(y) ? (\n                    a\n                ) : y, ys[0]))\n        ) : Nothing()\n    )(list(xs));",
  "maximumMay": "// maximumMay :: Ord a => [a] -> Maybe a\nconst maximumMay = xs => (\n    ys => 0 < ys.length ? (\n        Just(ys.slice(1)\n            .reduce((a, y) => (y > a ? y : a), ys[0]))\n    ) : Nothing()\n)(list(xs));",
  "maximumOn": "// maximumOn :: (Ord b) => (a -> b) -> [a] -> a\nconst maximumOn = f =>\n    // The item in xs for which f \n    // returns the highest value.\n    xs => 0 < xs.length ? (\n        xs.slice(1).reduce(\n            (tpl, x) => {\n                const v = f(x);\n                return v > tpl[1] ? [\n                    x, v\n                ] : tpl;\n            },\n            (h => [h, f(h)])(xs[0])\n        )[0]\n    ) : undefined;",
  "maybe": "// maybe :: b -> (a -> b) -> Maybe a -> b\nconst maybe = v =>\n    // Default value (v) if m is Nothing, or f(m.Just)\n    f => m => m.Nothing ? (\n        v\n    ) : f(m.Just);",
  "mconcatOrd": "// mconcatOrd :: [Ordering] -> Ordering\nconst mconcatOrd = cmps =>\n    // A sort compare function derived from\n    // a list of such functions, providing\n    // for composition of n-ary sorts.\n    0 < cmps.length ? (\n        foldl(\n            mappendOrd\n        )(cmps[0])(cmps.slice(1))\n    ) : compare;",
  "mean": "// mean :: [Num] -> Num\nconst mean = xs => (\n    ys => ys.reduce((a, y) => a + y, 0) / ys.length\n)(list(xs));",
  "measuredTree": "// measuredTree :: Tree a -> Tree (a, (Int, Int, Int, Int))\nconst measuredTree = tree => {\n    // A tree in which each node is tupled with\n    // a (leafSum, layerSum, nodeSum) measure of its sub-tree,\n    // where leafSum is the number of descendant leaves,\n    // and layerSum is the number of descendant levels,\n    // and nodeSum counts all nodes, including the root.\n    // Index is a position in a zero-based top-down\n    // left to right series. \n    // For additional parent indices, see parentIndexedTree.\n    const whni = (w, h, n, i) => ({\n        leafSum: w,\n        layerSum: h,\n        nodeSum: n,\n        index: i\n    });\n    let i = 0;\n    return foldTree(\n        x => {\n            let topDown = i++;\n            return xs => Node(\n                Tuple(x)(\n                    0 < xs.length ? (() => {\n                        const dct = xs.reduce(\n                            (a, node) => {\n                                const dimns = node.root[1];\n                                return whni(\n                                    a.leafSum + dimns.leafSum,\n                                    max(a.layerSum)(\n                                        dimns.layerSum\n                                    ),\n                                    a.nodeSum + dimns.nodeSum,\n                                    topDown\n                                );\n                            }, whni(0, 0, 0, topDown)\n                        );\n                        return whni(\n                            dct.leafSum,\n                            1 + dct.layerSum,\n                            1 + dct.nodeSum,\n                            topDown\n                        );\n                    })() : whni(1, 0, 1, topDown)\n                )\n            )(xs);\n        }\n    )(tree);\n};",
  "member": "// member :: Key -> Dict -> Bool\nconst member = k =>\n    // True if dict contains the key k.\n    dict => k in dict;",
  "merge": "// merge :: Ord a => [a] -> [a] -> [a]\nconst merge = xs =>\n    // An ordered list derived by merging\n    // two other ordered lists.\n    mergeBy(compare)(xs);",
  "mergeBy": "// mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]\nconst mergeBy = f =>\n    // A single list defined by the ordered \n    // merging of xs and ys in terms of the \n    // given comparator function.\n    xs => ys => {\n        const go = (as, bs) =>\n            0 < bs.length ? (\n                0 < as.length ? (\n                    1 !== f(as[0])(bs[0]) ? (\n                        [as[0]].concat(\n                            go(as.slice(1), bs)\n                        )\n                    ) : [bs[0]].concat(\n                        go(as, bs.slice(1))\n                    )\n                ) : bs\n            ) : as;\n        return [].concat(...go(xs, ys));\n    };",
  "min": "// min :: Ord a => a -> a -> a\nconst min = a => \n    b => b < a ? b : a;",
  "minBound": "// minBound :: a -> a\nconst minBound = x => {\n    const e = x.enum;\n    return Boolean(e) ? (\n        e[e[0]]\n    ) : {\n        'number': Number.MIN_SAFE_INTEGER,\n        'string': String.fromCodePoint(0),\n        'boolean': false\n    }[typeof x];\n};",
  "minimum": "// minimum :: Ord a => [a] -> a\nconst minimum = xs => (\n    // The least value of xs.\n    ys => 0 < ys.length ? (\n        ys.slice(1)\n        .reduce((a, y) => y < a ? y : a, ys[0])\n    ) : null\n)(list(xs));",
  "minimumBy": "// minimumBy :: (a -> a -> Ordering) -> [a] -> a\nconst minimumBy = f =>\n    xs => {\n        const ys = list(xs);\n        return 0 < ys.length ? (\n            ys.slice(1).reduce(\n                (a, y) => 0 > f(y)(a) ? (\n                    y\n                ) : a,\n                ys[0]\n            )\n        ) : undefined;\n    };",
  "minimumByMay": "// minimumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\nconst minimumByMay = f =>\n    xs => list(xs).reduce((a, x) =>\n        a.Nothing ? Just(x) : (\n            f(x)(a.Just) < 0 ? (\n                Just(x)\n            ) : a\n        ), Nothing());",
  "minimumMay": "// minimumMay :: [a] -> Maybe a\nconst minimumMay = xs => (\n    ys => 0 < ys.length ? (\n        Just(ys.slice(1)\n            .reduce((a, y) => y < a ? y : a, ys[0])\n        )\n    ) : Nothing()\n)(list(xs));",
  "minimumOn": "// minimumOn :: (Ord b) => (a -> b) -> [a] -> a\nconst minimumOn = f =>\n    // The item in xs for which f \n    // returns the highest value.\n    xs => 0 < xs.length ? (\n        xs.slice(1).reduce(\n            (tpl, x) => {\n                const v = f(x);\n                return v < tpl[1] ? [\n                    x, v\n                ] : tpl;\n            },\n            (h => [h, f(h)])(xs[0])\n        )[0]\n    ) : undefined;",
  "mod": "// mod :: Int -> Int -> Int\nconst mod = n =>\n    d => (n % d) + (\n        signum(n) === signum(-d) ? (\n            d\n        ) : 0\n    );",
  "modificationTime": "// modificationTime :: FilePath -> Either String Date\nconst modificationTime = fp =>\n    bindLR(fileStatus(fp))(\n       dct => Right(ObjC.unwrap(dct.NSFileModificationDate))\n    );",
  "mul": "// mul (*) :: Num a => a -> a -> a\nconst mul = a =>\n    b => a * b;",
  "ne": "// ne :: a -> a -> Bool\nconst ne = a =>\n    b => a !== b;",
  "negate": "// negate :: Num -> Num\nconst negate = n =>\n    -n;",
  "nest": "// nest :: Tree a -> [a]\nconst nest = tree => {\n    // Allowing for lazy (on-demand) evaluation.\n    // If the nest turns out to be a function –\n    // rather than a list – that function is applied\n    // here to the root, and returns a list.\n    const xs = tree.nest;\n\n    return \"function\" !== typeof xs ? (\n        xs\n    ) : xs(root(x));\n};",
  "newUUID": "// newUUID :: () -> IO UUID String\nconst newUUID = () =>\n    ObjC.unwrap($.NSUUID.UUID.UUIDString);",
  "not": "// not :: Bool -> Bool\nconst not = b =>\n    !b;",
  "notElem": "// notElem :: Eq a => a -> [a] -> Bool\nconst notElem = x => \n    xs => !xs.includes(x);",
  "nub": "// nub :: [a] -> [a]\nconst nub = xs => \n  nubBy(eq)(xs);",
  "nubBy": "// nubBy :: (a -> a -> Bool) -> [a] -> [a]\nconst nubBy = fEq => {\n    const go = xs => 0 < xs.length ? (() => {\n        const x = xs[0];\n        return [x].concat(\n            go(xs.slice(1)\n                .filter(y => !fEq(x)(y))\n            )\n        );\n    })() : [];\n    return compose(go, list);\n};",
  "odd": "// odd :: Int -> Bool\nconst odd = n =>\n    !even(n);",
  "on": "// on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\nconst on = f =>\n    // e.g. groupBy(on(eq)(length))\n    g => a => b => f(g(a))(g(b));",
  "or": "// or :: [Bool] -> Bool\nconst or = xs =>\n    xs.some(Boolean);",
  "ord": "// ord :: Char -> Int\nconst ord = c =>\n    // Unicode ordinal value of the character.\n    c.codePointAt(0);",
  "ordering": "// ordering :: () -> Ordering\nconst\n    ordering = enumFromPairs(\n        'Ordering', \n        [['LT', -1], ['EQ', 0], ['GT', 1]]\n    ),\n    LT = ordering.LT,\n    EQ = ordering.EQ,\n    GT = ordering.GT;",
  "outdented": "// outdented :: String -> String\nconst outdented = s => {\n    // All lines in the string outdented by the same amount\n    // (just enough to ensure that the least indented lines \n    //  have no remaining indent)\n    // All relative indents are left unchanged\n    const\n        rgx = /^ */, // Leading space characters.\n        xs = lines(s),\n        n = length(minimumBy(comparing(length))(\n            xs.map(txt => rgx.exec(txt)[0])\n        ));\n    return unlines(map(drop(n))(xs));\n};",
  "parentIndexedTree": "// parentIndexedTree :: Tree (a, {...index :: Int}) ->\n// Tree (a, {...index :: Int, parent :: Maybe Int})\nconst parentIndexedTree = tree => {\n    // A tree additionally decorated with parent indices,\n    // derived from a measured tree already decorated with\n    // node indices. (See measuredTree).\n    const go = mb => node => {\n        const\n            x = node.root,\n            measures = x[1];\n        return Node(Tuple(x[0])(\n            Object.assign(measures, {\n                parent: mb\n            })\n        ))(node.nest.map(go(Just(measures.index))));\n    };\n    return go(Nothing())(tree);\n};",
  "partition": "// partition :: (a -> Bool) -> [a] -> ([a], [a])\nconst partition = p =>\n    // A tuple of two lists - those elements in\n    // xs which match p, and those which don't.\n    xs => list(xs).reduce(\n        (a, x) => p(x) ? (\n            Tuple(a[0].concat(x))(a[1])\n        ) : Tuple(a[0])(a[1].concat(x)),\n        Tuple([])([])\n    );",
  "partitionEithers": "// partitionEithers :: [Either a b] -> ([a],[b])\nconst partitionEithers = xs =>\n    xs.reduce(\n        (a, x) => undefined !== x.Left ? (\n            Tuple(a[0].concat(x.Left))(a[1])\n        ) : Tuple(a[0])(a[1].concat(x.Right)),\n        Tuple([])([])\n    );",
  "permutations": "// permutations :: [a] -> [[a]]\nconst permutations = xs => (\n    ys => ys.reduceRight(\n        (a, y) => a.flatMap(\n            ys => Array.from({\n                length: 1 + ys.length\n            }, (_, i) => i)\n            .map(n => ys.slice(0, n)\n                .concat(y)\n                .concat(ys.slice(n))\n            )\n        ),[[]]\n    )\n)(list(xs));",
  "pi": "// pi :: Float\nconst pi = Math.PI;",
  "plural": "// plural :: String -> Int -> String\nconst plural = k =>\n    // Singular or plural EN inflection\n    // of a given word.\n    n => 1 !== n ? (\n        `${k}s`\n    ) : k;",
  "plus": "// plus :: Num -> Num -> Num\nconst plus = a =>\n    // The sum of a and b.\n    b => a + b;",
  "postorder": "// postorder :: Tree a -> [a]\nconst postorder = t => {\n    // List of root elements of tree flattened\n    // bottom-up into a postorder list.\n    const go = (xs, x) =>\n        nest(x).reduce(go, xs).concat(root(x));\n    return go([], t);\n};",
  "pred": "// pred :: Enum a => a -> a\nconst pred = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mn] = [x, minBound(x)].map(fromEnum);\n        return i > mn ? (\n            toEnum(x)(i - 1)\n        ) : Error('succ :: enum out of range.');\n    })() : x > Number.MIN_SAFE_INTEGER ? (\n        x - 1\n    ) : Error('succ :: Num out of range.');\n};",
  "predMay": "// predMay :: Enum a => a -> Maybe a\nconst predMay = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mn] = [x, minBound(x)].map(fromEnum);\n        return i > mn ? (\n            Just(toEnum(x)(i - 1))\n        ) : Nothing();\n    })() : x > Number.MIN_SAFE_INTEGER ? (\n        Just(x - 1)\n    ) : Nothing();\n};",
  "print": "// print :: a -> IO ()\nconst print = x => {\n    const s = show(x);\n    return (\n        typeof document !== 'undefined' ? (\n            document.writeln(s)\n        ) : typeof draft !== 'undefined' ? (\n            editor.setText(\n                editor.getText() + '\\n' + s\n            )\n        ) : (\n            console.log(s),\n            s\n        )\n    );\n};",
  "product": "// product :: [Num] -> Num\nconst product = xs =>\n    list(xs).reduce((a, x) => a * x, 1);",
  "properFracRatio": "// properFracRatio :: Ratio -> (Int, Ratio)\nconst properFracRatio = nd => {\n    const [q, r] = Array.from(quotRem(nd.n, nd.d));\n    return Tuple(q, ratio(r, nd.d));\n};",
  "properFraction": "// properFraction :: Real -> (Int, Real)\nconst properFraction = n => {\n    const i = Math.floor(n) + (n < 0 ? 1 : 0);\n    return Tuple(i)(n - i);\n};",
  "pureLR": "// pureLR :: a -> Either e a\nconst pureLR = x =>\n    // The value x lifted into the Either monad.\n    Right(x);",
  "pureList": "// pureList :: a -> [a]\nconst pureList = x => \n    [x];",
  "pureMay": "// pureMay :: a -> Maybe a\nconst pureMay = x =>\n    Just(x);",
  "pureT": "// pureT :: String -> f a -> (a -> f a)\nconst pureT = t =>\n    // Given a type name string, returns a \n    // specialised 'pure', where\n    // 'pure' lifts a value into a particular functor.\n    ({\n        'Either': () => pureLR,\n        'Maybe': () => pureMay,\n        'Node': () => pureTree,\n        'Tuple': () => pureTuple,\n        'List': () => pureList\n    })[t || 'List']();",
  "pureTree": "// pureTree :: a -> Tree a\nconst pureTree = x =>\n    Node(x)([]);",
  "pureTuple": "// pureTuple :: a -> (a, a)\nconst pureTuple = x =>\n    Tuple('')(x);",
  "quickSort": "// quickSort :: (Ord a) => [a] -> [a]\nconst quickSort = xs =>\n    // Included only for comparison with AppleScript\n    // sort and sortBy are faster and more flexible\n    xs.length > 1 ? (() => {\n        const\n            h = xs[0],\n            lessMore = partition(x => x <= h)(\n                xs.slice(1)\n            );\n        return [].concat.apply(\n            [], [quickSort(lessMore[0]), h, quickSort(lessMore[1])]\n        );\n    })() : xs;",
  "quickSortBy": "// quickSortBy :: (a -> a -> Ordering) -> [a] -> [a]\nconst quickSortBy = cmp => {\n    // Included only for comparison with AppleScript.\n    // sort and sortBy are faster and more flexible.\n    const go = xs => xs.length > 1 ? (() => {\n        const\n            h = xs[0],\n            lessMore = partition(\n                x => 1 !== cmp(x)(h)\n            )(xs.slice(1));\n        return [].concat.apply([], [\n            go(lessMore[0]),\n            h,\n            go(lessMore[1])\n        ]);\n    })() : xs;\n    return go;\n};",
  "quot": "// quot :: Int -> Int -> Int\nconst quot = n =>\n    m => Math.trunc(n / m);",
  "quotRem": "// quotRem :: Int -> Int -> (Int, Int)\nconst quotRem = m =>\n    // The quotient, tupled with the remainder.\n    n => Tuple(\n        Math.trunc(m / n)\n    )(m % n);",
  "quoted": "// quoted :: Char -> String -> String\nconst quoted = c =>\n    // A string flanked on both sides\n    // by a specified quote character.\n    s => c + s + c;",
  "radians": "// radians :: Float x => Degrees x -> Radians x\nconst radians = x =>\n    (Math.PI / 180) * x;",
  "raise": "// raise :: Num -> Int -> Num\nconst raise = x =>\n    // X to the power of n.\n    n => Math.pow(x, n);",
  "randomRInt": "// randomRInt :: Int -> Int -> IO () -> Int\nconst randomRInt = low =>\n    // The return value of randomRInt is itself\n    // a function, which, whenever evaluated,\n    // yields a a new pseudo-random integer\n    // in the range [low..high].\n    high => () => low + Math.floor(\n        Math.random() * (1 + (high - low))\n    );",
  "range": "// range :: Ix a => (a, a) -> [a]\nfunction range() {\n    // The list of values in the subrange defined by a bounding pair.\n    // range([0, 2]) -> [0,1,2]\n    // range([[0,0], [2,2]]) \n    //  -> [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\n    // range([[0,0,0],[1,1,1]])\n    //  -> [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]\n    const\n        args = Array.from(arguments),\n        ab = 1 !== args.length ? (\n            args\n        ) : args[0],\n        [as, bs] = [ab[0], ab[1]].map(\n            x => Array.isArray(x) ? (\n                x\n            ) : (undefined !== x.type) &&\n            (x.type.startsWith('Tuple')) ? (\n                listFromTuple(x)\n            ) : [x]\n        ),\n        an = as.length;\n    return (an === bs.length) ? (\n        1 < an ? (\n            traverseList(x => x)(\n                as.map((_, i) => enumFromTo(as[i])(bs[i]))\n            )\n        ) : enumFromTo(as[0])(bs[0])\n    ) : [];\n}",
  "ratio": "// ratio :: Int -> Int -> Ratio Int\nconst ratio = x => y => {\n  const go = (x, y) =>\n    0 !== y ? (() => {\n      const d = gcd(x)(y);\n      return {\n        type: 'Ratio',\n        'n': quot(x)(d), // numerator\n        'd': quot(y)(d) // denominator\n      };\n    })() : undefined;\n  return go(x * signum(y), abs(y));\n};",
  "ratioDiv": "// ratioDiv :: Rational -> Rational -> Rational\nconst ratioDiv = n1 => n2 => {\n    const [r1, r2] = map(rational)(\n        [n1, n2]\n    );\n    return ratio(r1.n * r2.d)(\n        r1.d * r2.n\n    );\n};",
  "ratioMinus": "// ratioMinus :: Rational -> Rational -> Rational\nconst ratioMinus = n1 => n2 => {\n    const [r1, r2] = [n1, n2].map(rational);\n    const d = lcm(r1.d)(r2.d);\n    return ratio((r1.n * (d / r1.d)) - (r2.n * (d / r2.d)))(\n        d\n    );\n};",
  "ratioMult": "// ratioMult :: Rational -> Rational -> Rational\nconst ratioMult = n1 => n2 => {\n    const [r1, r2] = map(rational)(\n        [n1, n2]\n    );\n    return ratio(r1.n * r2.n)(\n        r1.d * r2.d\n    );\n};",
  "ratioPlus": "// ratioPlus :: Rational -> Rational -> Rational\nconst ratioPlus = n1 =>\n    n2 => {\n        const [r1, r2] = [n1, n2].map(rational);\n        const d = lcm(r1.d)(r2.d);\n        return ratio((r1.n * (d / r1.d)) + (r2.n * (d / r2.d)))(\n            d\n        );\n    };",
  "rational": "// rational :: Num a => a -> Rational\nconst rational = x =>\n    isNaN(x) ? x : Number.isInteger(x) ? (\n        ratio(x)(1)\n    ) : approxRatio(undefined)(x);",
  "read": "// read :: Read a => String -> a\nconst read = JSON.parse;",
  "readFile": "// readFile :: FilePath -> IO String\nconst readFile = fp => {\n    // The contents of a text file at the\n    // filepath fp.\n    const\n        e = $(),\n        ns = $.NSString\n        .stringWithContentsOfFileEncodingError(\n            $(fp).stringByStandardizingPath,\n            $.NSUTF8StringEncoding,\n            e\n        );\n\n    return ObjC.unwrap(\n        ns.isNil() ? (\n            e.localizedDescription\n        ) : ns\n    );\n};",
  "readFileLR": "// readFileLR :: FilePath -> Either String IO String\nconst readFileLR = fp => {\n    // Either a message or the contents of any\n    // text file at the given filepath.\n    const\n        e = $(),\n        ns = $.NSString\n        .stringWithContentsOfFileEncodingError(\n            $(fp).stringByStandardizingPath,\n            $.NSUTF8StringEncoding,\n            e\n        );\n\n    return ns.isNil() ? (\n        Left(ObjC.unwrap(e.localizedDescription))\n    ) : Right(ObjC.unwrap(ns));\n};",
  "readHex": "// readHex :: String -> Int\nconst readHex = s =>\n    // Integer value of hexadecimal expression.\n    parseInt(s, 16);",
  "readLR": "// readLR :: Read a => String -> Either String a\nconst readLR = s => {\n    try {\n        return Right(JSON.parse(s));\n    } catch (e) {\n        return Left(e.message);\n    }\n};",
  "readPlistFileLR": "// readPlistFileLR :: FilePath -> Either String Object\nconst readPlistFileLR = fp =>\n    bindLR(\n        doesFileExist(fp) ? (\n            Right(filePath(fp))\n        ) : Left(`No file found at path:\\n\\t${fp}`)\n    )(fpFull => {\n        const\n            e = $(),\n            maybeDict = (\n                $.NSDictionary\n                .dictionaryWithContentsOfURLError(\n                    $.NSURL.fileURLWithPath(fpFull),\n                    e\n                )\n            );\n\n        return maybeDict.isNil() ? (() => {\n            const msg = ObjC.unwrap(e.localizedDescription);\n\n            return Left(`readPlistFileLR:\\n\\t${msg}`);\n        })() : Right(ObjC.deepUnwrap(maybeDict));\n    });",
  "recip": "// recip :: Num -> Num\nconst recip = n =>\n    0 !== n ? (1 / n) : undefined;",
  "recipMay": "// recipMay :: Num -> Maybe Num\nconst recipMay = n =>\n    0 === n ? (\n        Nothing()\n    ) : Just(1 / n);",
  "regexMatches": "// regexMatches :: Regex String -> String -> [[String]]\nconst regexMatches = rgx =>\n    // All matches for the given regular expression\n    // in the supplied string s.\n    s => [...s.matchAll(new RegExp(rgx, 'g'))];",
  "rem": "// rem :: Int -> Int -> Int\nconst rem = n => \n    m => n % m;",
  "removeFile": "// removeFile :: FilePath -> Either String String\nconst removeFile = fp => {\n    const error = $();\n\n    return $.NSFileManager.defaultManager\n        .removeItemAtPathError(fp, error) ? (\n            Right(`Removed: ${fp}`)\n        ) : Left(ObjC.unwrap(error.localizedDescription));\n};",
  "renamedFile": "// renamedFile :: FilePath -> FilePath ->\n// Either IO String IO String\nconst renamedFile = fp =>\n    // Either a message detailing a problem, or\n    // confirmation of a filename change in the OS.\n    fp1 => {\n        const error = $();\n\n        return $.NSFileManager.defaultManager\n            .moveItemAtPathToPathError(fp, fp1, error) ? (\n                Right(fp1)\n            ) : Left(ObjC.unwrap(\n                error.localizedDescription\n            ));\n    };",
  "repeat": "// repeat :: a -> Generator [a]\nfunction* repeat(x) {\n    while(true) yield x;\n}",
  "replace": "// replace :: String -> String -> String -> String\n// replace :: Regex -> String -> String -> String\nconst replace = needle => strNew => strHaystack =>\n    strHaystack.replace(\n      'string' !== typeof needle ? (\n        needle\n      ) : new RegExp(needle, 'g'),\n      strNew\n    );",
  "replicate": "// replicate :: Int -> a -> [a]\nconst replicate = n =>\n    // A list of n copies of x.\n    x => Array.from({\n        length: n\n    }, () => x);",
  "replicateM": "// replicateM :: Int -> [a] -> [[a]]\nconst replicateM = n =>\n    // Instance for lists (arrays) only here.\n    xs => {\n        const go = x => 0 >= x ? [\n            []\n        ] : liftA2List(cons)(\n            list(xs)\n        )(go(x - 1));\n        return go(n);\n    };",
  "replicateString": "// replicateString :: Int -> String -> String\nconst replicateString = n => \n    s => s.repeat(n);",
  "reverse": "// reverse :: [a] -> [a]\nconst reverse = xs =>\n    \"string\" === typeof xs ? (\n        xs.split(\"\").reverse()\n        .join(\"\")\n    ) : xs.slice(0).reverse();",
  "rights": "// rights :: [Either a b] -> [b]\nconst rights = xs =>\n    xs.flatMap(\n        x => ('Either' === x.type) && (\n            undefined !== x.Right\n        ) ? [x.Right] : []\n    );",
  "root": "// root :: Tree a -> a\nconst root = tree =>\n    // The value attached to a tree node.\n    tree.root;",
  "rotate": "// rotate :: Int -> [a] -> [a]\nconst rotate = n => xs => {\n    // Rightward rotation of xs by n positions.\n    const lng = xs.length;\n    return Infinity > lng ? (\n        take(lng)(\n            drop(lng - n)(\n                cycle(xs)\n            )\n        )\n    ) : undefined;\n};",
  "round": "// round :: a -> Int\nconst round = x => {\n    const\n        nr = properFraction(x),\n        [n, r] = [nr[0], nr[1]],\n        m = n + (r < 0 ? -1 : 1),\n        sign = signum(abs(r) - 0.5);\n    return (-1 === sign) ? n : (\n        0 === sign ? (even(n) ? n : m) : (\n            1 === sign ? m : undefined\n        )\n    );\n};",
  "roundTo": "// roundTo :: Int -> Float -> Float\nconst roundTo = n => x => {\n    const d = Math.pow(10, n);\n    return Math.round(x * d) / d;\n};",
  "runAction": "// runAction :: Action a -> a\nconst runAction = act =>\n    // Evaluation of an action.\n    act.act(act.arg);",
  "safeMay": "// safeMay :: (a -> Bool) -> (a -> b) -> Maybe b\nconst safeMay = p => f => x =>\n    p(x) ? Just(f(x)) : Nothing();",
  "scanl": "// scanl :: (b -> a -> b) -> b -> [a] -> [b]\nconst scanl = f => startValue => xs =>\n    list(xs).reduce((a, x) => {\n        const v = f(a[0])(x);\n\n        return Tuple(v)(a[1].concat(v));\n    }, Tuple(startValue)([startValue]))[1];",
  "scanl1": "// scanl1 :: (a -> a -> a) -> [a] -> [a]\nconst scanl1 = f =>\n    // scanl1 is a variant of scanl that has no \n    // starting value argument.\n    xs => xs.length > 0 ? (\n        scanl(f)(\n            xs[0]\n        )(xs.slice(1))\n    ) : [];",
  "scanr": "// scanr :: (a -> b -> b) -> b -> [a] -> [b]\nconst scanr = f =>\n    startValue => xs => list(xs).reduceRight((a, x) => {\n        const v = f(x)(a[0]);\n\n        return Tuple(v)([v].concat(a[1]));\n    }, Tuple(startValue)([startValue]))[1];",
  "scanr1": "// scanr1 :: (a -> a -> a) -> [a] -> [a]\nconst scanr1 = f =>\n    // scanr1 is a variant of scanr that has no \n    // seed-value argument, and assumes that\n    // xs is not empty.\n    xs => xs.length > 0 ? (\n        scanr(f)(\n            xs.slice(-1)[0]\n        )(xs.slice(0, -1))\n    ) : [];",
  "second": "// second :: (a -> b) -> ((c, a) -> (c, b))\nconst second = f =>\n    // A function over a simple value lifted\n    // to a function over a tuple.\n    // f (a, b) -> (a, f(b))\n    xy => {\n        const tpl = Tuple(xy[0])(f(xy[1]));\n\n        return Array.isArray(xy) ? (\n            Array.from(tpl)\n        ) : tpl;\n    };",
  "sequenceA": "// sequenceA :: (Applicative f, Traversable t) => t (f a) -> f (t a)\nconst sequenceA = tfa =>\n    traverse(x => x)(\n        tfa\n    );",
  "setCurrentDirectory": "// setCurrentDirectory :: String -> IO ()\nconst setCurrentDirectory = strPath =>\n    $.NSFileManager.defaultManager\n    .changeCurrentDirectoryPath(\n        ObjC.wrap(strPath)\n        .stringByStandardizingPath\n    );",
  "setFromList": "// setFromList :: Ord a => [a] -> Set a\nconst setFromList = xs =>\n    new Set(xs);",
  "setInsert": "// setInsert :: Ord a => a -> Set a -> Set a\nconst setInsert = x => oSet =>\n    oSet.add(x);",
  "setMember": "// setMember :: Ord a => a -> Set a -> Bool\nconst setMember = x => oSet =>\n    oSet.has(x);",
  "setSize": "// setSize :: Set a -> Int\nconst setSize = oSet =>\n    oSet.size;",
  "shift": "// shift :: Int -> [a] -> [a]\nconst shift = n => xs => {\n    const lng = length(xs);\n    return Infinity > lng ? (\n        take(lng)(\n          drop(n)(cycle(xs))\n        )\n    ) : (drop(n)(xs), xs);\n};",
  "show": "// show :: a -> String\n// show :: a -> Int -> Indented String\nconst show = x => {\n    const\n        str = x => x.toString(),\n        t = typeName(x);\n    return Boolean(t) ? (\n        'Node' !== t ? (\n            JSON.stringify(\n                x,\n                (_, v) => ({\n                    '(a -> b)': () => showFn,\n                    'Bool': () => str,\n                    'Bottom': () => showUndefined,\n                    'Date': () => x => x,\n                    'Dict': () => x => x,\n                    'Either': () => showLR,\n                    'List': () => showList,\n                    'Maybe': () => showMaybe,\n                    'Num': () => str,\n                    'Ratio': () => showRatio,\n                    'String': () => str,\n                    'Tuple': () => showTuple\n                })[t]()(v)\n            )\n        ) : showTree(x)\n    ) : `No Show instance has been defined for ${t}.`;\n};",
  "showBinary": "// showBinary :: Int -> String\nconst showBinary = n => {\n    const\n        binaryChar = n => 0 !== n ? (\n            '1'\n        ) : '0';\n    return showIntAtBase(2)(\n        binaryChar\n    )(n)('');\n};",
  "showDate": "// showDate :: Date -> String\nconst showDate = dte =>\n    dte.toJSON;",
  "showDict": "// showDict :: Dict -> String\nconst showDict = show;",
  "showFn": "// showFn :: (a -> b) -> String\nconst showFn = f =>\n    `λ${f}`;",
  "showForest": "// showForest :: [Tree a] -> String\nconst showForest = xs =>\n    unlines(xs.map(x => drawTree2(false)(true)(\n        fmapTree(show)(\n            x\n        )\n    )));",
  "showHex": "// showHex :: Int -> String\nconst showHex = n =>\n    // Hexadecimal string for a given integer.\n    '0x' + n.toString(16);",
  "showIntAtBase": "// showIntAtBase :: Int -> (Int -> Char) -> Int -> String -> String\nconst showIntAtBase = base => toChr => n => rs => {\n    const go = ([n, d], r) => {\n        const r_ = toChr(d) + r;\n        return 0 !== n ? (\n            go(Array.from(quotRem(n)(base)), r_)\n        ) : r_;\n    };\n    return 1 >= base ? (\n        'error: showIntAtBase applied to unsupported base'\n    ) : 0 > n ? (\n        'error: showIntAtBase applied to negative number'\n    ) : go(Array.from(quotRem(n)(base)), rs);\n};",
  "showJSON": "// showJSON :: a -> String\nconst showJSON = x =>\n    // Indented JSON representation of the value x.\n    JSON.stringify(x, null, 2);",
  "showLR": "// showLR :: Either a b -> String\nconst showLR = lr => {\n    const k = undefined !== lr.Left ? (\n        'Left'\n    ) : 'Right';\n    return k + '(' + unQuoted(show(lr[k])) + ')';\n};",
  "showList": "// showList :: [a] -> String\nconst showList = xs =>\n    '[' + xs.map(show)\n    .join(', ')\n    .replace(/[\\\"]/g, '') + ']';",
  "showLog": "// showLog :: a -> IO ()\nconst showLog = (...args) =>\n    console.log(\n        args\n        .map(JSON.stringify)\n        .join(\" -> \")\n    );",
  "showMaybe": "// showMaybe :: Maybe a -> String\nconst showMaybe = mb =>\n    mb.Nothing ? (\n        'Nothing'\n    ) : 'Just(' + unQuoted(show(mb.Just)) + ')';",
  "showMenuLR": "// showMenuLR :: Bool -> String -> String -> \n// [String] -> String -> Either String [String]\nconst showMenuLR = blnMult =>\n    // An optionally multi-choice menu, with \n    // a given title and prompt string.\n    // Listing the strings in xs, with \n    // the the string `selected` pre-selected\n    // if found in xs.\n    title => prompt => xs =>\n    selected => 0 < xs.length ? (() => {\n        const sa = Object.assign(\n            Application('System Events'), {\n                includeStandardAdditions: true\n            });\n        sa.activate();\n        const v = sa.chooseFromList(xs, {\n            withTitle: title,\n            withPrompt: prompt,\n            defaultItems: xs.includes(selected) ? (\n                [selected]\n            ) : [xs[0]],\n            okButtonName: 'OK',\n            cancelButtonName: 'Cancel',\n            multipleSelectionsAllowed: blnMult,\n            emptySelectionAllowed: false\n        });\n        return Array.isArray(v) ? (\n            Right(v)\n        ) : Left('User cancelled ' + title + ' menu.');\n    })() : Left(title + ': No items to choose from.');",
  "showOrdering": "// showOrdering :: Ordering -> String\nconst showOrdering = e =>\n    0 < e.value ? (\n        'GT'\n    ) : 0 > e.value ? (\n        'LT'\n    ) : 'EQ';",
  "showOutline": "// showOutline :: Tree String -> String\nconst showOutline = tree => {\n    const go = indent => x =>\n        unlines(\n            [indent + x.root].concat(\n                x.nest.flatMap(go('    ' + indent))\n            )\n        );\n    return go('')(tree);\n};",
  "showPrecision": "// showPrecision :: Int -> Float -> String\nconst showPrecision = n => x => {\n    // A string showing a floating point number\n    // at a given degree of precision.\n    const d = Math.pow(10, n);\n    return str(Math.round(d * x) / d);\n};",
  "showRatio": "// showRatio :: Ratio -> String\nconst showRatio = r =>\n    'Ratio' !== r.type ? (\n        r.toString()\n    ) : r.n.toString() + (\n        1 !== r.d ? (\n            '/' + r.d.toString()\n        ) : ''\n    );",
  "showSet": "// showSet :: Set a -> String\nconst showSet = oSet =>\n    '{' + Array.from(oSet)\n    .map(x => x.toString())\n    .join(',') + '}';",
  "showTree": "// showTree :: Tree a -> String\nconst showTree = x =>\n    drawTree(\n        fmapTree(show)(x)\n    );",
  "showTuple": "// showTuple :: Tuple -> String\nconst showTuple = tpl =>\n    '(' + enumFromTo(0)(tpl.length - 1)\n    .map(x => unQuoted(show(tpl[x])))\n    .join(',') + ')';",
  "showUndefined": "// showUndefined :: () -> String\nconst showUndefined = () => '(⊥)';",
  "signum": "// signum :: Num -> Num\nconst signum = n =>\n    // | Sign of a number.\n    // The functions 'abs' and 'signum' should satisfy the law:\n    //\n    // > abs x * signum x == x\n    //\n    // For real numbers, the 'signum' is either @-1@ (negative), @0@ (zero)\n    // or @1@ (positive).\n    0 > n ? (\n        -1\n    ) : (\n        0 < n ? 1 : 0\n    );",
  "sj": "// sj :: a -> String\nconst sj = (...args) =>\n    // Abbreviation of showJSON for quick testing.\n    // Default indent size is two, which can be\n    // overriden by any integer supplied as the\n    // first argument of more than one.\n    JSON.stringify.apply(\n        null,\n        1 < args.length && !isNaN(args[0]) ? [\n            args[1], null, args[0]\n        ] : [args[0], null, 2]\n    );",
  "snd": "// snd :: (a, b) -> b\nconst snd = tpl =>\n    // Second member of a pair.\n    tpl[1];",
  "snoc": "// snoc :: [a] -> a -> [a]\nconst snoc = xs =>\n    // The mirror image of cons\n    // A new copy of the given list, \n    // with an atom appended at the end.\n    x => list(xs).concat(x);",
  "sort": "// sort :: Ord a => [a] -> [a]\nconst sort = xs =>\n    // An A-Z sorted copy of xs.\n    list(xs).slice()\n    .sort((a, b) => a < b ? -1 : (a > b ? 1 : 0));",
  "sortBy": "// sortBy :: (a -> a -> Ordering) -> [a] -> [a]\nconst sortBy = f =>\n    xs => list(xs).slice()\n    .sort((a, b) => f(a)(b));",
  "sortOn": "// sortOn :: Ord b => (a -> b) -> [a] -> [a]\nconst sortOn = f =>\n    // Equivalent to sortBy(comparing(f)), but with f(x)\n    // evaluated only once for each x in xs.\n    // ('Schwartzian' decorate-sort-undecorate).\n    xs => xs.map(\n        x => Tuple(f(x))(x)\n    )\n    .sort(uncurry(comparing(fst)))\n    .map(snd);",
  "span": "// span :: (a -> Bool) -> [a] -> ([a], [a])\nconst span = p =>\n    // Longest prefix of xs consisting of elements which\n    // all satisfy p, tupled with the remainder of xs.\n    xs => {\n        const i = xs.findIndex(x => !p(x));\n        return -1 !== i ? (\n            Tuple(xs.slice(0, i))(\n                xs.slice(i)\n            )\n        ) : Tuple(xs)([]);\n    };",
  "splitArrow (***)": "// splitArrow (***) :: (a -> b) -> (c -> d) -> ((a, c) -> (b, d))\nconst splitArrow = f =>\n    // The functions f and g combined in a single function\n    // from a tuple (x, y) to a tuple of (f(x), g(y))\n    // (see bimap)\n    g => tpl => Tuple(f(tpl[0]))(\n        g(tpl[1])\n    );",
  "splitAt": "// splitAt :: Int -> [a] -> ([a], [a])\nconst splitAt = n =>\n    xs => Tuple(xs.slice(0, n))(\n        xs.slice(n)\n    );",
  "splitBy": "// splitBy :: (a -> a -> Bool) -> [a] -> [[a]]\n// splitBy :: (String -> String -> Bool) -> String -> [String]\nconst splitBy = p =>\n    // Splitting not on a delimiter, but wherever the relationship\n    // between consecutive terms matches a binary predicate.\n    xs => (xs.length < 2) ? [xs] : (() => {\n        const\n            bln = 'string' === typeof xs,\n            ys = bln ? xs.split('') : xs,\n            h = ys[0],\n            parts = ys.slice(1)\n            .reduce(([acc, active, prev], x) =>\n                p(prev)(x) ? (\n                    [acc.concat([active]), [x], x]\n                ) : [acc, active.concat(x), x], [\n                    [],\n                    [h],\n                    h\n                ]);\n        return (bln ? (\n            ps => ps.map(cs => ''.concat.apply('', cs))\n        ) : x => x)(parts[0].concat([parts[1]]));\n    })();",
  "splitFileName": "// splitFileName :: FilePath -> (String, String)\nconst splitFileName = strPath =>\n    // Tuple of directory and file name, derived from file path.\n    // Inverse of combine.\n    ('' !== strPath) ? (\n         ('/' !== strPath[strPath.length - 1]) ? (() => {\n            const\n                xs = strPath.split('/'),\n                stem = xs.slice(0, -1);\n            return stem.length > 0 ? (\n                Tuple(stem.join('/') + '/')(xs.slice(-1)[0])\n            ) : Tuple('./')(xs.slice(-1)[0]);\n        })() : Tuple(strPath)('')\n    ) : Tuple('./')('');",
  "splitOn": "// splitOn :: [a] -> [a] -> [[a]]\n// splitOn :: String -> String -> [String]\nconst splitOn = pat => src =>\n    /* A list of the strings delimited by\n       instances of a given pattern in s. */\n    ('string' === typeof src) ? (\n        src.split(pat)\n    ) : (() => {\n        const\n            lng = pat.length,\n            tpl = findIndices(matching(pat))(src).reduce(\n                (a, i) => Tuple(\n                    fst(a).concat([src.slice(snd(a), i)])\n                )(lng + i),\n                Tuple([])(0)\n            );\n        return fst(tpl).concat([src.slice(snd(tpl))]);\n    })();",
  "splitRegex": "// splitRegex :: Regex -> String -> [String]\nconst splitRegex = needle =>\n    haystack => haystack.split(needle);",
  "sqrt": "// sqrt :: Num -> Num\nconst sqrt = n =>\n    (0 <= n) ? Math.sqrt(n) : undefined;",
  "sqrtLR": "// sqrtLR :: Num -> Either String Num\nconst sqrtLR = n =>\n    0 > n ? (\n        Left('Square root of negative number: ' + n)\n    ) : Right(Math.sqrt(n));",
  "sqrtMay": "// sqrtMay :: Num -> Maybe Num\nconst sqrtMay = n =>\n    0 > n ? (\n        Nothing()\n    ) : Just(Math.sqrt(n));",
  "str": "// str :: a -> String\nconst str = x =>\n    Array.isArray(x) && x.every(\n        v => (\"string\" === typeof v) && (1 === v.length)\n    ) ? (\n        // [Char] -> String\n        x.join(\"\")\n    ) : null === x ? (\n        \"null\"\n    ) : x.toString();",
  "strip": "// strip :: String -> String\nconst strip = s =>\n    s.trim();",
  "stripEnd": "// stripEnd :: String -> String\nconst stripEnd = s =>\n    s.trimEnd();",
  "stripPrefix": "// stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]\nconst stripPrefix = pfx =>\n    s => {\n        const\n            blnString = 'string' === typeof pfx,\n            [xs, ys] = blnString ? (\n                [pfx.split(''), s.split('')]\n            ) : [pfx, s];\n        const\n            sp_ = (xs, ys) => 0 === xs.length ? (\n                Just(blnString ? ys.join('') : ys)\n            ) : (0 === ys.length || xs[0] !== ys[0]) ? (\n                Nothing()\n            ) : sp_(xs.slice(1), ys.slice(1));\n        return sp_(xs, ys);\n    };",
  "stripStart": "// stripStart :: String -> String\nconst stripStart = s =>\n    s.trimStart();",
  "subTreeAtPath": "// subTreeAtPath :: Tree String -> [String] -> Maybe Tree String\nconst subTreeAtPath = tree => path => {\n    const go = (nest, xs) =>\n        0 < nest.length && 0 < xs.length ? (() => {\n            const h = xs[0];\n            return bindMay(find(t => h === t.root, nest))(\n                t => 1 < xs.length ? (\n                    go(t.nest, xs.slice(1))\n                ) : Just(t)\n            );\n        })() : Nothing();\n    return go([tree], path);\n};",
  "subsequences": "// subsequences :: [a] -> [[a]]\n// subsequences :: String -> [String]\nconst subsequences = xs => {\n    // subsequences([1,2,3]) -> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n    // subsequences('abc') -> [\"\",\"a\",\"b\",\"ab\",\"c\",\"ac\",\"bc\",\"abc\"]\n    const\n        // nonEmptySubsequences :: [a] -> [[a]]\n        nonEmptySubsequences = xxs => {\n            if (xxs.length < 1) return [];\n            const [x, xs] = [xxs[0], xxs.slice(1)];\n            const f = (r, ys) => cons(ys)(cons(cons(x)(ys))(r));\n            return cons([x])(nonEmptySubsequences(xs)\n                .reduceRight(f, []));\n        };\n    return ('string' === typeof xs) ? (\n        cons('')(nonEmptySubsequences(xs.split(''))\n            .map(x => ''.concat.apply('', x))) // map(concat)\n    ) : cons([])(nonEmptySubsequences(xs));\n};",
  "subsets": "// subsets :: [a] -> [[a]]\nconst subsets = xs => {\n    const go = ys =>\n        0 < ys.length ? (() => {\n            const\n                h = ys[0],\n                zs = go(ys.slice(1));\n            return zs.concat(\n                zs.map(z => [h].concat(z))\n            );\n        })() : [\n            []\n        ];\n    return go(xs);\n};",
  "subtract": "// subtract :: Num -> Num -> Num\nconst subtract = x =>\n    y => y - x;",
  "succ": "// succ :: Enum a => a -> a\nconst succ = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mx] = [x, maxBound(x)].map(fromEnum);\n        return i < mx ? (\n            toEnum(x)(1 + i)\n        ) : Error('succ :: enum out of range.');\n    })() : x < Number.MAX_SAFE_INTEGER ? (\n        1 + x\n    ) : Error('succ :: Num out of range.');\n};",
  "succMay": "// succMay :: Enum a => a -> Maybe a\nconst succMay = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mx] = [x, maxBound(x)].map(fromEnum);\n        return i < mx ? (\n            Just(toEnum(x)(1 + i))\n        ) : Nothing();\n    })() : x < Number.MAX_SAFE_INTEGER ? (\n        Just(1 + x)\n    ) : Nothing();\n};",
  "sum": "// sum :: [Num] -> Num\nconst sum = xs =>\n    // The numeric sum of all values in xs.\n    xs.reduce((a, x) => a + x, 0);",
  "swap": "// swap :: (a, b) -> (b, a)\nconst swap = ab =>\n    // The pair ab with its order reversed.\n    Tuple(ab[1])(\n        ab[0]\n    );",
  "tail": "// tail :: [a] -> [a]\nconst tail = xs =>\n    // A new list consisting of all\n    // items of xs except the first.\n    'GeneratorFunction' !== xs.constructor\n    .constructor.name ? (\n        (ys => 0 < ys.length ? ys.slice(1) : [])(\n            list(xs)\n        )\n    ) : (take(1)(xs), xs);",
  "tailMay": "// tailMay :: [a] -> Maybe [a]\nconst tailMay = xs => (\n    ys => 0 < ys.length ? (\n        Just(ys.slice(1))\n    ) : Nothing()\n)(list(xs));",
  "tails": "// tails :: [a] -> [[a]]\nconst tails = xs => (\n    es => es.map((_, i) => es.slice(i))\n    .concat([\n        []\n    ])\n)(list(xs));",
  "take": "// take :: Int -> [a] -> [a]\n// take :: Int -> String -> String\nconst take = n =>\n// The first n elements of a list,\n// string of characters, or stream.\n    xs => \"GeneratorFunction\" !== xs\n    .constructor.constructor.name ? (\n            xs.slice(0, n)\n        ) : Array.from({\n            length: n\n        }, () => {\n            const x = xs.next();\n\n            return x.done ? [] : [x.value];\n        });",
  "takeAround": "// takeAround :: (a -> Bool) -> [a] -> [a]\nconst takeAround = p => xs => {\n    const ys = takeWhile(p)(xs);\n    return ys.length < xs.length ? (\n        ys.concat(takeWhileR(p)(xs))\n    ) : ys;\n};",
  "takeBaseName": "// takeBaseName :: FilePath -> String\nconst takeBaseName = strPath =>\n  ('' !== strPath) ? (\n    ('/' !== strPath[strPath.length - 1]) ? (() => {\n      const fn = strPath.split('/').slice(-1)[0];\n      return fn.includes('.') ? (\n        fn.split('.').slice(0, -1).join('.')\n      ) : fn;\n    })() : ''\n  ) : '';",
  "takeCycle": "// takeCycle :: Int -> [a] -> [a]\nconst takeCycle = n =>\n    // First n elements of a non-finite cycle of xs.\n    xs => {\n        const lng = xs.length;\n        return (\n            n <= xs ? (\n                xs\n            ) : concat(\n                replicate(Math.ceil(n / lng))(\n                    xs\n                )\n            )\n        ).slice(0, n);\n    };",
  "takeDirectory": "// takeDirectory :: FilePath -> FilePath\nconst takeDirectory = fp =>\n    '' !== fp ? (\n        (xs => xs.length > 0 ? xs.join('/') : '.')(\n            fp.split('/').slice(0, -1)\n        )\n    ) : '.';",
  "takeDropCycle": "// takeDropCycle :: Int -> [a] -> [a]\nconst takeDropCycle = n =>\n    // N Members of an infinite cycle of xs, starting from index I\n    i => xs => drop(i)(\n        take(n + i)(cycle(xs))\n    );",
  "takeExtension": "// takeExtension :: FilePath -> String\nconst takeExtension = fp => (\n    fs => {\n        const fn = last(fs);\n        return fn.includes('.') ? (\n            '.' + last(fn.split('.'))\n        ) : '';\n    }\n)(fp.split('/'));",
  "takeFileName": "// takeFileName :: FilePath -> FilePath\nconst takeFileName = fp =>\n    '' !== fp ? (\n        '/' !== fp[fp.length - 1] ? (\n            fp.split('/').slice(-1)[0]\n        ) : ''\n    ) : '';",
  "takeFromThenTo": "// takeFromThenTo :: Int -> Int -> Int -> [a] -> [a]\nconst takeFromThenTo = a => b => z => xs => {\n    const ixs = enumFromThenTo(a)(b)(z);\n    return 'GeneratorFunction' !== xs.constructor\n    .constructor.name ? (\n        ixs.map(i => xs[i])\n    ) : (() => {\n        const g = zipGen(enumFrom(0))(\n            take(z)(xs)\n        );\n        return ixs.flatMap(i => {\n            const mb = index(g)(i);\n            return mb.Nothing ? [] : [mb.Just];\n        });\n    })();\n};",
  "takeIterate": "// takeIterate n f x == [x, f x, f (f x), ...]\n// takeIterate :: Int -> (a -> a) -> a -> [a]\nconst takeIterate = n => f => x =>\n    snd(mapAccumL(a => _ => i => {\n        const v = 0 !== i ? f(a) : x;\n        return [v, v];\n    }, x, Array.from({\n        length: n\n    })));",
  "takeWhile": "// takeWhile :: (a -> Bool) -> [a] -> [a]\n// takeWhile :: (Char -> Bool) -> String -> String\nconst takeWhile = p =>\n    // The longest prefix of xs in which\n    // every element satisfies p.\n    xs => xs.constructor.constructor.name !==\n    'GeneratorFunction' ? (() => {\n        const n = xs.length;\n        return xs.slice(\n            0, 0 < n ? until(\n                i => n === i || !p(xs[i])\n            )(i => 1 + i)(0) : 0\n        );\n    })() : takeWhileGen(p)(xs);",
  "takeWhileGen": "// takeWhileGen :: (a -> Bool) -> Gen [a] -> [a]\nconst takeWhileGen = p => xs => {\n    const ys = [];\n    let\n        nxt = xs.next(),\n        v = nxt.value;\n    while (!nxt.done && p(v)) {\n        ys.push(v);\n        nxt = xs.next();\n        v = nxt.value;\n    }\n    return ys;\n};",
  "takeWhileR": "// takeWhileR :: (a -> Bool) -> [a] -> [a]\nconst takeWhileR = p =>\n    // The longest suffix of xs in which\n    // all elements satisfy p.\n    xs => {\n        const ys = list(xs);\n        let i = ys.length;\n        while (i-- && p(ys[i])) {}\n        return ys.slice(i + 1);\n    };",
  "taskPaperDateString": "// taskPaperDateString :: Date -> String\nconst taskPaperDateString = dte => {\n    const [d, t] = iso8601Local(dte).split('T');\n    return [d, t.slice(0, 5)].join(' ');\n};",
  "taskPaperDayString": "// taskPaperDayString :: Date -> String\nconst taskPaperDayString = dte =>\n    take(10)(\n        taskPaperDateString(dte)\n    );",
  "tempFilePath": "// tempFilePath :: String -> IO FilePath\nconst tempFilePath = template =>\n    // File name template to temporary path\n    // Random digit sequence inserted between\n    // template base and extension\n    ObjC.unwrap($.NSTemporaryDirectory()) +\n    takeBaseName(template) + Math.random()\n    .toString()\n    .substring(3) + takeExtension(template);",
  "toEnum": "// toEnum :: a -> Int -> a\nconst toEnum = e =>\n    // The first argument is a sample of the type\n    // allowing the function to make the right mapping\n    x => ({\n        'number': Number,\n        'string': String.fromCodePoint,\n        'boolean': Boolean,\n        'object': v => e.min + v\n    } [typeof e])(x);",
  "toLower": "// toLower :: String -> String\nconst toLower = s =>\n    // Lower-case version of string.\n    s.toLocaleLowerCase();",
  "toRatio": "// toRatio :: Real -> Ratio\nconst toRatio = n =>\n    approxRatio(1e-12)(n);",
  "toSentence": "// toSentence :: String -> String\nconst toSentence = s =>\n    // Sentence case - initial char capitalized \n    // and rest lowercase.\n    (0 < s.length) ? (\n        s[0].toUpperCase() + s.slice(1)\n        .toLowerCase()\n    ) : s;",
  "toTitle": "// toTitle :: String -> String\nconst toTitle = s =>\n    // NB this does not model any regional or cultural conventions.\n    // It simply simply capitalizes the first character of each word.\n    regexMatches(/(\\w)(\\w*)(\\b[\\W]*|$)/g)(s)\n    .map(ms => ms[1].toUpperCase() + ms[2].toLowerCase() + ms[3])\n    .join('');",
  "toUpper": "// toUpper :: String -> String\nconst toUpper = s =>\n    s.toLocaleUpperCase();",
  "transpose": "// transpose :: [[a]] -> [[a]]\nconst transpose = xss => {\n    // If any rows are shorter than those that follow, \n    // their elements are skipped:\n    // > transpose [[10,11],[20],[],[30,31,32]]\n    //             == [[10,20,30],[11,31],[32]]\n    const go = xss =>\n        0 < xss.length ? (() => {\n            const\n                h = xss[0],\n                t = xss.slice(1);\n            return 0 < h.length ? [\n                [h[0]].concat(t.reduce(\n                    (a, xs) => a.concat(\n                        0 < xs.length ? (\n                            [xs[0]]\n                        ) : []\n                    ),\n                    []\n                ))\n            ].concat(go([h.slice(1)].concat(\n                t.map(xs => xs.slice(1))\n            ))) : go(t);\n        })() : [];\n    return go(xss);\n};",
  "transpose_": "// transpose_ :: [[a]] -> [[a]]\nconst transpose_ = rows =>\n    // The columns of the input transposed\n    // into new rows.\n    // Simpler version of transpose, assuming input \n    // rows of even length.\n    0 < rows.length ? rows[0].map(\n        (x, i) => rows.flatMap(\n            x => x[i]\n        )\n    ) : [];",
  "traverse": "// traverse :: (Applicative f, Traversable t) => \n// (a -> f b) -> t a -> f (t b)\nconst traverse = f =>\n    // Each element of a structure mapped to an \n    // a functor-wrapped value, with evaluation from\n    // from left to right, and the results collected\n    // in a single instance of the target functor.\n    tx => ({\n        'Either': () => traverseLR,\n        'Maybe': () => traverseMay,\n        'Node': () => traverseTree,\n        'Tuple': () => traverseTuple,\n        'List': () => traverseList\n    })[tx.type || 'List']()(f)(tx);",
  "traverseLR": "// traverseLR :: Applicative f => \n// (t -> f b) -> Either a t -> f (Either a b)\nconst traverseLR = f =>\n    // instance of Traversable (Either a) where\n    //    traverse _ (Left x) = pure (Left x)\n    //    traverse f (Right y) = Right <$> f y\n    lr => undefined !== lr.Left ? (\n        [lr]\n    ) : fmap(Right)(\n        f(lr.Right)\n    );",
  "traverseList": "// traverseList :: (Applicative f) => (a -> f b) -> [a] -> f [b]\nconst traverseList = f =>\n    // Collected results of mapping each element\n    // of a structure to an action, and evaluating\n    // these actions from left to right.\n    xs => (\n        zs => 0 < zs.length ? (() => {\n            const\n                vLast = f(zs.slice(-1)[0]),\n                t = vLast.type || 'List';\n            return zs.slice(0, -1).reduceRight(\n                (ys, z) => liftA2(cons)(f(z))(ys),\n                liftA2(cons)(vLast)(pureT(t)([]))\n            );\n        })() : fType(f)([])\n    )(list(xs));",
  "traverseMay": "// traverseMay :: Applicative f => (t -> f a) -> Maybe t -> f (Maybe a)\nconst traverseMay = f => mb =>\n    mb.Nothing ? (\n        [mb]\n    ) : fmap(Just)(\n        f(mb.Just)\n    );",
  "traverseTree": "// traverseTree :: Applicative f => (a -> f b) -> Tree a -> f (Tree b)\nconst traverseTree = f => {\n    // traverse f (Node x ts) = liftA2 Node (f x) (traverse (traverse f) ts)\n    const go = tree =>\n        liftA2(Node)(f(tree.root))(\n            traverseList(go)(\n                tree.nest\n            )\n        );\n    return go;\n};",
  "traverseTuple": "// traverseTuple :: Functor f => (t -> f b) -> (a, t) -> f (a, b)\nconst traverseTuple = f => tpl =>\n    fmap(Tuple(tpl[0]))(\n        f(tpl[1])\n    );",
  "treeFromDict": "// treeFromDict :: String -> Dict -> Tree String\nconst treeFromDict = rootLabel =>\n    dict => {\n        const go = x =>\n            'object' !== typeof x ? [] : (\n                Array.isArray(x) ? (\n                    x.flatMap(go)\n                ) : keys(x).map(\n                    k => Node(k)(\n                        go(x[k])\n                    )\n                )\n            );\n        return Node(rootLabel)(\n            go(dict)\n        );\n    };",
  "treeFromJSON": "// treeFromJSON :: JSON String -> Tree a\nconst treeFromJSON = json => {\n    // Assumes a recursive [root, nest] JSON format,\n    // in which `root` is a parseable value string, and `nest`\n    // is a possibly empty list of [`root`, `nest`] pairs.\n    const go = ([root, nest]) =>\n        Node(root)(nest.map(go));\n    return go(JSON.parse(json));\n};",
  "treeFromNestedDict": "// treeFromNestedDict -> Dict -> Either String Tree Dict\nconst treeFromNestedDict = dict => {\n    // A generic Tree structure from a dict\n    // with keys assumed to include no more than\n    // one key to a *list* value,\n    // with this pattern applied recursively\n    // to each child dictionary in such a list.\n    const go = dct => {\n        const\n            kvs = Object.entries(dct),\n            lists = kvs.filter(\n                ([_, v]) => Array.isArray(v)\n            ),\n            lng = lists.length;\n        return 0 < lng ? (\n            1 < lng ? (\n                Left(\n                    'Ambiguous structure :: ' +\n                    lng.toString() + (\n                        ' multiple sublists in:\\n  \"' +\n                        dct.name + (\n                            '\":\\n' + bulleted('    ')(\n                                unlines(lists.map(fst))\n                            )\n                        )\n                    )\n                )\n            ) : (() => {\n                const [nestName, xs] = lists[0];\n                return bindLR(traverseList(go)(xs))(\n                    xs => Right(\n                        Node(\n                            Object.assign(\n                                deleteKey(nestName)(\n                                    dct\n                                ), {\n                                    'List title': nestName\n                                }\n                            )\n                        )(xs)\n                    )\n                );\n            })()\n        ) : Right(Node(dct)([]));\n    };\n    return go(dict);\n};",
  "treeLeaves": "// treeLeaves :: Tree -> [Tree]\nconst treeLeaves = tree => {\n  const nest = tree.nest;\n  return (0 < nest.length) ? (\n    nest.flatMap(treeLeaves)\n  ) : [tree];\n};",
  "treeMatches": "// treeMatches :: (a -> Bool) -> Tree a -> [Tree a]\nconst treeMatches = p => {\n    // A list of all nodes in the tree which match \n    // a predicate p.\n    // For the first match only, see findTree.\n    const go = tree =>\n        p(tree.root) ? (\n            [tree]\n        ) : tree.nest.flatMap(go);\n    return go;\n};",
  "treeMenu": "// treeMenu :: Tree String -> IO [String]\nconst treeMenu = tree => {\n    const go = t => {\n        const\n            strTitle = t.root,\n            subs = t.nest,\n            menu = subs.map(root),\n            blnMore = 0 < subs.flatMap(nest).length;\n        return until(tpl => !fst(tpl) || !isNull(snd(tpl)))(\n            tpl => either(\n                x => Tuple(false)([])\n            )(\n                Tuple(true)\n            )(\n                bindLR(showMenuLR(!blnMore)(strTitle)(menu))(\n                    ks => {\n                        const k = ks[0];\n                        return maybe(\n                            Left(k + ': not found in ' +\n                                JSON.stringify(ks)\n                            )\n                        )(Right)(\n                            bindMay(find(x => k === x.root)(subs))(\n                                chosen => Just(\n                                    isNull(chosen.nest) ? (\n                                        ks // Choice made in leaf menu.\n                                    ) : go(chosen)\n                                )\n                            )\n                        );\n                    }\n                )\n            )\n        )(Tuple(true)([]))[1];\n    };\n    return go(tree);\n};",
  "treeMenuBy": "// treeMenuBy :: (a -> String) Tree a -> IO [a]\nconst treeMenuBy = fNodeKey => {\n    const go = tree => {\n        const\n            strTitle = fNodeKey(tree.root),\n            subTrees = nest(tree),\n            menu = subTrees.map(\n                compose(fNodeKey, root)\n            ).sort();\n        return until(\n            tpl => !fst(tpl) || !isNull(snd(tpl))\n        )(\n            tpl => either(\n                x => Tuple(false)([])\n            )(\n                Tuple(true)\n            )(\n                bindLR(\n                    showMenuLR(true)(strTitle)(menu)\n                )(\n                    ks => {\n                        const k0 = ks[0];\n                        return maybe(\n                            Left(\n                                k0 + ': not found in ' +\n                                JSON.stringify(ks)\n                            )\n                        )(Right)(\n                            bindMay(\n                                find(\n                                    x => k0 === fNodeKey(\n                                        x.root\n                                    )\n                                )(subTrees)\n                            )(\n                                firstChosen => Just(\n                                    isNull(\n                                        nest(firstChosen)\n                                    ) ? (\n                                        ks.map(\n                                            k => find(\n                                                x => k === fNodeKey(\n                                                    x.root\n                                                )\n                                            )(subTrees).Just\n                                        )\n                                    ) : go(firstChosen)\n                                )\n                            )\n                        );\n                    }\n                )\n            )\n        )(Tuple(true)([]))[1];\n    };\n    return go;\n};",
  "truncate": "// truncate :: Num -> Int\nconst truncate = x =>\n    'Ratio' === x.type ? (\n        properFracRatio(x)[0]\n    ) : properFraction(x)[0];",
  "tupleFromList": "// tupleFromList :: [a] -> (a, a ...)\nconst tupleFromList = xs =>\n    TupleN(...xs);",
  "typeName": "// typeName :: a -> String\nconst typeName = v => {\n    const t = typeof v;\n    return 'object' === t ? (\n        Array.isArray(v) ? (\n            'List'\n        ) : 'Date' === v.constructor.name ? (\n            'Date'\n        ) : null !== v ? (\n            v.type || 'Dict'\n        ) : 'Bottom'\n    ) : {\n        'boolean': 'Bool',\n        'date': 'Date',\n        'number': 'Num',\n        'string': 'String',\n        'function': '(a -> b)'\n    } [t] || 'Bottom';\n};",
  "unDigits": "// unDigits :: [Int] -> Int\nconst unDigits = ds =>\n    // The integer with the given digits.\n    ds.reduce((a, x) => 10 * a + x, 0);",
  "unQuoted": "// unQuoted :: String -> String\nconst unQuoted = s =>\n    1 < s.length ? (\n        q => s.slice(\n            q !== s[0] ? 0 : 1,\n            q !== s.slice(-1) ? undefined : -1\n        )\n    )(\n        String.fromCodePoint(34)\n    ) : s;",
  "uncons": "// uncons :: [a] -> Maybe (a, [a])\nconst uncons = xs => {\n    // Just a tuple of the head of xs and its tail, \n    // Or Nothing if xs is an empty list.\n    const lng = length(xs);\n    return (0 < lng) ? (\n        Infinity > lng ? (\n            Just(Tuple(xs[0])(xs.slice(1))) // Finite list\n        ) : (() => {\n            const nxt = take(1)(xs);\n            return 0 < nxt.length ? (\n                Just(Tuple(nxt[0])(xs))\n            ) : Nothing();\n        })() // Lazy generator\n    ) : Nothing();\n};",
  "uncurry": "// uncurry :: (a -> b -> c) -> ((a, b) -> c)\nconst uncurry = f =>\n    // A function over a pair, derived\n    // from a curried function.\n    function() {\n        const\n            args = arguments,\n            xy = Boolean(args.length % 2) ? (\n                args[0]\n            ) : args;\n        return f(xy[0])(xy[1]);\n    };",
  "uncurryN": "// uncurryN :: Curry a b => b -> a\nconst uncurryN = f =>\n    // A function over a tuple of values, derived from\n    // a curried function of any number of arguments.\n    (...args) => (\n        xs => xs.slice(1).reduce(\n            (a, x) => a(x), \n            f(xs[0])\n        )\n    )(Array.from(\n        1 < args.length ? (\n            args\n        ) : args[0]\n    ));",
  "unfoldForest": "// unfoldForest :: (b -> (a, [b])) -> [b] -> [Tree]\nconst unfoldForest = f =>\n    // A forest built from a list of seed values.\n    xs => xs.map(unfoldTree(f));",
  "unfoldTree": "// unfoldTree :: (b -> (a, [b])) -> b -> Tree a\nconst unfoldTree = f =>\n    // A tree unfolded in breadth-first order\n    // from a seed value.\n    // Given a seed value, f defines a tuple:\n    // (Node root value, [seed])\n    // Empty seed lists conclude recursion.\n    b => uncurry(Node)(\n        second(unfoldForest(f))(\n            f(b)\n        )\n    );",
  "unfoldl": "// unfoldl :: (b -> Maybe (b, a)) -> b -> [a]\nconst unfoldl = f => v => {\n    // Dual to reduce or foldl.\n    // Where these reduce a list to a summary value, unfoldl\n    // builds a list from a seed value.\n    // Where f returns Just(a, b), a is appended to the list,\n    // and the residual b is used as the argument for the next\n    // application of f.\n    // Where f returns Nothing, the completed list is returned.\n    // unfoldl(x => 0 !== x ? Just([x - 1, x]) : Nothing(), 10);\n    // --> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    let\n        xr = [v, v],\n        xs = [];\n    while (true) {\n        const mb = f(xr[0]);\n        if (mb.Nothing) {\n            return xs;\n        } else {\n            xr = mb.Just;\n            xs = [xr[1]].concat(xs);\n        }\n    }\n};",
  "unfoldr": "// unfoldr :: (b -> Maybe (a, b)) -> b -> Gen [a]\nconst unfoldr = f =>\n    // A lazy (generator) list unfolded from a seed value\n    // by repeated application of f to a value until no\n    // residue remains. Dual to fold/reduce.\n    // f returns either Nothing or Just (value, residue).\n    // For a strict output list, \n    // wrap with `list` or Array.from\n    x => function* () {\n        let maybePair = f(x);\n        while (!maybePair.Nothing) {\n            const valueResidue = maybePair.Just;\n            yield valueResidue[0];\n            maybePair = f(valueResidue[1]);\n        }\n    }();",
  "union": "// union :: [a] -> [a] -> [a]\nconst union = xs => ys =>\n  unionBy(a => b => a === b)(\n      list(xs)\n  )(list(ys));",
  "unionBy": "// unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst unionBy = fnEq => xs => ys => {\n    const sx = nubBy(fnEq)(xs);\n    return sx.concat(\n        sx.reduce(\n            (a, x) => deleteBy(fnEq)(\n                x\n            )(a),\n            nubBy(fnEq)(ys)\n        )\n    );\n};",
  "unionSet": "// unionSet :: Ord a => Set a -> Set a -> Set a\nconst unionSet = s => s1 =>\n    Array.from(s1.values())\n    .reduce(\n        (a, x) => (a.add(x), a),\n        new Set(s)\n    );",
  "unlines": "// unlines :: [String] -> String\nconst unlines = xs =>\n    // A single string formed by the intercalation\n    // of a list of strings with the newline character.\n    xs.join('\\n');",
  "unsnoc": "// unsnoc :: [a] -> Maybe ([a], a)\nconst unsnoc = xs =>\n    // Nothing if the list is empty, otherwise\n    // Just the init and the last.\n    (0 < xs.length) ? (\n        Just(Tuple(xs.slice(0, -1))(xs.slice(-1)[0]))\n    ) : Nothing();",
  "until": "// until :: (a -> Bool) -> (a -> a) -> a -> a\nconst until = p =>\n    // The value resulting from repeated applications\n    // of f to the seed value x, terminating when\n    // that result returns true for the predicate p.\n    f => x => {\n        let v = x;\n\n        while (!p(v)) {\n            v = f(v);\n        }\n\n        return v;\n    };",
  "unwords": "// unwords :: [String] -> String\nconst unwords = xs =>\n    // A space-separated string derived\n    // from a list of words.\n    xs.join(' ');",
  "unwrap": "// unwrap :: NSObject -> a\nconst unwrap = ObjC.unwrap;",
  "unzip": "// unzip :: [(a,b)] -> ([a],[b])\nconst unzip = xys =>\n    xys.reduce(\n        (ab, xy) => Tuple(ab[0].concat(xy[0]))(\n            ab[1].concat(xy[1])\n        ),\n        Tuple([])([])\n    );",
  "unzip3": "// unzip3 :: [(a,b,c)] -> ([a],[b],[c])\nconst unzip3 = xyzs =>\n    xyzs.reduce(\n        (a, x) => TupleN.apply(null, [0, 1, 2].map(\n            i => a[i].concat(x[i])\n        )),\n        TupleN([], [], [])\n    );",
  "unzip4": "// unzip4 :: [(a,b,c,d)] -> ([a],[b],[c],[d])\nconst unzip4 = wxyzs =>\n    wxyzs.reduce(\n        (a, x) => TupleN.apply(null, [0, 1, 2, 3].map(\n            i => a[i].concat(x[i])\n        )),\n        TupleN([], [], [], [])\n    );",
  "unzipN": "// unzipN :: [(a,b,...)] -> ([a],[b],...)\nconst unzipN = tpls =>\n    TupleN(...tpls.reduce(\n        (a, tpl) => a.map(\n            (x, i) => x.concat(tpl[i])\n        ),\n        replicate(\n            0 < tpls.length ? (\n                tpls[0].length\n            ) : 0, []\n        )\n    ));",
  "variance": "// variance :: [Num] -> Num\nconst variance = xs => {\n    const\n        lng = xs.length,\n        mean = xs.reduce((a, b) => a + b, 0) / lng;\n    return xs.reduce(\n        (a, b) => a + Math.pow(b - mean, 2),\n        0\n    ) / (lng - 1);\n};",
  "words": "// words :: String -> [String]\nconst words = s =>\n    // List of space-delimited sub-strings.\n    s.split(/\\s+/u);",
  "wrap": "// wrap :: a -> NSObject\nconst wrap = ObjC.wrap;",
  "writeFile": "// writeFile :: FilePath -> String -> IO ()\nconst writeFile = fp => s =>\n    $.NSString.alloc.initWithUTF8String(s)\n    .writeToFileAtomicallyEncodingError(\n        $(fp)\n        .stringByStandardizingPath, false,\n        $.NSUTF8StringEncoding, null\n    );",
  "writeFileLR": "// writeFileLR :: FilePath -> Either String IO FilePath\nconst writeFileLR = fp =>\n    s => {\n        const\n            e = $(),\n            efp = $(fp)\n            .stringByStandardizingPath;\n\n        return $.NSString.alloc.initWithUTF8String(s)\n            .writeToFileAtomicallyEncodingError(\n                efp, false,\n                $.NSUTF8StringEncoding, e\n            ) ? (\n                Right(ObjC.unwrap(efp))\n            ) : Left(ObjC.unwrap(e.localizedDescription));\n    };",
  "writeTempFile": "// writeTempFile :: String -> String -> IO FilePath\nconst writeTempFile = template =>\n    // File name template -> string data -> IO temporary path\n    txt => {\n        const\n            strPath = ObjC.unwrap($.NSTemporaryDirectory()) +\n            takeBaseName(template) + Math.random()\n            .toString()\n            .substring(3) + takeExtension(template);\n\n        return (writeFile(strPath)(txt), strPath);\n    };",
  "zip": "// zip :: [a] -> [b] -> [(a, b)]\nconst zip = xs =>\n    // The paired members of xs and ys, up to\n    // the length of the shorter of the two lists.\n    ys => Array.from({\n        length: Math.min(xs.length, ys.length)\n    }, (_, i) => Tuple(xs[i])(ys[i]));",
  "zip3": "// zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]\nconst zip3 = xs =>\n    ys => zs => list(xs)\n    .slice(0, Math.min(...[xs, ys, zs].map(length)))\n    .map((x, i) => TupleN(x, ys[i], zs[i]));",
  "zip4": "// zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]\nconst zip4 = ws =>\n    xs => ys => zs => list(ws)\n    .slice(0, Math.min(...[ws, xs, ys, zs].map(length)))\n    .map((w, i) => TupleN(w, xs[i], ys[i], zs[i]));",
  "zipGen": "// zipGen :: Gen [a] -> Gen [b] -> Gen [(a, b)]\nconst zipGen = ga => gb => {\n    function* go(ma, mb) {\n        let\n            a = ma,\n            b = mb;\n        while(!a.Nothing && !b.Nothing) {\n            let\n                ta = a.Just,\n                tb = b.Just;\n            yield(\n                Tuple(fst(ta))(\n                    fst(tb)\n                )\n            );\n            a = uncons(snd(ta));\n            b = uncons(snd(tb));\n        }\n    }\n    return go(uncons(ga), uncons(gb));\n};",
  "zipList": "// zipList :: [a] -> [b] -> [(a, b)]\nconst zipList = xs => ys => {\n    const\n        n = Math.min(length(xs), length(ys)),\n        vs = take(n)(list(ys));\n    return take(n)(list(xs))\n        .map((x, i) => Tuple(x)(vs[i]));\n};",
  "zipN": "// zipN :: [a] -> [b] -> ... -> [(a, b ...)]\nfunction zipN() {\n    const args = Array.from(arguments).map(list);\n    return 1 < args.length ? (\n        take(\n            Math.min(...args.map(length))\n        )(args[0]).map(\n            (x, i) => TupleN(...args.map(y => y[i]))\n        )\n    ) : args;\n}",
  "zipWith": "// zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst zipWith = f =>\n    // A list with the length of the shorter of \n    // xs and ys, defined by zipping with a\n    // custom function, rather than with the\n    // default tuple constructor.\n    xs => ys => {\n        const n = Math.min(length(xs), length(ys));\n        return Infinity > n ? (\n            (([as, bs]) => Array.from({\n                length: n\n            }, (_, i) => f(as[i])(\n                bs[i]\n            )))([xs, ys].map(\n                compose(take(n), list)\n            ))\n        ) : zipWithGen(f)(xs)(ys);\n    };",
  "zipWith3": "// zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]\nconst zipWith3 = f =>\n    xs => ys => zs => Array.from({\n        length: Math.min(\n            ...[xs, ys, zs].map(x => x.length)\n        )\n    }, (_, i) => f(xs[i])(ys[i])(zs[i]));",
  "zipWith4": "// zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]\nconst zipWith4 = f =>\n    ws => xs => ys => zs => Array.from({\n        length: Math.min(\n            ...[ws, xs, ys, zs].map(x => x.length)\n        )\n    }, (_, i) => f(ws[i])(xs[i])(ys[i])(zs[i]));",
  "zipWithGen": "// zipWithGen :: (a -> b -> c) -> \n// Gen [a] -> Gen [b] -> Gen [c]\nconst zipWithGen = f => ga => gb => {\n    function* go(ma, mb) {\n        let\n            a = ma,\n            b = mb;\n        while (!a.Nothing && !b.Nothing) {\n            let\n                ta = a.Just,\n                tb = b.Just;\n            yield(f(fst(ta))(fst(tb)));\n            a = uncons(snd(ta));\n            b = uncons(snd(tb));\n        }\n    }\n    return go(uncons(ga), uncons(gb));\n};",
  "zipWithList": "// zipWithList :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst zipWithList = f =>\n    // A list constructed by zipping with a\n    // custom function, rather than with the\n    // default tuple constructor.\n    xs => ys => ((xs_, ys_) => {\n        const lng = Math.min(length(xs_), length(ys_));\n        return take(lng)(xs_).map(\n            (x, i) => f(x)(ys_[i])\n        );\n    })([...xs], [...ys]);",
  "zipWithLong": "// zipWithLong :: (a -> a -> a) -> [a] -> [a] -> [a]\nconst zipWithLong = f => {\n    // A list with the length of the *longer* of \n    // xs and ys, defined by zipping with a\n    // custom function, rather than with the\n    // default tuple constructor.\n    // Any unpaired values, where list lengths differ,\n    // are simply appended.\n    const go = xs =>\n        ys => 0 < xs.length ? (\n            0 < ys.length ? (\n                [f(xs[0])(ys[0])].concat(\n                    go(xs.slice(1))(ys.slice(1))\n                )\n            ) : xs\n        ) : ys;\n    return go;\n};",
  "zipWithM": "// zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]\nconst zipWithM = f => \n    xs => ys =>\n        sequenceA(\n            zipWith(f)(\n                [...xs]\n            )([...ys])\n        );",
  "zipWithN": "// zipWithN :: (a -> b -> ... -> c) -> ([a], [b] ...) -> [c]\nfunction zipWithN() {\n    const\n        args = Array.from(arguments),\n        rows = args.slice(1).map(list),\n        f = compose(uncurryN(args[0]), TupleN),\n        n = Math.min(...rows.map(x => x.length));\n    return 0 < n ? (\n        take(n))(rows[0]).map(\n        (x, i) => f(rows.flatMap(\n            x => x[i]\n        ))\n    ) : [];\n}",
  "zipWith_": "// zipWith_ :: (a -> a -> b) -> [a] -> [b]\nconst zipWith_ = f => {\n    // A list with the length of the shorter of \n    // xs and ys, defined by zipping with a\n    // custom function, rather than with the\n    // default tuple constructor.\n    const go = xs =>\n        ys => 0 < xs.length ? (\n            0 < ys.length ? (\n                [f(xs[0])(ys[0])].concat(\n                    go(xs.slice(1))(ys.slice(1))\n                )\n            ) : []\n        ) : [];\n    return go;\n};"
}
