{
  "title": "zipWith",
  "cells": [
    {
      "type": "code",
      "language": "javascript",
      "data": "// zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst zipWith = f =>\n    // Use of `take` and `length` here allows zipping with non-finite lists\n    // i.e. generators like cycle, repeat, iterate.\n    xs => ys => {\n        const n = Math.min(length(xs), length(ys));\n        return Infinity > n ? (\n            (([as, bs]) => Array.from({\n                length: n\n            }, (_, i) => f(as[i])(\n                bs[i]\n            )))([xs, ys].map(\n                compose(take(n), list)\n            ))\n        ) : zipWithGen(f)(xs)(ys);\n    };"
    }
  ]
}