{
  "title": "drawTree2",
  "cells": [
    {
      "type": "code",
      "language": "javascript",
      "data": "// drawTree2 :: Bool -> Bool -> Tree String -> String\nconst drawTree2 = blnCompact => blnPruned => tree => {\n    // Tree design and algorithm inspired by the Haskell snippet at:\n    // https://doisinkidney.com/snippets/drawing-trees.html\n    const\n        // Lefts, Middle, Rights\n        lmrFromStrings = xs => {\n            const [ls, rs] = Array.from(splitAt(\n                Math.floor(xs.length / 2)\n            )(xs));\n            return TupleN(ls, rs[0], rs.slice(1));\n        },\n        stringsFromLMR = lmr =>\n        Array.from(lmr).reduce((a, x) => a.concat(x), []),\n        fghOverLMR = (f, g, h) => lmr => {\n            const [ls, m, rs] = Array.from(lmr);\n            return TupleN(ls.map(f), g(m), rs.map(h));\n        };\n    const lmrBuild = (f, w) => wsTree => {\n        const\n            leftPad = n => s => ' '.repeat(n) + s,\n            xs = wsTree.nest,\n            lng = xs.length,\n            [nChars, x] = Array.from(wsTree.root);\n\n        // LEAF NODE --------------------------------------\n        return 0 === lng ? (\n            TupleN([], '─'.repeat(w - nChars) + x, [])\n\n            // NODE WITH SINGLE CHILD -------------------------\n        ) : 1 === lng ? (() => {\n            const indented = leftPad(1 + w);\n            return fghOverLMR(\n                indented,\n                z => '─'.repeat(w - nChars) + x + '─' + z,\n                indented\n            )(f(xs[0]));\n\n            // NODE WITH CHILDREN -----------------------------\n        })() : (() => {\n            const\n                cFix = x => xs => x + xs,\n                treeFix = (l, m, r) => compose(\n                    stringsFromLMR,\n                    fghOverLMR(cFix(l), cFix(m), cFix(r))\n                ),\n                _x = '─'.repeat(w - nChars) + x,\n                indented = leftPad(w),\n                lmrs = xs.map(f);\n            return fghOverLMR(\n                indented,\n                s => _x + ({\n                    '┌': '┬',\n                    '├': '┼',\n                    '│': '┤',\n                    '└': '┴'\n                })[s[0]] + s.slice(1),\n                indented\n            )(lmrFromStrings(\n                intercalate(\n                    blnCompact ? [] : ['│']\n                )(\n                    [treeFix(' ', '┌', '│')(lmrs[0])]\n                    .concat(init(lmrs.slice(1)).map(\n                        treeFix('│', '├', '│')\n                    ))\n                    .concat([treeFix('│', '└', ' ')(\n                        lmrs[lmrs.length - 1]\n                    )])\n                )\n            ));\n        })();\n    };\n    const\n        measuredTree = fmapTree(\n            v => {\n                const s = ' ' + v + ' ';\n                return Tuple(s.length)(s);\n            })(tree),\n        levelWidths = levels(measuredTree)\n        .reduce(\n            (a, level) => a.concat(maximum(level.map(fst))),\n            []\n        ),\n        treeLines = stringsFromLMR(\n            levelWidths.reduceRight(\n                lmrBuild, x => x\n            )(measuredTree)\n        );\n    return unlines(\n        blnPruned ? (\n            treeLines.filter(\n                s => s.split('')\n                .some(c => !' │'.includes(c))\n            )\n        ) : treeLines\n    );\n};"
    }
  ]
}