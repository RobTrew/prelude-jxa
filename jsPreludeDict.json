{
  "Just": "// Just :: a -> Maybe a\nconst Just = x => ({\n    type: 'Maybe',\n    Nothing: false,\n    Just: x\n});",
  "Left": "// Left :: a -> Either a b\nconst Left = x => ({\n    type: 'Either',\n    Left: x\n});",
  "Node": "// Node :: a -> [Tree a] -> Tree a\nconst Node = (v, xs) => ({\n    type: 'Node',\n    root: v, // any type of value (consistent across tree)\n    nest: xs || []\n});",
  "Nothing": "// Nothing :: Maybe a\nconst Nothing = () => ({\n    type: 'Maybe',\n    Nothing: true,\n});",
  "Right": "// Right :: b -> Either a b\nconst Right = x => ({\n    type: 'Either',\n    Right: x\n});",
  "Tuple": "// Tuple (,) :: a -> b -> (a, b)\nconst Tuple = (a, b) => ({\n  type: 'Tuple',\n  '0': a,\n  '1': b,\n  length: 2\n});",
  "TupleN": "// TupleN :: a -> b ...  -> (a, b ... )\nfunction TupleN() {\n    const\n        args = Array.from(arguments),\n        lng = args.length;\n    return lng > 1 ? Object.assign(\n        args.reduce((a, x, i) => Object.assign(a, {\n            [i]: x\n        }), {\n            type: 'Tuple' + (2 < lng ? lng.toString() : ''),\n            length: lng\n        })\n    ) : args[0];\n};",
  "abs": "// abs :: Num -> Num\nconst abs = Math.abs;",
  "all": "// Determines whether all elements of the structure \n// satisfy the predicate.\n\n// all :: (a -> Bool) -> [a] -> Bool\nconst all = (p, xs) => xs.every(p);",
  "and": "// | The conjunction of a container of Bools. \n// True unless any contained value is false.\n\n// and :: [Bool] -> Bool\nconst and = xs =>\n    xs.every(Boolean);",
  "any": "// | True if any contained element satisfies the predicate.\n\n// any :: (a -> Bool) -> [a] -> Bool\nconst any = (p, xs) => xs.some(p);",
  "ap": "// Applies wrapped functions to wrapped values, \n// for example applying a list of functions to a list of values\n// or applying Just(f) to Just(x), Right(f) to Right(x), etc\n\n// ap (<*>) :: Monad m => m (a -> b) -> m a -> m b\nconst ap = (mf, mx) => {\n    const t = mx.type;\n    return (\n        undefined !== t ? (\n            'Either' === t ? (\n                apLR\n            ) : 'Maybe' === t ? (\n                apMay\n            ) : 'Node' === t ? (\n                apTree\n            ) : 'Tuple' === t ? (\n                apTuple\n            ) : apList\n        ) : apList\n    )(mf, mx);\n};",
  "apLR": "// apLR (<*>) :: Either e (a -> b) -> Either e a -> Either e b\nconst apLR = (flr, lr) => {\n    const pf = (undefined === flr.Left);\n    return pf && (undefined === lr.Left) ? (\n        Right(flr.Right(lr.Right))\n    ) : (pf ? lr : flr);\n};",
  "apList": "// e.g. [(*2),(/2), sqrt] <*> [1,2,3]\n// -->  ap([dbl, hlf, root], [1, 2, 3])\n// -->  [2,4,6,0.5,1,1.5,1,1.4142135623730951,1.7320508075688772]\n\n// Each member of a list of functions applied to each\n// of a list of arguments, deriving a list of new values.\n\n// apList (<*>) :: [(a -> b)] -> [a] -> [b]\nconst apList = (fs, xs) => //\n    fs.reduce((a, f) => a.concat(\n        xs.reduce((a, x) => a.concat([f(x)]), [])\n    ), []);",
  "apMay": "// Maybe f applied to Maybe x, deriving a Maybe y\n\n// apMay (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\nconst apMay = (mf, mx) =>\n    mf.Nothing || mx.Nothing ? (\n        Nothing()\n    ) : Just(mf.Just(mx.Just));",
  "apTree": "// apTree (<*>) :: Tree (a -> b) -> Tree a -> Tree b\nconst apTree = (tf, tx) => {\n    const go = t =>\n        Node(\n            t.root(tx.root),\n            tx.nest.map(\n                curry(fmapTree)(t.root)\n            ).concat(t.nest.map(go))\n        );\n    return go(tf);\n};",
  "apTuple": "// apTuple (<*>) :: Monoid m => (m, (a -> b)) -> (m, a) -> (m, b)\nconst apTuple = (tf, tx) =>\n    Tuple(\n        mappend(tf[0], tx[0]),\n        tf[1](tx[1])\n    );",
  "append": "// append (++) :: [a] -> [a] -> [a]\n// append (++) :: String -> String -> String\nconst append = (xs, ys) => xs.concat(ys);",
  "appendFile": "// appendFile :: FilePath -> String -> IO Bool\nconst appendFile = (strPath, txt) => {\n    const\n        oFullPath = ObjC.wrap(strPath)\n        .stringByStandardizingPath,\n        ref = Ref();\n  \n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            oFullPath\n            .stringByStandardizingPath, ref\n        ) ? (\n            0 === ref[0] ? (() => {\n                const // Not a directory\n                    oData = ObjC.wrap(txt)\n                    .dataUsingEncoding($.NSUTF8StringEncoding),\n                    h = $.NSFileHandle.fileHandleForWritingAtPath(\n                        oFullPath\n                    );\n                return (\n                    h.seekToEndOfFile, // Effect, and\n                    h.writeData(oData),\n                    h.closeFile,\n                    true // value.\n                );\n            })() : false // Text appending to directory is undefined\n        ) : doesDirectoryExist(takeDirectory(ObjC.unwrap(strPath))) ? (\n            writeFile(oFullPath, txt), // Effect, and\n            true // value.\n        ) : false;\n};",
  "appendFileMay": "// appendFileMay :: FilePath -> String -> Maybe IO FilePath\nconst appendFileMay = (strPath, txt) => {\n    const\n        oFullPath = ObjC.wrap(strPath)\n        .stringByStandardizingPath,\n        strFullPath = ObjC.unwrap(oFullPath),\n        ref = Ref();\n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            oFullPath\n            .stringByStandardizingPath, ref\n        ) ? (\n             0 === ref[0] ? (() => {\n                const // Not a directory\n                    oData = ObjC.wrap(txt)\n                    .dataUsingEncoding($.NSUTF8StringEncoding),\n                    h = $.NSFileHandle\n                    .fileHandleForWritingAtPath(oFullPath);\n                return (\n                    h.seekToEndOfFile, // Effect, and\n                    h.writeData(oData),\n                    h.closeFile, {\n                        Nothing: false,\n                        Just: strFullPath\n                    } // value.\n                );\n            })() : Nothing()\n            // Text appending to directory is undefined\n        ) : doesDirectoryExist(takeDirectory(strFullPath)) ? (\n            writeFile(oFullPath, txt), // Effect, and\n            Just(strFullPath) // value\n        ) : Nothing();\n};",
  "appendGen": "// appendGen (++) :: Gen [a] -> Gen [a] -> Gen [a]\nfunction* appendGen(xs, ys) {\n    for (let vs of [xs, ys]) {\n        let nxt = vs.next()\n        while (!nxt.done) {\n            yield nxt.value\n            nxt = vs.next()\n        }\n    }\n};",
  "apply": "// apply ($) :: (a -> b) -> a -> b\nconst apply = (f, x) => f(x);",
  "approxRatio": "// Epsilon -> Real -> Ratio\n\n// approxRatio :: Real -> Real -> Ratio\nconst approxRatio = eps => n => {\n  const\n    gcde = (e, x, y) => {\n      const _gcd = (a, b) => (b < e ? a : _gcd(b, a % b));\n      return _gcd(abs(x), abs(y));\n    },\n    c = gcde(Boolean(eps) ? eps : (1 / 10000), 1, abs(n)),\n    r = ratio(quot(abs(n), c), quot(1, c));\n  return {\n    type: 'Ratio',\n    n: r.n * signum(n),\n    d: r.d\n  };\n};",
  "argvLength": "// argvLength :: Function -> Int\nconst argvLength = f => f.length;",
  "assocs": "// assocs :: Map k a -> [(k, a)]\nconst assocs = m =>\n    Object.entries(m).map(\n        kv => Tuple(...kv)\n    );",
  "bind": "// bind (>>=) :: Monad m => m a -> (a -> m b) -> m b\nconst bind = (m, mf) =>\n    (Array.isArray(m) ? (\n        bindList\n    ) : (() => {\n        const t = m.type;\n        return 'Either' === t ? (\n            bindLR\n        ) : 'Maybe' === t ? (\n            bindMay\n        ) : 'Tuple' === t ? (\n            bindTuple\n        ) : ('function' === typeof m) ? (\n            bindFn\n        ) : undefined;\n    })()(m, mf));",
  "bindFn": "// bindFn :: (a -> b) -> (b -> c) -> a -> c\nconst bindFn = (m, mf) =>\n    x => mf(y => m(x, y))(x);",
  "bindLR": "// bindLR (>>=) :: Either a -> (a -> Either b) -> Either b\nconst bindLR = (m, mf) =>\n    undefined !== m.Left ? (\n        m\n    ) : mf(m.Right);",
  "bindList": "// bindList (>>=) :: [a] -> (a -> [b]) -> [b]\nconst bindList = (xs, mf) => \n  [].concat.apply([], xs.map(mf));",
  "bindMay": "// bindMay (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\nconst bindMay = (mb, mf) =>\n    mb.Nothing ? mb : mf(mb.Just);",
  "bindTuple": "// bindTuple (>>=) :: Monoid a => (a, a) -> (a -> (a, b)) -> (a, b)\nconst bindTuple = (tpl, f) => {\n    const t2 = f(tpl[1]);\n    return Tuple(\n        mappend(tpl[0], t2[0]),\n        t2[1]\n    );\n};",
  "bool": "// bool :: a -> a -> Bool -> a\nconst bool = f => t => p =>\n    p ? t : f;",
  "break": "// break :: (a -> Bool) -> [a] -> ([a], [a])\nconst break_ = (p, xs) => {\n  for (var i = 0, lng = xs.length; (i < lng) && !p(xs[i]); i++) {};\n  return Tuple(xs.slice(0, i), xs.slice(i));\n};",
  "breakOn": "// Needle -> Haystack -> (prefix before match, match + rest)\n\n// breakOn :: String -> String -> (String, String)\nconst breakOn = (pat, src) =>\n    0 < pat.length ? (() => {\n        const xs = src.split(pat);\n        return 1 < xs.length ? Tuple(\n            xs[0], src.slice(xs[0].length)\n        ) : Tuple(src, '');\n    })() : undefined;",
  "breakOnAll": "// breakOnAll \"::\" \"\"\n// ==> []\n// breakOnAll \"/\" \"a/b/c/\"\n// ==> [(\"a\", \"/b/c/\"), (\"a/b\", \"/c/\"), (\"a/b/c\", \"/\")]\n\n// breakOnAll :: String -> String -> [(String, String)]\nconst breakOnAll = (pat, src) =>\n    '' !== pat ? (\n        src.split(pat)\n        .reduce((a, x, i, xs) =>\n            0 < i ? (\n                a.concat([\n                    Tuple(xs.slice(0, i)\n                        .join(pat), pat + xs.slice(i)\n                        .join(pat)\n                    )\n                ])\n            ) : a, [])\n    ) : undefined;",
  "breakOnMay": "// Needle -> Haystack -> maybe (prefix before match, match + rest)\n\n// breakOnMay :: String -> String -> Maybe (String, String)\nconst breakOnMay = (pat, src) =>\n    Boolean(pat) ? (() => {\n        const xs = src.split(pat);\n        return Just(0 < xs.length ? Tuple(\n            xs[0], src.slice(xs[0].length)\n        ) : Tuple(src, ''));\n    })() : Nothing();",
  "cartesianProduct": "// cartesianProduct :: [a] -> [b] -> [(a, b)]\nconst cartesianProduct = (xs, ys) =>\n    apList(xs.map(x => y => Tuple(x, y)), ys);",
  "caseOf": "// List of (Predicate, value) tuples -> Default value \n//                        -> Value to test -> Output value\n\n// caseOf :: [(a -> Bool, b)] -> b -> a ->  b\nconst caseOf = (pvs, otherwise, x) => {\n    const mb = pvs.reduce((a, pv) =>\n        a.Nothing ? (\n            pv[0](x) ? Just(pv[1]) : a\n        ) : a, Nothing());\n    return mb.Nothing ? otherwise : mb.Just;\n};",
  "catMaybes": "// catMaybes :: [Maybe a] -> [a]\nconst catMaybes = mbs =>\n    concatMap(m => m.Nothing ? [] : [m.Just], mbs);",
  "ceiling": "// The least integer not less than x\n\n// ceiling :: Num -> Int\nconst ceiling = x => {\n    const\n      nr = properFraction(x),\n      n = nr[0]\n    return 0 < nr[1] ? 1 + n : n;\n};",
  "center": "// Size of space -> filler Char -> String -> Centered String\n\n// center :: Int -> Char -> String -> String\nconst center = (n, c, s) => {\n  const\n    qr = quotRem(n - s.length, 2),\n    q = qr[0];\n  return replicateString(q, c) +\n    s + replicateString(q + qr[1], c);\n};",
  "chars": "// chars :: String -> [Char]\nconst chars = s => s.split('');",
  "chr": "// chr :: Int -> Char\nconst chr = String.fromCodePoint;",
  "chunksOf": "// chunksOf :: Int -> [a] -> [[a]]\nconst chunksOf = (n, xs) =>\n    enumFromThenTo(0, n - 1, xs.length - 1)\n    .reduce(\n        (a, i) => a.concat([xs.slice(i, i + n)]),\n        []\n    );",
  "compare": "// compare :: a -> a -> Ordering\nconst compare = (a, b) =>\n    a < b ? -1 : (a > b ? 1 : 0);",
  "comparing": "// comparing :: (a -> b) -> (a -> a -> Ordering)\nconst comparing = f =>\n    (x, y) => {\n        const\n            a = f(x),\n            b = f(y);\n        return a < b ? -1 : (a > b ? 1 : 0);\n    };",
  "compose": "// compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\nconst compose = (f, g) => x => f(g(x));",
  "composeList": "// composeList :: [(a -> a)] -> (a -> a)\nconst composeList = fs =>\n    x => fs.reduceRight((a, f) => f(a), x, fs);",
  "composeListR": "// composeListR :: [(a -> a)] -> (a -> a)\nconst composeListR = fs =>\n    x => fs.reduce((a, f) => f(a), x);",
  "composeR": "// composeR (>>>) :: (a -> b) -> (b -> c) -> a -> c\nconst composeR = (f, g) => x => f(g(x));",
  "concat": "// concat :: [[a]] -> [a]\n// concat :: [String] -> String\nconst concat = xs =>\n    0 < xs.length ? (() => {\n        const unit = 'string' !== typeof xs[0] ? (\n            []\n        ) : '';\n        return unit.concat.apply(unit, xs);\n    })() : [];",
  "concatMap": "// concatMap :: (a -> [b]) -> [a] -> [b]\nconst concatMap = (f, xs) =>\n    xs.reduce((a, x) => a.concat(f(x)), []);\n    \n// Briefer but slower:\n// concatMap :: (a -> [b]) -> [a] -> [b]\n// const concatMap = (f, xs) =>\n//     [].concat(...xs.map(f))",
  "cons": "// cons :: a -> [a] -> [a]\nconst cons = (x, xs) =>\n    Array.isArray(xs) ? (\n        [x].concat(xs)\n    ) : 'GeneratorFunction' !== xs.constructor.constructor.name ? (\n        x + xs\n    ) : ( // Existing generator wrapped with one additional element\n        function* () {\n            yield x;\n            let nxt = xs.next()\n            while (!nxt.done) {\n                yield nxt.value;\n                nxt = xs.next();\n            }\n        }\n    )();",
  "const": "// const :: a -> b -> a\nconst const_ = k => _ => k;",
  "createDirectoryIfMissingLR": "// createDirectoryIfMissingLR :: Bool -> FilePath -> Either String String\nconst createDirectoryIfMissingLR = (blnParents, fp) =>\n    doesPathExist(fp) ? (\n        Right(`Found: '${fp}'`)\n    ) : (() => {\n        const\n            e = $(),\n            blnOK = $.NSFileManager.defaultManager[\n                'createDirectoryAtPath' +\n                'WithIntermediateDirectoriesAttributesError'\n            ]($(fp)\n                .stringByStandardizingPath,\n                blnParents, undefined, e\n            );\n        return blnOK ? (\n            Right(fp)\n        ) : Left(e.localizedDescription);\n    })();",
  "curry": "// Flexibly handles two or more arguments, applying\n// the function directly if the argument array\n// is long enough for complete saturation,\n// or recursing with a concatenation of any existing and\n// newly supplied arguments, if gaps remain.\n\n// curry :: ((a, b) -> c) -> a -> b -> c\nconst curry = (f, ...args) => {\n    const\n        n = f.length,\n        go = xs => n <= xs.length ? (\n            f(...xs)\n        ) : function() {\n            return go(xs.concat(Array.from(arguments)));\n        };\n    return go(args);\n};",
  "curry2": "// Simpler 2 argument only version of curry\n\n// curry2 :: ((a, b) -> c) -> a -> b -> c\nconst curry2 = f => a => b => f(a, b);",
  "curry3": "// curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d\nconst curry3 = f =>\n    a => b => c => f(a, b, c);",
  "cycle": "// cycle :: [a] -> Generator [a]\nfunction* cycle(xs) {\n    const lng = xs.length;\n    let i = 0;\n    while (true) {\n        yield(xs[i])\n        i = (1 + i) % lng;\n    }\n}",
  "degrees": "// degrees :: Float x => Radians x -> Degrees x\nconst degrees = r =>\n    (180 / Math.PI) * r;",
  "delete": "// xs with first instance of x (if any) removed\n\n// delete :: Eq a => a -> [a] -> [a]\nconst delete_ = (x, xs) => {\n    const go = xs => {\n        return 0 < xs.length ? (\n            (x === xs[0]) ? (\n                xs.slice(1)\n            ) : [xs[0]].concat(go(xs.slice(1)))\n        ) : [];\n    }\n    return go(xs);\n};",
  "deleteAt": "// deleteAt :: Int -> [a] -> [a]\nconst deleteAt = (i, xs) =>\n    i <= xs.length ? (() => {\n        const lr = splitAt(i, xs);\n        return lr[0].concat(lr[1].slice(1));\n    })() : xs;",
  "deleteBy": "// deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]\nconst deleteBy = (fEq, x, xs) => {\n    const go = xs => 0 < xs.length ? (\n        fEq(x, xs[0]) ? (\n            xs.slice(1)\n        ) : [xs[0]].concat(go(xs.slice(1)))\n    ) : [];\n    return go(xs);\n};",
  "deleteFirst": "// deleteFirst :: a -> [a] -> [a]\nconst deleteFirst = (x, xs) => {\n    const go = xs => 0 < xs.length ? (\n        x === xs[0] ? (\n            xs.slice(1)\n        ) : [xs[0]].concat(go(xs.slice(1)))\n    ) : [];\n    return go(xs);\n};",
  "deleteFirstsBy": "// deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst deleteFirstsBy = (fnEq, xs, ys) =>\n    ys.reduce((x, y) => deleteBy(fnEq, y, x), xs);",
  "deleteMap": "// deleteMap :: k -> Dict -> Dict\nconst deleteMap = (k, dct) =>\n    (delete dct[k], dct);",
  "difference": "// difference :: Eq a => [a] -> [a] -> [a]\nconst difference = (xs, ys) =>\n    xs.filter(x => -1 === ys.indexOf(x));",
  "digitToInt": "// digitToInt :: Char -> Int\nconst digitToInt = c => {\n    const\n        ord = x => x.codePointAt(0),\n        oc = ord(c);\n    return 48 > oc || 102 < oc ? (\n        undefined\n    ) : (() => {\n        const\n            dec = oc - ord('0'),\n            hexu = oc - ord('A'),\n            hexl = oc - ord('a');\n        return 9 >= dec ? (\n            dec\n        ) : 0 <= hexu && 5 >= hexu  ? (\n            10 + hexu\n        ) : 0 <= hexl && 5 >= hexl ? (\n            10 + hexl\n        ) : undefined;\n    })();\n};",
  "div": "// div :: Int -> Int -> Int\nconst div = (x, y) => Math.floor(x / y);",
  "doesDirectoryExist": "// doesDirectoryExist :: FilePath -> IO Bool\nconst doesDirectoryExist = strPath => {\n    const ref = Ref();\n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            $(strPath)\n            .stringByStandardizingPath, ref\n        ) && ref[0];\n};",
  "doesFileExist": "// doesFileExist :: FilePath -> IO Bool\nconst doesFileExist = strPath => {\n    const ref = Ref();\n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            $(strPath)\n            .stringByStandardizingPath, ref\n        ) && 1 !== ref[0];\n};",
  "doesPathExist": "// doesPathExist :: FilePath -> IO Bool\nconst doesPathExist = strPath =>\n\t$.NSFileManager.defaultManager\n\t.fileExistsAtPath(\n\t\t$(strPath).stringByStandardizingPath\n\t);",
  "draw": "// draw :: Tree String -> [String]\nconst draw = node => {\n    // shift :: String -> String -> [String] -> [String]\n    const shift = (first, other, xs) =>\n        zipWith(\n            append,\n            cons(first, replicate(xs.length - 1, other)),\n            xs\n        );\n    // drawSubTrees :: [Tree String] -> [String]\n    const drawSubTrees = xs => {\n        const lng = xs.length;\n        return 0 < lng ? (\n            1 < lng ? append(\n                cons(\n                    '│',\n                    shift('├─ ', '│  ', draw(xs[0]))\n                ),\n                drawSubTrees(xs.slice(1))\n            ) : cons('│', shift('└─ ', '   ', draw(xs[0])))\n        ) : [];\n    };\n    return append(\n        lines(node.root.toString()),\n        drawSubTrees(node.nest)\n    );\n};",
  "drawForest": "// drawForest :: [Tree String] -> String\nconst drawForest = trees =>\n    trees.map(drawTree).join('\\n');",
  "drawTree": "// drawTree :: Tree String -> String\nconst drawTree = tree =>\n    unlines(draw(tree));",
  "drop": "// drop :: Int -> [a] -> [a]\n// drop :: Int -> Generator [a] -> Generator [a]\n// drop :: Int -> String -> String\nconst drop = (n, xs) =>\n    Infinity > length(xs) ? (\n        xs.slice(n)\n    ) : (take(n, xs), xs);",
  "dropAround": "// dropAround :: (a -> Bool) -> [a] -> [a]\n// dropAround :: (Char -> Bool) -> String -> String\nconst dropAround = (p, xs) => dropWhile(p, dropWhileEnd(p, xs));",
  "dropFileName": "// dropFileName :: FilePath -> FilePath\nconst dropFileName = strPath =>\n    '' !== strPath ? (() => {\n        const\n          xs = (strPath.split('/'))\n          .slice(0, -1);\n        return xs.length > 0 ? (\n            xs.join('/') + '/'\n        ) : './';\n    })() : './';",
  "dropLength": "// dropLength :: [a] -> [b] -> [b]\nconst dropLength = (xs, ys) => {\n    const go = (x, y) =>\n        0 < x.length ? (\n            0 < y.length ? (\n                go(x.slice(1), y.slice(1))\n            ) : []\n        ) : y;\n    return go(xs, ys);\n};",
  "dropLengthMaybe": "// dropLengthMaybe :: [a] -> [b] -> Maybe [b]\nconst dropLengthMaybe = (xs, ys) => {\n    const go = (x, y) =>\n        0 < x.length ? (\n            0 < y.length ? (\n                go(x.slice(1), y.slice(1))\n            ) : Nothing()\n        ) : Just(y);\n    return go(xs, ys);\n};",
  "dropWhile": "// dropWhile :: (a -> Bool) -> [a] -> [a]\n// dropWhile :: (Char -> Bool) -> String -> String\nconst dropWhile = (p, xs) => {\n    const lng = xs.length;\n    return 0 < lng ? xs.slice(\n        until(\n            i => i === lng || !p(xs[i]),\n            i => 1 + i,\n            0\n        )\n    ) : [];\n};",
  "dropWhileEnd": "// dropWhileEnd :: (a -> Bool) -> [a] -> [a]\n// dropWhileEnd :: (Char -> Bool) -> String -> String\nconst dropWhileEnd = (p, xs) => {\n    let i = xs.length;\n    while (i-- && p(xs[i])) {}\n    return xs.slice(0, i + 1);\n};",
  "dropWhileGen": "// dropWhileGen :: (a -> Bool) -> Gen [a] -> [a]\nconst dropWhileGen = (p, xs) => {\n    let\n        nxt = xs.next(),\n        v = nxt.value;\n    while (!nxt.done && p(v)) {\n        nxt = xs.next();\n        v = nxt.value;\n    }\n    return cons(v, xs);\n};",
  "either": "// either :: (a -> c) -> (b -> c) -> Either a b -> c\nconst either = (fl, fr, e) =>\n    'Either' === e.type ? (\n        undefined !== e.Left ? (\n            fl(e.Left)\n        ) : fr(e.Right)\n    ) : undefined;",
  "elem": "// elem :: Eq a => a -> [a] -> Bool\nconst elem = (x, xs) => xs.includes(x);",
  "elemAtMay": "// If x is a dictionary, then the Int is read as an \n// index into the lexically sorted keys of the Dict, \n// returning a Maybe (Key, Value) pair.\n// If x is a list, then returns a Maybe a.\n// (In either case, returns Nothing for an Int out of range)\n\n// elemAtMay :: Int -> Dict -> Maybe (String, a)\n// elemAtMay :: Int -> [a] -> Maybe a\nconst elemAtMay = (i, x) => {\n    const\n        bln = Array.isArray(x),\n        k = bln ? i : Object.keys(x)\n        .sort()[i],\n        v = x[k];\n    return undefined !== v ? (\n        Just(bln ? v : Tuple(k, v))\n    ) : Nothing();\n};",
  "elemIndex": "// elemIndex :: Eq a => a -> [a] -> Maybe Int\nconst elemIndex = (x, xs) => {\n    const i = xs.indexOf(x);\n    return -1 === i ? (\n        Nothing()\n    ) : Just(i);\n};",
  "elemIndices": "// elemIndices :: Eq a => a -> [a] -> [Int]\nconst elemIndices = (x, xs) =>\n    concatMap((y, i) => y === x ? (\n        [i]\n    ) : [], xs);",
  "elems": "// elems :: Map k a -> [a]\n// elems :: Set a -> [a]\nconst elems = x =>\n    'Set' !== x.constructor.name ? (\n        Object.values(x)\n    ) : Array.from(x.values());",
  "enumFrom": "// enumFrom :: Enum a => a -> [a]\nfunction* enumFrom(x) {\n    let v = x;\n    while (true) {\n        yield v;\n        v = succ(v);\n    }\n}",
  "enumFromThenTo": "// enumFromThenTo :: Int -> Int -> Int -> [Int]\nconst enumFromThenTo = (x1, x2, y) => {\n    const d = x2 - x1;\n    return Array.from({\n        length: Math.floor(y - x2) / d + 2\n    }, (_, i) => x1 + (d * i));\n};",
  "enumFromThenToChar": "// enumFromThenToChar :: Char -> Char -> Char -> [Char]\nconst enumFromThenToChar = (x1, x2, y) => {\n    const [i1, i2, iY] = Array.from([x1, x2, y])\n        .map(x => x.charCodeAt(0)),\n        d = i2 - i1;\n    return Array.from({\n        length: (Math.floor(iY - i2) / d) + 2\n    }, (_, i) => String.fromCodePoint(i1 + (d * i)));\n};",
  "enumFromTo": "// enumFromTo :: Enum a => a -> a -> [a]\nconst enumFromTo = (m, n) => {\n    const\n        [x, y] = [m, n].map(fromEnum),\n        b = x + ('number' !== typeof m ? 0 : m - x);\n    return Array.from({\n        length: 1 + (y - x)\n    }, (_, i) => toEnum(m)(b + i));\n};",
  "enumFromToChar": "// enumFromToChar :: Char -> Char -> [Char]\nconst enumFromToChar = (m, n) => {\n    const [intM, intN] = [m, n].map(x => x.charCodeAt(0));\n    return Array.from({\n        length: Math.floor(intN - intM) + 1\n    }, (_, i) => String.fromCodePoint(intM + i));\n};",
  "eq": "// eq (==) :: Eq a => a -> a -> Bool\nconst eq = (a, b) => {\n    const t = typeof a;\n    return t !== typeof b ? (\n        false\n    ) : 'object' !== t ? (\n        'function' !== t ? (\n            a === b\n        ) : a.toString() === b.toString()\n    ) : (() => {\n        const aks = Object.keys(a);\n        return aks.length !== Object.keys(b).length ? (\n            false\n        ) : aks.every(k => eq(a[k], b[k]));\n    })();\n};",
  "evalJSLR": "// evalJSLR :: String -> Either String a\nconst evalJSLR = s => {\n    try {\n        return Right(eval('(' + s + ')'))\n    } catch (e) {\n        return Left(e.message);\n    };\n};",
  "evalJSMay": "// evalJSMay :: String -> Maybe a\nconst evalJSMay = s => {\n    try {\n        return Just(eval('(' + s + ')'))\n    } catch (e) {\n        return Nothing();\n    };\n};",
  "even": "// even :: Int -> Bool\nconst even = n => 0 === n % 2;",
  "exp": "// exp :: Float -> Float\nconst exp = Math.exp;",
  "fanArrow": "// Compose a function from a simple value to a tuple of\n// the separate outputs of two different functions\n\n// fanArrow (&&&) :: (a -> b) -> (a -> c) -> (a -> (b, c))\nconst fanArrow = (f, g) => x => Tuple(f(x), g(x));",
  "filePath": "// filePath :: String -> FilePath\nconst filePath = s =>\n    ObjC.unwrap(ObjC.wrap(s)\n        .stringByStandardizingPath);",
  "filePathTree": "// filePathTree :: filePath -> [Tree String] -> Tree FilePath\nconst filePathTree = (fpAnchor, trees) => {\n    const go = fp => tree => {\n        const path = `${fp}/${tree.root}`;\n        return Node(\n            path,\n            tree.nest.map(go(path))\n        );\n    };\n    return Node(fpAnchor, trees.map(go(fpAnchor)));\n};",
  "fileSize": "// fileSize :: FilePath -> Either String Int\nconst fileSize = fp =>\n  bindLR(\n    fileStatus(fp),\n    dct => Right(ObjC.unwrap(dct.NSFileSize))\n  );",
  "fileStatus": "// fileStatus :: FilePath -> Either String Dict\nconst fileStatus = fp => {\n  const\n    error = $(),\n    dct = $.NSFileManager.defaultManager\n    .attributesOfItemAtPathError(fp, error).js;\n  return undefined !== dct ? (\n    Right(dct)\n  ) : Left(ObjC.unwrap(error.localizedDescription));\n};",
  "fileUTI": "// fileUTI :: FilePath -> String\nconst fileUTI = fp => {\n    const\n        e = $(),\n        uti = ObjC.unwrap(\n            $.NSWorkspace.sharedWorkspace\n            .typeOfFileError(fp, e)\n        );\n    return undefined !== uti ? (\n        uti\n    ) : ObjC.unwrap(e.localizedDescription);\n};",
  "filter": "// filter :: (a -> Bool) -> [a] -> [a]\nconst filter = (f, xs) => xs.filter(f);",
  "find": "// find :: (a -> Bool) -> [a] -> Maybe a\nconst find = (p, xs) => {\n    for (let i = 0, lng = xs.length; i < lng; i++) {\n        if (p(xs[i])) return Just(xs[i]);\n    }\n    return Nothing();\n};",
  "findIndex": "//  Takes a predicate function and a list and\n//  returns Just( the 0-based index of the first\n//  element ) in the list satisfying the predicate\n//  or Nothing if there is no such element.\n\n// findIndex(isSpace, \"hello world\")\n//-> {\"type\":\"Maybe\",\"Nothing\":false,\"Just\":5}\n\n// findIndex(even, [3, 5, 7, 8, 9])\n//-> {\"type\":\"Maybe\",\"Nothing\":false,\"Just\":3}\n\n// findIndex(isUpper, \"all lower case\")\n//-> {\"type\":\"Maybe\",\"Nothing\":true}\n\n// findIndex :: (a -> Bool) -> [a] -> Maybe Int\nconst findIndex = (p, xs) => {\n    const\n        i = (\n            'string' !== typeof xs ? (\n                xs\n            ) : xs.split('')\n        ).findIndex(p);\n    return -1 !== i ? (\n        Just(i)\n    ) : Nothing();\n};",
  "findIndexR": "// findIndexR :: (a -> Bool) -> [a] -> Maybe Int\nconst findIndexR = (p, xs) => {\n    const i = reverse(xs).findIndex(p);\n    return -1 !== i ? (\n        Just(xs.length - (1 + i))\n    ) : Nothing();\n};",
  "findIndices": "// findIndices(matching([2, 3]), [1, 2, 3, 1, 2, 3])\n//-> {2, 5}\n\n// findIndices :: (a -> Bool) -> [a] -> [Int]\n// findIndices :: (String -> Bool) -> String -> [Int]\nconst findIndices = (p, xs) =>\n    concatMap((x, i) => p(x, i, xs) ? (\n        [i]\n    ) : [], xs);",
  "findTree": "// The first of any nodes in the tree which match the predicate p\n// (For all matches, see treeMatches)\n\n// findTree :: (a -> Bool) -> Tree a -> Maybe Tree a\nconst findTree = (p, tree) => {\n    const go = node =>\n        p(node.root) ? (\n            Just(node)\n        ) : (() => {\n            const\n                xs = node.nest,\n                lng = xs.length;\n                \n            return 0 < lng ? until(\n                tpl => lng <= tpl[0] || !tpl[1].Nothing,\n                tpl => Tuple(1 + tpl[0], go(xs[tpl[0]])),\n                Tuple(0, Nothing())\n            )[1] : Nothing()\n        })();\n    return go(tree);\n};",
  "firstArrow": "// Lift a simple function to one which applies to a tuple, \n// transforming only the first item of the tuple\n\n// firstArrow :: (a -> b) -> ((a, c) -> (b, c))\nconst firstArrow = f => xy => Tuple(f(xy[0]), xy[1]);",
  "flatten": "// flatten :: NestedList a -> [a]\nconst flatten = t => {\n\tconst go = x => \n    \tArray.isArray(x) ? (\n        \t[].concat(...x.map(go))\n    \t) : x;\n\treturn go(t);\n};",
  "flattenTree": "// The root elements of a tree in pre-order.\n\n// flattenTree :: Tree a -> [a]\nconst flattenTree = t => {\n    const\n      go = (xs, x) => [x.root]\n      .concat(x.nest.reduceRight(go, xs));\n    return go([], t);\n};",
  "flip": "// flip :: (a -> b -> c) -> b -> a -> c\nconst flip = f =>\n    1 < f.length ? (\n        (a, b) => f(b, a)\n    ) : (x => y => f(y)(x));",
  "floor": "// floor :: Num -> Int\nconst floor = x => {\n    const\n        nr = (\n            'Ratio' !== x.type ? (\n                properFraction\n            ) : properFracRatio\n        )(x),\n        n = nr[0];\n    return 0 > nr[1] ? n - 1 : n;\n};",
  "fmap": "// fmap (<$>) :: Functor f => (a -> b) -> f a -> f b\nconst fmap = (f, fa) =>\n    Array.isArray(fa) ? (\n        fa.map(f)\n    ) : 'string' !== typeof fa ? (() => {\n        const t = fa.type;\n        return ('Either' === t ? (\n            fmapLR(f, fa)\n        ) : 'Maybe' === t ? (\n            fmapMay(f, fa)\n        ) : 'Node' === t ? (\n            fmapTree(f, fa)\n        ) : 'Tuple' === t ? (\n            fmapTuple(f, fa)\n        ) : undefined)\n    })() : fa.split('').map(f);",
  "fmapGen": "// fmapGen <$> :: (a -> b) -> Gen [a] -> Gen [b]\nfunction* fmapGen(f, gen) {\n    let v = take(1, gen);\n    while (0 < v.length) {\n        yield(f(v[0]))\n        v = take(1, gen)\n    }\n}",
  "fmapLR": "// fmapLR (<$>) :: (a -> b) -> Either a a -> Either a b\nconst fmapLR = (f, lr) =>\n    undefined === lr.Left ? (\n        Right(f(lr.Right))\n    ) : lr;",
  "fmapMay": "// fmapMay (<$>) :: (a -> b) -> Maybe a -> Maybe b\nconst fmapMay = (f, mb) =>\n    mb.Nothing ? (\n        mb\n    ) : Just(f(mb.Just));",
  "fmapTree": "// fmapTree :: (a -> b) -> Tree a -> Tree b\nconst fmapTree = (f, tree) => {\n    const go = node => Node(\n        f(node.root),\n        node.nest.map(go)\n    );\n    return go(tree);\n};",
  "fmapTuple": "// fmapTuple (<$>) :: (a -> b) -> (a, a) -> (a, b)\nconst fmapTuple = (f, tpl) =>\n    Tuple(tpl[0], f(tpl[1]));",
  "foldMapTree": "// foldMapTree :: Monoid m => (a -> m) -> Tree a -> m\nconst foldMapTree = (f, node) => {\n    const go = x =>\n        0 < x.nest.length ? mappend(\n            f(x.root),\n            foldl1(mappend, x.nest.map(go))\n        ) : f(x.root);\n    return go(node);\n};",
  "foldTree": "// foldTree :: (a -> [b] -> b) -> Tree a -> b\nconst foldTree = (f, tree) => {\n    const go = node => f(node.root, node.nest.map(go));\n    return go(tree);\n};",
  "foldl": "// foldl :: (a -> b -> a) -> a -> [b] -> a\nconst foldl = (f, a, xs) => xs.reduce(f, a);",
  "foldl1": "// foldl1 :: (a -> a -> a) -> [a] -> a\nconst foldl1 = (f, xs) =>\n    1 < xs.length ? xs.slice(1)\n    .reduce(f, xs[0]) : xs[0];",
  "foldl1May": "// foldl1May :: (a -> a -> a) -> [a] -> Maybe a\nconst foldl1May = (f, xs) =>\n    0 < xs.length ? (\n        Just(xs.slice(1)\n            .reduce(f, xs[0]))\n    ) : Nothing();",
  "foldlTree": "// foldlTree :: (b -> a -> b) -> b -> Tree a -> b\nconst foldlTree = (f, acc, node) => {\n  const go = (a, x) =>\n    x.nest.reduce(go, f(a, x));\n  return go(acc, node);\n};",
  "foldr": "// Note that that the Haskell signature of foldr is different from that of\n// foldl - the positions of accumulator and current value are reversed\n\n// foldr :: (a -> b -> b) -> b -> [a] -> b\nconst foldr = (f, a, xs) => xs.reduceRight(flip(f), a);",
  "foldr1": "// foldr1 :: (a -> a -> a) -> [a] -> a\nconst foldr1 = (f, xs) =>\n    0 < xs.length ? init(xs)\n    .reduceRight(f, last(xs)) : [];",
  "foldr1May": "// foldr1May :: (a -> a -> a) -> [a] -> Maybe a\nconst foldr1May = (f, xs) =>\n    0 < xs.length ? (\n        Just(xs.slice(0, -1)\n            .reduceRight(f, xs.slice(-1)[0]))\n    ) : Nothing();",
  "fromEnum": "// fromEnum :: Enum a => a -> Int\nconst fromEnum = x =>\n    typeof x !== 'string' ? (\n        x.constructor === Object ? (\n            x.value\n        ) : parseInt(Number(x))\n    ) : x.codePointAt(0);",
  "fromLeft": "// | Return the contents of a 'Left'-value or a default value otherwise.\n\n// fromLeft :: a -> Either a b -> a\nconst fromLeft = (def, lr) =>\n  isLeft(lr) ? lr.Left : def;",
  "fromMaybe": "// fromMaybe :: a -> Maybe a -> a\nconst fromMaybe = (def, mb) => mb.Nothing ? def : mb.Just;",
  "fromRight": "// | Return the contents of a 'Right'-value or a default value otherwise.\n\n// fromRight :: b -> Either a b -> b\nconst fromRight = (def, lr) =>\n  isRight(lr) ? lr.Right : def;",
  "fst": "// fst :: (a, b) -> a\nconst fst = tpl => tpl[0];",
  "ft": "// Abbreviation for quick testing\n\n// ft :: (Int, Int) -> [Int]\nconst ft = (m, n) =>\n    Array.from({\n        length: 1 + n - m\n    }, (_, i) => m + i);",
  "gcd": "// gcd :: Int -> Int -> Int\nconst gcd = (x, y) => {\n    const\n        _gcd = (a, b) => (0 === b ? a : _gcd(b, a % b)),\n        abs = Math.abs;\n    return _gcd(abs(x), abs(y));\n};",
  "genericIndexMay": "// genericIndexMay :: [a] -> Int -> Maybe a\nconst genericIndexMay = (xs, i) =>\n    (i < xs.length && 0 <= i) ? Just(xs[i]) : Nothing();",
  "getCurrentDirectory": "// getCurrentDirectory :: IO FilePath\nconst getCurrentDirectory = () =>\n    ObjC.unwrap($.NSFileManager.defaultManager.currentDirectoryPath);",
  "getDirectoryContents": "// getDirectoryContents :: FilePath -> IO [FilePath]\nconst getDirectoryContents = strPath =>\n    ObjC.deepUnwrap(\n        $.NSFileManager.defaultManager\n        .contentsOfDirectoryAtPathError(\n            $(strPath)\n            .stringByStandardizingPath, null\n        )\n    );",
  "getFinderDirectory": "// getFinderDirectory :: IO FilePath\nconst getFinderDirectory = () =>\n    decodeURIComponent(\n        Application('Finder')\n        .insertionLocation()\n        .url()\n        .slice(7)\n    );",
  "getHomeDirectory": "// getHomeDirectory :: IO FilePath\nconst getHomeDirectory = () =>\n    ObjC.unwrap($.NSHomeDirectory());",
  "getTemporaryDirectory": "// getTemporaryDirectory :: IO FilePath\nconst getTemporaryDirectory = () =>\n    ObjC.unwrap($.NSTemporaryDirectory());",
  "group": "// group :: Eq a => [a] -> [[a]]\nconst group = xs => groupBy((a, b) => a === b, xs);",
  "groupBy": "// Typical usage: groupBy(on(eq, f), xs)\n\n// groupBy :: (a -> a -> Bool) -> [a] -> [[a]]\nconst groupBy = (f, xs) => {\n    const tpl = xs.slice(1)\n        .reduce((a, x) => {\n            const h = a[1].length > 0 ? a[1][0] : undefined;\n            return (undefined !== h) && f(h, x) ? (\n                Tuple(a[0], a[1].concat([x]))\n            ) : Tuple(a[0].concat([a[1]]), [x]);\n        }, Tuple([], 0 < xs.length ? [xs[0]] : []));\n    return tpl[0].concat([tpl[1]]);\n};",
  "groupSortOn": "// Sort and group a list by comparing the results of a key function\n// applied to each element. groupSortOn f is equivalent to\n// groupBy eq $ sortBy (comparing f),\n// but has the performance advantage of only evaluating f once for each\n// element in the input list.\n// This is a decorate-(group.sort)-undecorate pattern, as in the\n// so-called 'Schwartzian transform'.\n// Groups are arranged from from lowest to highest.\n\n// groupSortOn :: Ord b => (a -> b) -> [a] -> [a]\n// groupSortOn :: Ord b => [((a -> b), Bool)]  -> [a] -> [a]\nconst groupSortOn = (f, xs) => {\n    // Functions and matching bools derived from argument f\n    // which is a single key function\n    const fsbs = unzip(\n            flatten([f])\n            .reduceRight((a, x) =>\n                'boolean' === typeof x ? {\n                    asc: x,\n                    fbs: a.fbs\n                } : {\n                    asc: true,\n                    fbs: [\n                        [x, a.asc]\n                    ].concat(a.fbs)\n                }, {\n                    asc: true,\n                    fbs: []\n                })\n            .fbs\n        ),\n        [fs, bs] = [fsbs[0], fsbs[1]],\n        iLast = fs.length;\n    // decorate-sort-group-undecorate\n    return groupBy(\n            (p, q) => p[0] === q[0],\n            sortBy(\n                mappendComparing(\n                    // functions that access pre-calculated values by position\n                    // in the decorated ('Schwartzian') version of xs\n                    zip(fs.map((_, i) => x => x[i]), bs)\n                ), xs.map( // xs decorated with precalculated key function values\n                    x => fs.reduceRight(\n                        (a, g) => [g(x)].concat(a), [\n                            x\n                        ]\n                    )\n                )\n            )\n        )\n        .map(gp => gp.map(x => x[iLast])); // undecorated version of data, post sort\n};",
  "gt": "// gt :: Ord a => a -> a -> Bool\nconst gt = (x, y) =>\n    'Tuple' === x.type ? (\n        x[0] > y[0]\n    ) : (x > y);",
  "head": "// head :: [a] -> a\nconst head = xs => xs.length ? xs[0] : undefined;",
  "headMay": "// headMay :: [a] -> Maybe a\nconst headMay = xs =>\n    0 < xs.length ? Just(xs[0]) : Nothing();",
  "id": "// id :: a -> a\nconst id = x => x;",
  "if_": "// if_ :: Bool -> a -> a -> a\nconst if_ = (bln, x, y) =>\n    bln ? x : y;",
  "indented": "// indented :: String -> String -> String\nconst indented = (strIndent, s) =>\n    unlines(map(\n        x => '' !== x ? strIndent + x : x,\n        lines(s)\n    ));",
  "index": "// index (!!) :: [a] -> Int -> Maybe a\n// index (!!) :: Generator (Int, a) -> Int -> Maybe a\n// index (!!) :: String -> Int -> Maybe Char\nconst index = xs => i => {\n    const s = xs.constructor.constructor.name;\n    return 'GeneratorFunction' !== s ? (() => {\n        const v = xs[i];\n        return undefined !== v ? Just(v) : Nothing();\n    })() : (() => {\n        const v = until(\n            x => x.done || i <= fst(x.value),\n            () => xs.next(),\n            xs.next()\n        );\n        return v.done ? Nothing() : Just(snd(v.value));\n    })();\n};",
  "indexOf": "// indexOf :: Eq a => [a] -> [a] -> Maybe Int\n// indexOf :: String -> String -> Maybe Int\nconst indexOf = (needle, haystack) =>\n    'string' !== typeof haystack ? (\n        findIndex(xs => isPrefixOf(needle, xs), tails(haystack))\n    ) : (() => {\n        const i = haystack.indexOf(needle);\n        return -1 !== i ? (\n            Just(i)\n        ) : Nothing();\n    })();",
  "init": "// init :: [a] -> [a]\nconst init = xs =>\n    0 < xs.length ? (\n        xs.slice(0, -1)\n    ) : undefined;",
  "initMay": "// initMay :: [a] -> Maybe [a]\nconst initMay = xs =>\n    0 < xs.length ? Just(xs.slice(0, -1)) : Nothing();",
  "inits": "// inits([1, 2, 3]) -> [[], [1], [1, 2], [1, 2, 3]\n// inits('abc') -> [\"\", \"a\", \"ab\", \"abc\"]\n\n// inits :: [a] -> [[a]]\n// inits :: String -> [String]\nconst inits = xs => [\n        []\n    ]\n    .concat(('string' === typeof xs ? xs.split('') : xs)\n        .map((_, i, lst) => lst.slice(0, i + 1)));",
  "insert": "// insert :: Ord a => a -> [a] -> [a]\nconst insert = (x, ys) => {\n    const cmp = (a, b) => a < b ? -1 : (a > b ? 1 : 0);\n    for (var i = 0, lng = ys.length; i < lng && cmp(x, ys[i]) > 0; i++) {};\n    return ys.slice(0, i)\n        .concat(x)\n        .concat(ys.slice(i));\n};",
  "insertBy": "// insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]\nconst insertBy = (cmp, x, ys) => {\n    for (var i = 0, lng = ys.length; i < lng && cmp(x, ys[i]) > 0; i++) {};\n    return ys.slice(0, i)\n        .concat(x)\n        .concat(ys.slice(i));\n};",
  "insertMap": "// insertMap :: Dict -> String -> a -> Dict\nconst insertMap = (dct, k, v) =>\n  Object.assign(dct, {[k]: v});",
  "intToDigit": "// intToDigit :: Int -> Char\nconst intToDigit = n =>\n    n >= 0 && n < 16 ? (\n        '0123456789ABCDEF'.charAt(n)\n    ) : '?';",
  "intercalate": "// intercalate :: [a] -> [[a]] -> [a]\n// intercalate :: String -> [String] -> String\nconst intercalate = (sep, xs) =>\n    0 < xs.length && 'string' === typeof sep &&\n    'string' === typeof xs[0] ? (\n        xs.join(sep)\n    ) : concat(intersperse(sep, xs));",
  "intercalateS": "// intercalateS :: String -> [String] -> String\nconst intercalateS = (s, xs) =>\n    xs.join(s);",
  "intersect": "// intersect :: (Eq a) => [a] -> [a] -> [a]\nconst intersect = (xs, ys) => {\n    const s = new Set(ys);\n    return xs.filter(x => s.has(x));\n};",
  "intersectBy": "// intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst intersectBy = (eq, xs, ys) => {\n    const ceq = curry(eq);\n    return (0 < xs.length && 0 < ys.length) ?\n    xs.filter(x => ys.some(ceq(x))) : [];\n};",
  "intersectListsBy": "// intersectListsBy :: (a -> a -> Bool) -> [[a]] -> [a]\nconst intersectListsBy = (eq, xs) =>\n    foldr1(((a, x) => intersectBy(eq, a, x)), xs);",
  "intersection": "// intersection :: Ord a => Set a -> Set a -> Set a\nconst intersection = (s, s1) =>\n    new Set([...s].filter(x => s1.has(x)));",
  "intersperse": "// intersperse(0, [1,2,3]) -> [1, 0, 2, 0, 3]\n\n// intersperse :: a -> [a] -> [a]\n// intersperse :: Char -> String -> String\nconst intersperse = (sep, xs) => {\n    const bln = 'string' === typeof xs;\n    return xs.length > 1 ? (\n        (bln ? concat : x => x)(\n            (bln ? (\n                xs.split('')\n            ) : xs)\n            .slice(1)\n            .reduce((a, x) => a.concat([sep, x]), [xs[0]])\n        )) : xs;\n};",
  "isAlpha": "// isAlpha :: Char -> Bool\nconst isAlpha = c =>\n    /[A-Za-z\\u00C0-\\u00FF]/.test(c);",
  "isChar": "// isChar :: a -> Bool\nconst isChar = x =>\n    ('string' === typeof x) && (1 === x.length);",
  "isDigit": "// isDigit :: Char -> Bool\nconst isDigit = c => {\n  const n = ord(c);\n  return 48 <= n && 57 >= n;\n};",
  "isInfixOf": "// isInfixOf :: (Eq a) => [a] -> [a] -> Bool\n// isInfixOf :: String -> String -> Bool\nconst isInfixOf = (needle, haystack) =>\n    'string' !== typeof haystack ? (() => {\n        const\n            lng = needle.length,\n            go = xs => lng <= xs.length ? (\n                isPrefixOf(needle, xs) || go(xs.slice(1))\n            ) : false;\n        return go(haystack);\n    })() : haystack.includes(needle);",
  "isLeft": "// isLeft :: Either a b -> Bool\nconst isLeft = lr =>\n    ('Either' === lr.type) && (undefined !== lr.Left);",
  "isLower": "// isLower :: Char -> Bool\nconst isLower = c =>\n    /[a-z]/.test(c);",
  "isMaybe": "// isMaybe :: a -> Bool\nconst isMaybe = x =>\n    'Maybe' === x.type;",
  "isNull": "// isNull :: [a] -> Bool\n// isNull :: String -> Bool\nconst isNull = xs =>\n    Array.isArray(xs) || ('string' === typeof xs) ? (\n        1 > xs.length\n    ) : undefined;",
  "isPrefixOf": "// isPrefixOf takes two lists or strings and returns \n// true iff the first is a prefix of the second.\n\n// isPrefixOf :: [a] -> [a] -> Bool\n// isPrefixOf :: String -> String -> Bool\nconst isPrefixOf = (xs, ys) => {\n    const go = (xs, ys) => {\n        const intX = xs.length;\n        return 0 < intX ? (\n            ys.length >= intX ? xs[0] === ys[0] && go(\n                xs.slice(1), ys.slice(1)\n            ) : false\n        ) : true;\n    };\n    return 'string' !== typeof xs ? (\n        go(xs, ys)\n    ) : ys.startsWith(xs);\n};",
  "isRight": "// isRight :: Either a b -> Bool\nconst isRight = lr =>\n  ('undefined' !== typeof lr) && \n  ('Either' === lr.type) && (undefined !== lr.Right);",
  "isSortedBy": "// The 'isSortedBy' function returns true iff the predicate returns true\n// for all adjacent pairs of elements in the list.\n\n// isSortedBy :: (a -> a -> Bool) -> [a] -> Bool\nconst isSortedBy = (cmp, xs) =>\n    xs.length < 2 || all(x => x < 1, zipWith(cmp, xs, tail(xs)));",
  "isSpace": "// isSpace :: Char -> Bool\nconst isSpace = c => /\\s/.test(c);",
  "isSubsequenceOf": "// isSubsequenceOf :: Eq a => [a] -> [a] -> Bool\n// isSubsequenceOf :: String -> String -> Bool\nconst isSubsequenceOf = (xs, ys) => {\n    const iss = (a, b) =>\n        a.length > 0 ? (\n            b.length > 0 ? (\n                iss((a[0] === b[0] ? a.slice(1) : a), b.slice(1))\n            ) : false\n        ) : true;\n    return iss.apply(\n        null, 'string' === typeof xs ? [\n            xs.split(''), ys.split('')\n        ] : [xs, ys]\n    );\n};",
  "isSubsetOf": "// isSubsetOf :: Ord a => Set a -> Set a -> Bool\nconst isSubsetOf = (a, b) => {\n    for (let x of a) {\n        if (!b.has(x)) return false;\n    }\n    return true;\n};",
  "isSuffixOf": "// isSuffixOf :: Eq a => [a] -> [a] -> Bool\n// isSuffixOf :: String -> String -> Bool\nconst isSuffixOf = (ns, hs) => {\n    const go = delta =>\n        eq(ns, dropLength(delta, hs));\n    return 'string' !== typeof hs ? (\n        bindMay(dropLengthMaybe(ns, hs), go)\n    ) : hs.endsWith(ns);\n};",
  "isUpper": "// isUpper :: Char -> Bool\nconst isUpper = c =>\n    /[A-Z]/.test(c);",
  "iso8601Local": "// iso8601Local :: Date -> String\nconst iso8601Local = dte =>\n    new Date(dte - (6E4 * dte.getTimezoneOffset()))\n    .toISOString();",
  "iterate": "// iterate :: (a -> a) -> a -> Gen [a]\nfunction* iterate(f, x) {\n    let v = x;\n    while (true) {\n        yield(v);\n        v = f(v);\n    }\n}",
  "iterateUntil": "// iterateUntil :: (a -> Bool) -> (a -> a) -> a -> [a]\nconst iterateUntil = (p, f, x) => {\n    const vs = [x];\n    let h = x;\n    while (!p(h))(h = f(h), vs.push(h));\n    return vs;\n};",
  "join": "// join :: Monad m => m (m a) -> m a\nconst join = x => bind(x, id);",
  "jsonLog": "// jsonLog :: a -> IO ()\nconst jsonLog = (...args) =>\n    console.log(\n        args\n        .map(JSON.stringify)\n        .join(' -> ')\n    );",
  "jsonParseLR": "// jsonParseLR :: String -> Either String a\nconst jsonParseLR = s => {\n    try {\n        return Right(JSON.parse(s));\n    } catch (e) {\n        return Left(`${e.message} (line:${e.line} col:${e.column})`);\n    }\n};",
  "justifyLeft": "// justifyLeft :: Int -> Char -> String -> String\nconst justifyLeft = (n, cFiller, s) =>\n    n > s.length ? (\n        s.padEnd(n ,cFiller)\n    ) : s;",
  "justifyRight": "// justifyRight :: Int -> Char -> String -> String\nconst justifyRight = (n, cFiller, s) =>\n    n > s.length ? (\n        s.padStart(n, cFiller)\n    ) : s;",
  "keys": "// keys :: Dict -> [String]\nconst keys = Object.keys;",
  "kleisliCompose": "// Kleisli composition LR\n\n// kleisliCompose (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)\nconst kleisliCompose = (f, g) =>\n    x => bind(f(x), g);",
  "last": "// last :: [a] -> a\nconst last = xs =>\n    0 < xs.length ? xs.slice(-1)[0] : undefined;",
  "lastMay": "// lastMay :: [a] -> Maybe a\nconst lastMay = xs => 0 < xs.length ? (\n    Just(xs.slice(-1)[0])\n) : Nothing();",
  "lcm": "// lcm :: Int -> Int -> Int\nconst lcm = (x, y) =>\n   ( x === 0 || y === 0) ? 0 : Math.abs(Math.floor(x / gcd(x, y)) * y);",
  "lefts": "// lefts :: [Either a b] -> [a]\nconst lefts = xs =>\n    concatMap(\n        x => ('Either' === x.type) && (undefined !== x.Left) ? (\n            [x.Left]\n        ) : [], xs\n    );",
  "length": "// Returns Infinity over objects without finite length.\n// This enables zip and zipWith to choose the shorter\n// argument when one is non-finite, like cycle, repeat etc\n\n// length :: [a] -> Int\nconst length = xs =>\n    (Array.isArray(xs) || 'string' === typeof xs) ? (\n        xs.length\n    ) : Infinity;",
  "levelNodes": "// levelNodes :: Tree a -> [[Tree a]]\nconst levelNodes = tree =>\n  iterateUntil(\n    xs => 1 > xs.length,\n    xs => concatMap(x => x.nest, xs), [tree]\n  );",
  "levels": "// levels :: Tree a -> [[a]]\nconst levels = tree =>\n    map(xs => map(x => x.root, xs),\n        iterateUntil(\n            xs => 1 > xs.length,\n            xs => concatMap(x => x.nest, xs), [tree]\n        )\n    );",
  "liftA2": "// Lift a binary function to actions.\n// liftA2 f a b = fmap f a <*> b\n// const liftA2 = (f, x, y) => ap(fmap(curry(f), x), y);\n\n// liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\nconst liftA2 = (f, a, b) => {\n    const t = a.type;\n    return (\n        undefined !== t ? (\n            'Either' === t ? (\n                liftA2LR\n            ) : 'Maybe' === t ? (\n                liftA2May\n            ) : 'Tuple' === t ? (\n                liftA2Tuple\n            ) : 'Node' === t ? (\n                liftA2Tree\n            ) : liftA2List\n        ) : liftA2List\n    )(...[f, a, b]);\n};",
  "liftA2LR": "// liftA2LR :: (a -> b -> c) -> Either d a -> Either d b -> Either d c\nconst liftA2LR = (f, a, b) =>\n    undefined !== a.Left ? (\n        a\n    ) : undefined !== b.Left ? (\n        b\n    ) : Right(f(a.Right, b.Right));",
  "liftA2List": "// liftA2List :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst liftA2List = (f, xs, ys) =>\n    concatMap(x => concatMap(y => [f(x, y)], ys), xs);",
  "liftA2May": "// liftA2May :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\nconst liftA2May = (f, a, b) =>\n    a.Nothing ? a : b.Nothing ? b : Just(f(a.Just, b.Just));",
  "liftA2Tree": "// liftA2Tree :: Tree (a -> b -> c) -> Tree a -> Tree b -> Tree c\nconst liftA2Tree = (f, tx, ty) => {\n    const go = tx =>\n        Node(\n            f(tx.root, ty.root || ty),\n            Boolean(ty.nest) ? (\n                ty.nest.map(curry(fmapTree)(curry(f)(tx.root)))\n                .concat(\n                    tx.nest.map(go)\n                )\n            ) : ty\n        );\n    return go(tx);\n};",
  "liftA2Tuple": "// liftA2Tuple :: Monoid m => (a -> b -> c) -> (m, a) -> (m, b) -> (m, c)\nconst liftA2Tuple = (f, a, b) =>\n    Tuple(mappend(a[0], b[0]), f(a[1], b[1]));",
  "liftM2": "// > liftM2 (+) [0,1] [0,2] = [0,2,1,3]\n// > liftM2 (+) (Just 1) Nothing = Nothing\n\n// Control.Monad : \n// \"Promote a function to a monad, scanning the monadic arguments \n// from left to right.\"\n\n// Add 7, 9, or 10,  to 100 or 1000\n// liftM2(plus, [7, 9, 10], [100, 1000])\n\n// --> [107, 1007, 109, 1009, 110, 1010]\n\n// liftM2 f xs ys = [f] <*> xs <*> ys\n\n// liftM2 :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst liftM2 = liftA2;",
  "liftMmay": "// liftMmay :: (a -> b) -> (Maybe a -> Maybe b)\nconst liftMmay = f =>\n    mb => mb.Nothing ? (\n        mb\n    ) : Just(f(mb.Just))",
  "lines": "// lines :: String -> [String]\nconst lines = s => s.split(/[\\r\\n]/);",
  "listDirectory": "// listDirectory :: FilePath -> [FilePath]\nconst listDirectory = strPath =>\n\tObjC.unwrap(\n\t\t$.NSFileManager.defaultManager\n\t\t.contentsOfDirectoryAtPathError(\n\t\t\tObjC.wrap(strPath)\n\t\t\t.stringByStandardizingPath,\n\t\t\tnull\n\t\t))\n\t.map(ObjC.unwrap);",
  "listFromTuple": "// listFromTuple :: (a, a ...) -> [a]\nconst listFromTuple = tpl =>\n    Array.from(tpl);",
  "listToMaybe": "// The listToMaybe function returns Nothing on \n// an empty list or Just the head of the list.\n\n// listToMaybe :: [a] -> Maybe a\nconst listToMaybe = xs =>\n    0 < xs.length ? (\n        Just(xs[0])\n    ) : Nothing();",
  "log": "// log :: Float -> Float\nconst log = Math.log;",
  "lookup": "// lookup :: Eq a => a -> Container -> Maybe b\nconst lookup = (k, m) =>\n    (Array.isArray(m) ? (\n        lookupTuples\n    ) : lookupDict)(k, m);",
  "lookupDict": "// lookupDict :: a -> Dict -> Maybe b\nconst lookupDict = (k, dct) => {\n    const v = dct[k];\n    return undefined !== v ? (\n        Just(v)\n    ) : Nothing();\n};",
  "lookupTuples": "// lookupTuples :: Eq a => a -> [(a, b)] -> Maybe b\nconst lookupTuples = (k, kvs) =>\n    bindMay(\n        find(x => k === fst(x), kvs),\n        x => Just(snd(x))\n    );",
  "mReturn": "// Not required in JS, which has first functions by default.\n// Included only for comparison with AS, which has to derive\n// first class functions by lifting 'handlers' into 'scripts'\n// as anonymous |λ|() functions.\n\n// In JS, mReturn is just an alternate name for id.\n\n// mReturn :: First-class m => (a -> b) -> m (a -> b)\nconst mReturn = x => id(x);",
  "map": "// map :: (a -> b) -> [a] -> [b]\nconst map = (f, xs) =>\n    (Array.isArray(xs) ? (\n        xs\n    ) : xs.split('')).map(f);",
  "mapAccumL": "// Map-accumulation is a combination of map and a catamorphism;\n// it applies a function to each element of a list, passing an accumulating \n// parameter from left to right, and returning a final value of this \n// accumulator together with the new list.\n\n// mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\nconst mapAccumL = (f, acc, xs) =>\n    xs.reduce((a, x, i) => {\n        const pair = f(a[0], x, i);\n        return Tuple(pair[0], a[1].concat(pair[1]));\n    }, Tuple(acc, []));",
  "mapAccumL_Tree": "// mapAccumL_Tree :: (acc -> x -> (acc, y)) -> acc -> Tree -> (acc, Tree)\nconst mapAccumL_Tree = (f, acc, tree) => {\n    const go = (a, x) => {\n        const\n            pair = f(a, x.root),\n            tpl = mapAccumL(go, pair[0], x.nest);\n        return Tuple(tpl[0], Node(pair[1], tpl[1]));\n    };\n    return go(acc, tree);\n};",
  "mapAccumR": "// 'The mapAccumR function behaves like a combination of map and foldr; \n// it applies a function to each element of a list, passing an accumulating \n// parameter from right to left, and returning a final value of this \n// accumulator together with the new list.' (See Hoogle)\n\n// mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\nconst mapAccumR = (f, acc, xs) =>\n    xs.reduceRight((a, x, i) => {\n        const pair = f(a[0], x, i);\n        return Tuple(pair[0],\n            [pair[1]].concat(a[1])\n        );\n    }, Tuple(acc, []));",
  "mapFromList": "// mapFromList :: [(k, v)] -> Dict\nconst mapFromList = kvs =>\n    kvs.reduce(\n        (a, kv) => {\n            const k = kv[0];\n            return Object.assign(a, {\n                [(('string' === typeof k) && k) || show(k)]: kv[1]\n            });\n        }, {}\n    );",
  "mapKeys": "// A function mapped over the keys of a record\n\n// mapKeys :: (Key -> Key) -> IntMap a -> IntMap a\nconst mapKeys = (f, dct) =>\n    mapFromList(\n        map(\n            kv => [f(read(kv[0])), kv[1]],\n            zip(keys(dct), elems(dct))\n        )\n    );",
  "mapMaybe": "// The mapMaybe function is a version of map which can throw out\n// elements. In particular, the functional argument returns\n// something of type Maybe b. If this is Nothing, no element is\n// added on to the result list. If it just Just b, then b is\n// included in the result list.\n\n// mapMaybe :: (a -> Maybe b) -> [a] -> [b]\nconst mapMaybe = (mf, xs) =>\n  xs.reduce(\n    (a, x) => maybe(a, j => a.concat(j), mf(x)),\n    []\n  );",
  "mapMaybeGen": "// mapMaybeGen :: (a -> Maybe b) -> Gen [a] -> Gen [b]\nfunction* mapMaybeGen(mf, gen) {\n    let v = take(1, gen);\n    while (0 < v.length) {\n        let mb = mf(v[0]);\n        if (!mb.Nothing) yield mb.Just\n        v = take(1, gen);\n    }\n}",
  "mappend": "// mappend (<>) :: Monoid a => a -> a -> a\nconst mappend = (a, b) => {\n    const t = a.type;\n    return (\n        Boolean(t) ? (\n            'Maybe' === t ? (\n                mappendMaybe\n            ) : 'Ordering' === t ? (\n                mappendOrdering\n            ) : mappendTuple\n        ) : 'function' !== typeof a ? (\n            append\n        ) : mappendFn\n    )(a, b);\n};",
  "mappendComparing": "// mappendComparing :: [(a -> b)] -> (a -> a -> Ordering)\nconst mappendComparing = fs =>\n    (x, y) => fs.reduce(\n        (ordr, f) => (ordr || compare(f(x), f(y))),\n        0\n    );",
  "mappendComparing2": "// Expects functions in the argument list to be \n// paired with Bools:\n//     true  -> ascending sort on that key\n//     false -> descending sort on that key\n\n// mappendComparing2 :: [((a -> b), Bool)] -> (a -> a -> Ordering)\nconst mappendComparing2 = fboolPairs =>\n    (x, y) => fboolPairs.reduce(\n        (ordr, fb) => {\n            const f = fb[0];\n            return 0 !== ordr ? (\n                ordr\n            ) : fb[1] ? (\n                compare(f(x), f(y))\n            ) : compare(f(y), f(x));\n        }, 0\n    );",
  "mappendFn": "// mappendFn :: Monoid b => (a -> b) -> (a -> b) -> (a -> b)\nconst mappendFn = (f, g) =>\n    x => mappend(f(x), g(x));",
  "mappendMaybe": "// mappendMaybe (<>) :: Maybe a -> Maybe a -> Maybe a\nconst mappendMaybe = (a, b) =>\n    a.Nothing ? b : b.Nothing ? a :\n    Just(mappend(a.Just, b.Just));",
  "mappendOrdering": "// mappendOrdering (<>) :: Ordering -> Ordering -> Ordering\nconst mappendOrdering = (a, b) => eqOrdering(EQ, a) ? b : a;",
  "mappendTuple": "// mappendTuple (<>) :: (a, b) -> (a, b) -> (a, b)\nconst mappendTuple = (t, t2) =>\n    Tuple(mappend(t[0], t1[0]), mappend(t[1], t1[1]));",
  "matching": "// Returns a sequence-matching function for findIndices etc\n// findIndices(matching([2, 3]), [1, 2, 3, 1, 2, 3])\n// -> [1, 4]\n\n// matching :: [a] -> (a -> Int -> [a] -> Bool)\nconst matching = pat => {\n    const\n        lng = pat.length,\n        bln = 0 < lng,\n        h = bln ? pat[0] : undefined;\n    return (x, i, src) =>\n        bln && h == x &&\n        eq(pat, src.slice(i, lng + i));\n};",
  "max": "// max :: Ord a => a -> a -> a\nconst max = (a, b) => gt(b, a) ? b : a;",
  "maxBound": "// maxBound :: a -> a\nconst maxBound = x => {\n    const e = x.enum;\n    return Boolean(e) ? (\n        e[e[x.max]]\n    ) : {\n        'number': Number.MAX_SAFE_INTEGER,\n        'string': String.fromCodePoint(65535),\n        'boolean': true\n    }[typeof x];\n};",
  "maximum": "// maximum :: Ord a => [a] -> a\nconst maximum = xs =>\n    0 < xs.length ? (\n        foldl1((a, x) => x > a ? x : a, xs)\n    ) : undefined;",
  "maximumBy": "//  Ordering: (LT|EQ|GT):\n//  GT: 1 (or other positive n)\n//\tEQ: 0\n//  LT: -1 (or other negative n) \n\n// maximumBy :: (a -> a -> Ordering) -> [a] -> a\nconst maximumBy = (f, xs) =>\n    0 < xs.length ? (\n        xs.slice(1)\n        .reduce((a, x) => 0 < f(x, a) ? x : a, xs[0])\n    ) : undefined;",
  "maximumByMay": "//Ordering: (LT|EQ|GT):\n//  GT: 1 (or other positive n)\n//\tEQ: 0\n//  LT: -1 (or other negative n) \n\n// maximumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\nconst maximumByMay = (f, xs) =>\n    xs.length > 0 ? (\n        Just(xs.slice(1)\n            .reduce((a, x) => 0 < f(x, a) ? x : a, xs[0]))\n    ) : Nothing();",
  "maximumMay": "// maximumMay :: Ord a => [a] -> Maybe a\nconst maximumMay = xs =>\n    0 < xs.length ? (\n        Just(xs.slice(1)\n            .reduce((a, x) => (x > a ? x : a), xs[0]))\n    ) : Nothing();",
  "maybe": "// Default value (v) if m.Nothing, or f(m.Just)\n\n// maybe :: b -> (a -> b) -> Maybe a -> b\nconst maybe = (v, f, m) =>\n    m.Nothing ? v : f(m.Just);",
  "maybeToList": "// The maybeToList function returns an empty list when given\n// Nothing or a singleton list when not given Nothing.”\n\n// maybeToList :: Maybe a -> [a]\nconst maybeToList = mb =>\n    mb.Nothing ? [] : [mb.Just];",
  "mean": "// mean :: [Num] -> Num\nconst mean = xs =>\n  xs.reduce((a, x) => a + x, 0) / xs.length;",
  "member": "// member :: Key -> Dict -> Bool\nconst member = (k, dct) => k in dct;",
  "min": "// min :: Ord a => a -> a -> a\nconst min = (a, b) => b < a ? b : a;",
  "minBound": "// minBound :: a -> a\nconst minBound = x => {\n    const e = x.enum;\n    return Boolean(e) ? (\n        e[e[0]]\n    ) : {\n        'number': Number.MIN_SAFE_INTEGER,\n        'string': String.fromCodePoint(0),\n        'boolean': false\n    }[typeof x];\n};",
  "minimum": "// minimum :: Ord a => [a] -> a\nconst minimum = xs =>\n    0 < xs.length ? (\n        foldl1((a, x) => x < a ? x : a, xs)\n    ) : undefined;",
  "minimumBy": "//Ordering: (LT|EQ|GT):\n//  GT: 1 (or other positive n)\n//\tEQ: 0\n//  LT: -1 (or other negative n)\n\n// minimumBy :: (a -> a -> Ordering) -> [a] -> a\nconst minimumBy = (f, xs) =>\n    xs.reduce((a, x) => undefined === a ? x : (\n        0 > f(x, a) ? x : a\n    ), undefined);",
  "minimumByMay": "// minimumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\nconst minimumByMay = (f, xs) =>\n    xs.reduce((a, x) => a.Nothing ? Just(x) : (\n        f(x, a.Just) < 0 ? Just(x) : a\n    ), Nothing());",
  "minimumMay": "// minimumMay :: [a] -> Maybe a\nconst minimumMay = xs =>\n    0 < xs.length ? (\n        Just(xs.slice(1)\n            .reduce((a, x) => x < a ? x : a, xs[0])\n        )\n    ) : Nothing();",
  "mod": "// mod :: Int -> Int -> Int\nconst mod = (n, d) => n % d;",
  "modificationTime": "// modificationTime :: FilePath -> Either String Date\nconst modificationTime = fp =>\n    bindLR(\n       fileStatus(fp),\n       dct => Right(ObjC.unwrap(dct.NSFileModificationDate))\n    );",
  "namedEnumFromList": "// namedEnumFromList :: String -> [String] -> Dict\nconst namedEnumFromList = (name, keys, values) => {\n    const\n        e = {},\n        iMax = keys.length - 1;\n    return keys.map(\n        values ? (\n            (k, i) => Tuple(k, values[i])\n        ) : Tuple\n    ).reduce(\n        (a, kv) => Object.assign(\n            a, {\n                [kv[0]]: {\n                    'type': 'enum',\n                    'name': name,\n                    'key': kv[0],\n                    'max' : iMax,\n                    'value': kv[1],\n                    'enum': e\n                },\n                [kv[1]]: kv[0]\n            }\n        ), e\n    );\n};",
  "negate": "// negate :: Num -> Num\nconst negate = n => -n;",
  "newUUID": "// newUUID :: () -> IO UUID String\nconst newUUID = () =>\n    ObjC.unwrap($.NSUUID.UUID.UUIDString);",
  "not": "// not :: Bool -> Bool\nconst not = b => !b;",
  "notElem": "// notElem :: Eq a => a -> [a] -> Bool\nconst notElem = (x, xs) => -1 === xs.indexOf(x);",
  "nub": "// nub :: [a] -> [a]\nconst nub = xs => nubBy(eq, xs);",
  "nubBy": "// nubBy :: (a -> a -> Bool) -> [a] -> [a]\nconst nubBy = (p, xs) => {\n    const go = xs => 0 < xs.length ? (() => {\n        const x = xs[0];\n        return [x].concat(\n            go(xs.slice(1)\n                .filter(y => !p(x, y))\n            )\n        )\n    })() : [];\n    return go(xs);\n};",
  "odd": "// odd :: Int -> Bool\nconst odd = n => !even(n);",
  "on": "// e.g. sortBy(on(compare,length), xs)\n\n// on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\nconst on = (f, g) => (a, b) => f(g(a), g(b));",
  "op": "// Derive a function from the name of a JS infix operator\n\n// op :: String -> (a -> a -> b)\nconst op = strOp =>\n    eval(`(a, b) => a ${strOp} b`);",
  "or": "// or :: [Bool] -> Bool\nconst or = xs =>\n    xs.some(Boolean);",
  "ord": "// ord :: Char -> Int\nconst ord = c => c.codePointAt(0);",
  "ordering": "// ordering :: () -> Ordering\nconst\n    ordering = namedEnumFromList(\n        'Ordering', ['LT', 'EQ', 'GT'],\n        [-1, 0, 1]\n    ),\n    LT = ordering.LT,\n    EQ = ordering.EQ,\n    GT = ordering.GT;",
  "outdented": "// All lines in the string outdented by the same amount\n// (just enough to ensure that the least indented lines \n//  have no remaining indent)\n// All relative indents are left unchanged\n\n// outdented :: String -> String\nconst outdented = s => {\n    const\n        rgx = /^ */, // Leading space characters.\n        xs = lines(s),\n        n = length(minimumBy( // size of minimum indent\n            comparing(length),\n            map(txt => rgx.exec(txt)[0], xs)\n        ));\n    return unlines(map(curry(drop)(n), xs));\n};",
  "partition": "// partition :: Predicate -> List -> (Matches, nonMatches)\n\n// partition :: (a -> Bool) -> [a] -> ([a], [a])\nconst partition = (p, xs) =>\n    xs.reduce(\n        (a, x) =>\n        p(x) ? (\n            Tuple(a[0].concat(x), a[1])\n        ) : Tuple(a[0], a[1].concat(x)),\n        Tuple([], [])\n    );",
  "partitionEithers": "// partitionEithers :: [Either a b] -> ([a],[b])\nconst partitionEithers = xs =>\n    xs.reduce(\n        (a, x) => undefined !== x.Left ? (\n            Tuple(a[0].concat(x.Left), a[1])\n        ) : Tuple(a[0], a[1].concat(x.Right)),\n        Tuple([], [])\n    );",
  "permutations": "// permutations :: [a] -> [[a]]\nconst permutations = xs =>\n    xs.reduceRight(\n        (a, x) => concatMap(\n            xs => enumFromTo(0, xs.length)\n            .map(n => xs.slice(0, n)\n                .concat(x)\n                .concat(xs.slice(n))\n            ),\n            a\n        ),\n        [[]]\n    );\n\n// OR\n// // permutations :: [a] -> [[a]]\n// const permutations = xs => {\n//     const go = xs =>\n//         xs.length ? concatMap(x => concatMap(ys => [\n//                 [x].concat(ys)\n//             ],\n//             go(delete_(x, xs))), xs) : [\n//             []\n//         ];\n//     return go(xs);\n// };",
  "permutationsWithRepetition": "// permutationsWithRepetition :: Int -> [a] -> [[a]]\nconst permutationsWithRepetition = (n, xs) =>\n    0 < xs.length ? (\n        map(flatten,\n            foldl1(\n                x => cartesianProduct(xs, x),\n                replicate(n, xs)\n            )\n        )\n    ) : [];",
  "pi": "// pi :: Float\nconst pi = Math.PI;",
  "plus": "// plus :: Num -> Num -> Num\nconst plus = (a, b) => a + b;",
  "postorder": "// Root elements of tree flattened bottom-up\n// into a postorder list.\n\n// postorder :: Tree a -> [a]\nconst postorder = t => {\n    const go = (xs, x) =>\n        x.nest.reduce(go, xs).concat(x.root);\n    return go([], t);\n};",
  "pred": "// pred :: Enum a => a -> a\nconst pred = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mn] = [x, minBound(x)].map(fromEnum);\n        return i > mn ? (\n            toEnum(x)(i - 1)\n        ) : Error('succ :: enum out of range.')\n    })() : x > Number.MIN_SAFE_INTEGER ? (\n        x - 1\n    ) : Error('succ :: Num out of range.')\n};",
  "predMay": "// predMay :: Enum a => a -> Maybe a\nconst predMay = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mn] = [x, minBound(x)].map(fromEnum);\n        return i > mn ? (\n            Just(toEnum(x)(i - 1))\n        ) : Nothing()\n    })() : x > Number.MIN_SAFE_INTEGER ? (\n        Just(x - 1)\n    ) : Nothing()\n};",
  "print": "// print :: a -> IO ()\nconst print = x => {\n    const\n        c = x.constructor.name,\n        s = 'object' !== typeof x ? (\n            x.toString()\n        ) : 'Date' !== c ? (\n            JSON.stringify.apply(\n                null,\n                'Array' !== c ? (\n                    [x, null, 2]\n                ) : [x]\n            )\n        ) : x.toString();\n    return (\n        typeof document !== 'undefined' ? (\n            document.writeln(s)\n        ) : typeof draft !== 'undefined' ? (\n            editor.setText(\n                editor.getText() + '\\n' + s\n            )\n        ) : (\n            console.log(s),\n            s\n        )\n    );\n};",
  "product": "// product :: [Num] -> Num\nconst product = xs => xs.reduce((a, x) => a * x, 1);",
  "properFracRatio": "// properFracRatio :: Ratio -> (Int, Ratio)\nconst properFracRatio = nd => {\n    const [q, r] = Array.from(quotRem(nd.n, nd.d));\n    return Tuple(q, ratio(r, nd.d));\n};",
  "properFraction": "// properFraction :: Real -> (Int, Real)\nconst properFraction = n => {\n    const i = Math.floor(n) + (n < 0 ? 1 : 0);\n    return Tuple(i, n - i);\n};",
  "pureLR": "// pureLR :: a -> Either e a\nconst pureLR = x => Right(x);",
  "pureList": "// pureList :: a -> [a]\nconst pureList = x => [x];",
  "pureMay": "// pureMay :: a -> Maybe a\nconst pureMay = x => Just(x);",
  "pureT": "// Given a type name string, returns a \n// specialised 'pure', where\n// 'pure' lifts a value into a particular functor.\n\n// pureT :: String -> f a -> (a -> f a)\nconst pureT = (t, x) =>\n    'List' !== t ? (\n        'Either' === t ? (\n            pureLR(x)\n        ) : 'Maybe' === t ? (\n            pureMay(x)\n        ) : 'Node' === t ? (\n            pureTree(x)\n        ) : 'Tuple' === t ? (\n            pureTuple(x)\n        ) : pureList(x)\n    ) : pureList(x);",
  "pureTree": "// pureTree :: a -> Tree a\nconst pureTree = x => Node(x, []);",
  "pureTuple": "// pureTuple :: a -> (a, a)\nconst pureTuple = x => Tuple('', x);",
  "quickSort": "// Included only for comparison with AppleScript\n// sort and sortBy are faster and more flexible\n\n// quickSort :: (Ord a) => [a] -> [a]\nconst quickSort = xs =>\n    xs.length > 1 ? (() => {\n        const\n            h = xs[0],\n            lessMore = partition(x => x <= h, xs.slice(1));\n        return [].concat.apply(\n            [], [quickSort(lessMore[0]), h, quickSort(lessMore[1])]\n        );\n    })() : xs;",
  "quickSortBy": "// Included only for comparison with AppleScript\n// sort and sortBy are faster and more flexible\n\n// quickSortBy :: (a -> a -> Ordering) -> [a] -> [a]\nconst quickSortBy = (cmp, xs) =>\n    xs.length > 1 ? (() => {\n        const\n            h = xs[0],\n            lessMore = partition(\n                x => 1 !== cmp(x, h),\n                xs.slice(1)\n            );\n        return [].concat.apply(\n            [], [quickSortBy(cmp, lessMore[0]), h, quickSortBy(cmp, lessMore[1])]\n        );\n    })() : xs;",
  "quot": "// quot :: Int -> Int -> Int\nconst quot = (n, m) => Math.floor(n / m);",
  "quotRem": "// quotRem :: Int -> Int -> (Int, Int)\nconst quotRem = (m, n) => \n  Tuple(Math.floor(m / n), m % n);",
  "radians": "// radians :: Float x => Degrees x -> Radians x\nconst radians = x =>\n    (Math.PI / 180) * x;",
  "raise": "// raise :: Num -> Int -> Num\nconst raise = (n, e) => Math.pow(n, e);",
  "randomRInt": "// e.g. map(randomRInt(1, 10), ft(1, 20))\n\n// randomRInt :: Int -> Int -> IO () -> Int\nconst randomRInt = (low, high) => () =>\n    low + Math.floor(\n        (Math.random() * ((high - low) + 1))\n    );",
  "range": "// The list of values in the subrange defined by a bounding pair.\n\n// range([0, 2]) -> [0,1,2]\n// range([[0,0], [2,2]]) \n//  -> [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\n// range([[0,0,0],[1,1,1]])\n//  -> [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]\n\n// range :: Ix a => (a, a) -> [a]\nfunction range() {\n    const\n        args = Array.from(arguments),\n        ab = 1 !== args.length ? (\n            args\n        ) : args[0],\n        [as, bs] = [ab[0], ab[1]].map(\n            x => Array.isArray(x) ? (\n                x\n            ) : (undefined !== x.type) &&\n            (x.type.startsWith('Tuple')) ? (\n                listFromTuple(x)\n            ) : [x]\n        ),\n        an = as.length;\n    return (an === bs.length) ? (\n        1 < an ? (\n            sequenceAList(as.map((_, i) => enumFromTo(as[i], bs[i])))\n        ) : enumFromTo(as[0], bs[0])\n    ) : [];\n};",
  "ratio": "// ratio :: Int -> Int -> Ratio Int\nconst ratio = (x, y) => {\n  const go = (x, y) =>\n    0 !== y ? (() => {\n      const d = gcd(x, y);\n      return {\n        type: 'Ratio',\n        'n': quot(x, d), // numerator\n        'd': quot(y, d) // denominator\n      };\n    })() : undefined;\n  return go(x * signum(y), abs(y));\n};",
  "ratioDiv": "// ratioDiv :: Rational -> Rational -> Rational\nconst ratioDiv = (n1, n2) => {\n    const [r1, r2] = map(rational, [n1, n2]);\n    return ratio(r1.n * r2.d, r1.d * r2.n);\n};",
  "ratioMinus": "// ratioMinus :: Rational -> Rational -> Rational\nconst ratioMinus = (n1, n2) => {\n    const [r1, r2] = map(rational, [n1, n2]);\n    const d = lcm(r1.d, r2.d);\n    return ratio(\n        (r1.n * (d / r1.d)) - (r2.n * (d / r2.d)),\n        d\n    );\n};",
  "ratioMult": "// ratioMult :: Rational -> Rational -> Rational\nconst ratioMult = (n1, n2) => {\n    const [r1, r2] = map(rational, [n1, n2]);\n    return ratio(r1.n * r2.n, r1.d * r2.d);\n};",
  "ratioPlus": "// ratioPlus :: Rational -> Rational -> Rational\nconst ratioPlus = (n1, n2) => {\n    const [r1, r2] = map(rational, [n1, n2]);\n    const d = lcm(r1.d, r2.d);\n    return ratio(\n        (r1.n * (d / r1.d)) + (r2.n * (d / r2.d)),\n        d\n    );\n};",
  "rational": "// rational :: Num a => a -> Rational\nconst rational = x =>\n    isNaN(x) ? x : Number.isInteger(x) ? (\n        ratio(x, 1)\n    ) : approxRatio(undefined)(x);",
  "read": "// read :: Read a => String -> a\nconst read = JSON.parse;",
  "readFile": "// readFile :: FilePath -> IO String\nconst readFile = fp => {\n    const\n        e = $(),\n        uw = ObjC.unwrap,\n        s = uw(\n            $.NSString.stringWithContentsOfFileEncodingError(\n                $(fp)\n                .stringByStandardizingPath,\n                $.NSUTF8StringEncoding,\n                e\n            )\n        );\n    return undefined !== s ? (\n        s\n    ) : uw(e.localizedDescription);\n};",
  "readFileLR": "// readFileLR :: FilePath -> Either String String\nconst readFileLR = fp => {\n    const\n        e = $(),\n        uw = ObjC.unwrap,\n        s = uw(\n            $.NSString.stringWithContentsOfFileEncodingError(\n                $(fp)\n                .stringByStandardizingPath,\n                $.NSUTF8StringEncoding,\n                e\n            )\n        );\n    return undefined !== s ? (\n        Right(s)\n    ) : Left(uw(e.localizedDescription));\n};",
  "readLR": "// readLR :: Read a => String -> Either String a\nconst readLR = s => {\n    try {\n        return Right(JSON.parse(s))\n    } catch (e) {\n        return Left(e.message);\n    };\n};",
  "recip": "// recip :: Num -> Num\nconst recip = n =>\n    0 !== n ? (1 / n) : undefined;",
  "recipMay": "// recipMay :: Num -> Maybe Num\nconst recipMay = n =>\n    0 === n ? (\n        Nothing()\n    ) : Just(1 / n);",
  "regexMatches": "// regexMatches :: String -> String -> [[String]]\nconst regexMatches = (strRgx, strHay) => {\n    const rgx = new RegExp(strRgx, 'g');\n    let m = rgx.exec(strHay),\n        xs = [];\n    while (m)(xs.push(m), m = rgx.exec(strHay));\n    return xs;\n};",
  "rem": "// rem :: Int -> Int -> Int\nconst rem = (n, m) => n % m;",
  "removeFile": "// removeFile :: FilePath -> Either String String\nconst removeFile = fp => {\n  const error = $();\n  return $.NSFileManager.defaultManager\n    .removeItemAtPathError(fp, error) ? (\n      Right('Removed: ' + fp)\n    ) : Left(ObjC.unwrap(error.localizedDescription));\n};",
  "repeat": "// repeat :: a -> Generator [a]\nfunction* repeat(xs) {\n    while(true) yield xs;\n}",
  "replace": "// replace :: String -> String -> String -> String\n// replace :: Regex -> String -> String -> String\nconst replace = (needle, strNew, strHaystack) =>\n    strHaystack.replace(\n      'string' !== typeof needle ? (\n        needle\n      ) : new RegExp(needle, 'g'),\n      strNew\n    );",
  "replicate": "// replicate :: Int -> a -> [a]\nconst replicate = (n, x) =>\n    Array.from({\n        length: n\n    }, () => x);",
  "replicateM": "// Instance for lists (arrays) only here\n\n// replicateM :: Int -> [a] -> [[a]]\nconst replicateM = (n, xs) => {\n    const go = x => 0 >= x ? [\n        []\n    ] : liftA2List(cons, xs, go(x - 1));\n    return go(n);\n};",
  "replicateString": "// replicateString :: Int -> String -> String\nconst replicateString = (n, s) => s.repeat(n);",
  "reverse": "// reverse :: [a] -> [a]\nconst reverse = xs =>\n    'string' !== typeof xs ? (\n        xs.slice(0).reverse()\n    ) : xs.split('').reverse().join('');",
  "rights": "// rights :: [Either a b] -> [b]\nconst rights = xs =>\n    concatMap(\n        x => ('Either' === x.type) && (undefined !== x.Right) ? (\n            [x.Right]\n        ) : [], xs\n    );",
  "rotate": "// rotate :: Int -> [a] -> [a]\nconst rotate = (n, xs) => {\n    const lng = xs.length;\n    return Infinity > lng ? (\n        take(lng, drop(lng - n, cycle(xs)))\n    ) : undefined;\n};",
  "round": "// round :: a -> Int\nconst round = x => {\n    const\n        nr = properFraction(x),\n        [n, r] = [nr[0], nr[1]],\n        m = n + (r < 0 ? -1 : 1),\n        sign = signum(abs(r) - 0.5);\n    return (-1 === sign) ? n : (\n        0 === sign ? (even(n) ? n : m) : (\n            1 === sign ? m : undefined\n        )\n    );\n};",
  "safeMay": "// safeMay :: (a -> Bool) -> (a -> b) -> Maybe b\nconst safeMay = (p, f, x) =>\n    p(x) ? Just(f(x)) : Nothing();",
  "scanl": "// scanl :: (b -> a -> b) -> b -> [a] -> [b]\nconst scanl = (f, startValue, xs) =>\n    xs.reduce((a, x) => {\n        const v = f(a[0], x);\n        return Tuple(v, a[1].concat(v));\n    }, Tuple(startValue, [startValue]))[1];",
  "scanl1": "// scanl1 is a variant of scanl that has no starting value argument\n\n// scanl1 :: (a -> a -> a) -> [a] -> [a]\nconst scanl1 = (f, xs) =>\n    xs.length > 0 ? scanl(f, xs[0], xs.slice(1)) : [];",
  "scanr": "// scanr :: (b -> a -> b) -> b -> [a] -> [b]\nconst scanr = (f, startValue, xs) =>\n    xs.reduceRight((a, x) => {\n        const v = f(a.acc, x);\n        return {\n            acc: v,\n            scan: [v].concat(a.scan)\n        };\n    }, {\n        acc: startValue,\n        scan: [startValue]\n    })\n    .scan;",
  "scanr1": "// scanr1 is a variant of scanr that has no starting value argument\n\n// scanr1 :: (a -> a -> a) -> [a] -> [a]\nconst scanr1 = (f, xs) =>\n    xs.length > 0 ? scanr(f, xs.slice(-1)[0], xs.slice(0, -1)) : [];",
  "secondArrow": "// Lift a simple function to one which applies to a tuple, \n// transforming only the second item of the tuple\n\n// secondArrow :: (a -> b) -> ((c, a) -> (c, b))\nconst secondArrow = f => xy => Tuple(xy[0], f(xy[1]));",
  "sequenceA": "// sequenceA :: (Applicative f, Traversable t) => t (f a) -> f (t a)\nconst sequenceA = tfa =>\n    traverse(x => x, tfa);",
  "setCurrentDirectory": "// setCurrentDirectory :: String -> IO ()\nconst setCurrentDirectory = strPath =>\n    $.NSFileManager.defaultManager\n    .changeCurrentDirectoryPath(\n        ObjC.wrap(strPath)\n        .stringByStandardizingPath\n    );",
  "setFromList": "// setFromList :: Ord a => [a] -> Set a\nconst setFromList = xs =>\n    new Set(xs);",
  "setInsert": "// setInsert :: Ord a => a -> Set a -> Set a\nconst setInsert = (x, set) =>\n    set.add(x);",
  "setMember": "// setMember :: Ord a => a -> Set a -> Bool\nconst setMember = (x, set) =>\n    set.has(x);",
  "setSize": "// setSize :: Set a -> Int\nconst setSize = set =>\n    set.size;",
  "shift": "// shift :: Int -> [a] -> [a]\nconst shift = (n, xs) => {\n    const lng = length(xs);\n    return Infinity > lng ? (\n        take(lng, drop(n, cycle(xs)))\n    ) : (drop(n, xs), xs);\n};",
  "show": "// show :: a -> String\n// show :: a -> Int -> Indented String\nconst show = (x, n) => {\n    const\n        e = ('function' !== typeof x) ? (\n            x\n        ) : {\n            type: 'Function',\n            f: x\n        };\n    return JSON.stringify(e, (_, v) => {\n        const\n            f = ((null !== v) && (undefined !== v)) ? (() => {\n                const t = v.type;\n                return 'Either' === t ? (\n                    showLR\n                ) : 'Function' === t ? (\n                    dct => 'λ' + dct.f.toString()\n                ) : 'Maybe' === t ? (\n                    showMaybe\n                ) : 'Ordering' === t ? (\n                    showOrdering\n                ) : 'Ratio' === t ? (\n                    showRatio\n                ) : 'string' === typeof t && t.startsWith('Tuple') ? (\n                    showTuple\n                ) : undefined;\n            })() : showUndefined;\n        return Boolean(f) ? (\n            f(v)\n        ) : 'string' !== typeof v ? (\n            v\n        ) : \"'\" + v + \"'\";\n    }, n)\n};",
  "showBinary": "// showBinary :: Int -> String\nconst showBinary = n => {\n    const binaryChar = n => 0 !== n ? '1' : '0';\n    return showIntAtBase(2, binaryChar, n, '');\n};",
  "showDate": "// showDate :: Date -> String\nconst showDate = JSON.stringify;",
  "showDict": "// showDict :: Dict -> String\nconst showDict = show;",
  "showHex": "// showHex :: Int -> String\nconst showHex = n =>\n    showIntAtBase(16, intToDigit, n, '');",
  "showIntAtBase": "// showIntAtBase :: Int -> (Int -> Char) -> Int -> String -> String\nconst showIntAtBase = (base, toChr, n, rs) => {\n    const go = ([n, d], r) => {\n        const r_ = toChr(d) + r;\n        return 0 !== n ? (\n            go(Array.from(quotRem(n, base)), r_)\n        ) : r_;\n    };\n    return 1 >= base ? (\n        'error: showIntAtBase applied to unsupported base'\n    ) : 0 > n ? (\n        'error: showIntAtBase applied to negative number'\n    ) : go(Array.from(quotRem(n, base)), rs);\n};",
  "showJSON": "// showJSON :: a -> String\nconst showJSON = x => JSON.stringify(x, null, 2);",
  "showLR": "// showLR :: Either a b -> String\nconst showLR = lr => {\n    const k = undefined !== lr.Left ? (\n        'Left'\n    ) : 'Right';\n    return k + '(' + unQuoted(show(lr[k])) + ')';\n};",
  "showList": "// showList :: [a] -> String\nconst showList = x => show(x);",
  "showLog": "// showLog :: a -> IO ()\nconst showLog = (...args) =>\n    console.log(\n        args\n        .map(JSON.stringify)\n        .join(' -> ')\n    );",
  "showMaybe": "// showMaybe :: Maybe a -> String\nconst showMaybe = mb =>\n    mb.Nothing ? (\n        'Nothing'\n    ) : 'Just(' + unQuoted(show(mb.Just)) + ')';",
  "showOrdering": "// showOrdering :: Ordering -> String\nconst showOrdering = e =>\n    0 < e.value ? (\n        'GT'\n    ) : 0 > e.value ? (\n        'LT'\n    ) : 'EQ';",
  "showRatio": "// showRatio :: Ratio -> String\nconst showRatio = r =>\n    'Ratio' !== r.type ? (\n        r.toString()\n    ) : r.n.toString() + (\n        1 !== r.d ? (\n            '/' + r.d.toString()\n        ) : ''\n    );",
  "showSet": "// showSet :: Set -> String\nconst showSet = s =>\n    intercalate(sort(elems(s)), ['{','}']);",
  "showTuple": "// showTuple :: Tuple -> String\nconst showTuple = tpl =>\n    '(' + enumFromTo(0, tpl.length - 1)\n    .map(x => unQuoted(show(tpl[x])))\n    .join(',') + ')';",
  "showUndefined": "// showUndefined :: () -> String\nconst showUndefined = () => '(⊥)';",
  "signum": "// | Sign of a number.\n// The functions 'abs' and 'signum' should satisfy the law:\n//\n// > abs x * signum x == x\n//\n// For real numbers, the 'signum' is either @-1@ (negative), @0@ (zero)\n// or @1@ (positive).\n\n// signum :: Num -> Num\nconst signum = n => 0 > n ? -1 : (0 < n ? 1 : 0);",
  "sj": "// Abbreviation for quick testing - any 2nd arg interpreted as indent size\n\n// sj :: a -> String\nfunction sj() {\n    const args = Array.from(arguments);\n    return JSON.stringify.apply(\n        null,\n        1 < args.length && !isNaN(args[0]) ? [\n            args[1], null, args[0]\n        ] : [args[0], null, 2]\n    );\n}",
  "snd": "// snd :: (a, b) -> b\nconst snd = tpl => tpl[1];",
  "snoc": "// Mirror image of cons\n// New copy of the list, with an atom added at the end\n\n// snoc :: [a] -> a -> [a]\nconst snoc = (xs, x) => xs.concat(x);",
  "sort": "// sort :: Ord a => [a] -> [a]\nconst sort = xs => xs.slice()\n    .sort((a, b) => a < b ? -1 : (a > b ? 1 : 0));",
  "sortBy": "// sortBy :: (a -> a -> Ordering) -> [a] -> [a]\nconst sortBy = (f, xs) =>\n    xs.slice()\n    .sort(f);",
  "sortOn": "// Sort a list by comparing the results of a key function applied to each\n// element. sortOn f is equivalent to sortBy (comparing f), but has the\n// performance advantage of only evaluating f once for each element in\n// the input list. This is called the decorate-sort-undecorate paradigm,\n// or Schwartzian transform.\n// Elements are arranged from from lowest to highest.\n\n// sortOn :: Ord b => (a -> b) -> [a] -> [a]\nconst sortOn = (f, xs) => {\n    // Functions and matching bools derived from argument f\n    // which may be a single key function, or a list of key functions\n    // each of which may or may not be followed by a direction bool.\n    const fsbs = unzip(\n            flatten([f])\n            .reduceRight((a, x) =>\n                ('boolean' === typeof x) ? {\n                    asc: x,\n                    fbs: a.fbs\n                } : {\n                    asc: true,\n                    fbs: [\n                        [x, a.asc]\n                    ].concat(a.fbs)\n                }, {\n                    asc: true,\n                    fbs: []\n                })\n            .fbs\n        ),\n        [fs, bs] = [fsbs[0], fsbs[1]],\n        iLast = fs.length;\n    // decorate-sort-undecorate\n    return sortBy(mappendComparing_(\n            // functions that access pre-calculated values\n            // by position in the decorated ('Schwartzian')\n            // version of xs\n            zip(fs.map((_, i) => x => x[i]), bs)\n        ), xs.map( // xs decorated with precalculated values\n            x => fs.reduceRight(\n                (a, g) => [g(x)].concat(a), [\n                    x\n                ])))\n        .map(x => x[iLast]); // undecorated version of data, post sort.\n};",
  "span": "// span, applied to a predicate p and a list xs, returns a tuple of xs of \n// elements that satisfy p and second element is the remainder of the list:\n//\n// > span (< 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])\n// > span (< 9) [1,2,3] == ([1,2,3],[])\n// > span (< 0) [1,2,3] == ([],[1,2,3])\n//\n// span p xs is equivalent to (takeWhile p xs, dropWhile p xs) \n\n// span :: (a -> Bool) -> [a] -> ([a], [a])\nconst span = (p, xs) =>\n    splitAt(until(\n        i => !p(xs[i]),\n        i => 1 + i,\n        0\n    ), xs);",
  "splitArrow": "// Compose a function (from a tuple to a tuple), \n// (with separate transformations for fst and snd)\n\n// splitArrow (***) :: (a -> b) -> (c -> d) -> ((a, c) -> (b, d))\nconst splitArrow = (f, g) => tpl => Tuple(f(tpl[0]), g(tpl[1]));",
  "splitAt": "// splitAt :: Int -> [a] -> ([a], [a])\nconst splitAt = (n, xs) => Tuple(xs.slice(0, n), xs.slice(n));",
  "splitBy": "// Splitting not on a delimiter, but wherever the relationship\n// between consecutive terms matches a binary predicate\n\n// splitBy :: (a -> a -> Bool) -> [a] -> [[a]]\n// splitBy :: (String -> String -> Bool) -> String -> [String]\nconst splitBy = (p, xs) =>\n    (xs.length < 2) ? [xs] : (() => {\n        const\n            bln = 'string' === typeof xs,\n            ys = bln ? xs.split('') : xs,\n            h = ys[0],\n            parts = ys.slice(1)\n            .reduce(([acc, active, prev], x) =>\n                p(prev, x) ? (\n                    [acc.concat([active]), [x], x]\n                ) : [acc, active.concat(x), x], [\n                    [],\n                    [h],\n                    h\n                ]);\n        return (bln ? (\n            ps => ps.map(cs => ''.concat.apply('', cs))\n        ) : x => x)(parts[0].concat([parts[1]]));\n    })();",
  "splitEvery": "// splitEvery :: Int -> [a] -> [[a]]\nconst splitEvery = (n, xs) => {\n    if (xs.length <= n) return [xs];\n    const [h, t] = [xs.slice(0, n), xs.slice(n)];\n    return [h].concat(splitEvery(n, t));\n};",
  "splitFileName": "// Split a filename into directory and file. combine is the inverse.\n\n// splitFileName :: FilePath -> (String, String)\nconst splitFileName = strPath =>\n    ('' !== strPath) ? (\n         ('/' !== strPath[strPath.length - 1]) ? (() => {\n            const\n                xs = strPath.split('/'),\n                stem = xs.slice(0, -1);\n            return stem.length > 0 ? (\n                Tuple(stem.join('/') + '/', xs.slice(-1)[0])\n            ) : Tuple('./', xs.slice(-1)[0]);\n        })() : Tuple(strPath, '')\n    ) : Tuple('./', '');",
  "splitOn": "// splitOn(\"\\r\\n\", \"a\\r\\nb\\r\\nd\\r\\ne\") //--> [\"a\", \"b\", \"d\", \"e\"]\n// splitOn(\"aaa\", \"aaaXaaaXaaaXaaa\") //--> [\"\", \"X\", \"X\", \"X\", \"\"]\n// splitOn(\"x\", \"x\") //--> [\"\", \"\"]\n// splitOn([3, 1], [1,2,3,1,2,3,1,2,3]) //--> [[1,2],[2],[2,3]]\n\n// splitOn :: [a] -> [a] -> [[a]]\n// splitOn :: String -> String -> [String]\nconst splitOn = (pat, src) =>\n    /* A list of the strings delimited by\n       instances of a given pattern in s. */\n    ('string' === typeof src) ? (\n        src.split(pat)\n    ) : (() => {\n        const\n            lng = pat.length,\n            tpl = foldl((a, i) =>\n                Tuple(\n                    fst(a).concat([src.slice(snd(a), i)]),\n                    lng + i\n                ), Tuple([], 0),\n                findIndices(matching(pat), src)\n            );\n        return fst(tpl).concat([src.slice(snd(tpl))]);\n    })();",
  "splitRegex": "// splitRegex :: Regex -> String -> [String]\nconst splitRegex = (needle, haystack) =>\n    haystack.split(needle);",
  "sqrt": "// sqrt :: Num -> Num\nconst sqrt = n =>\n    (0 <= n) ? Math.sqrt(n) : undefined;",
  "sqrtLR": "// sqrtLR :: Num -> Either String Num\nconst sqrtLR = n =>\n    0 > n ? (\n        Left('Square root of negative number: ' + n)\n    ) : Right(Math.sqrt(n));",
  "sqrtMay": "// sqrtMay :: Num -> Maybe Num\nconst sqrtMay = n =>\n    0 > n ? (\n        Nothing()\n    ) : Just(Math.sqrt(n));",
  "strip": "// strip :: String -> String\nconst strip = s => s.trim();",
  "stripEnd": "// stripEnd :: String -> String\nconst stripEnd = s => dropWhileEnd(isSpace, s);",
  "stripPrefix": "// stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]\nconst stripPrefix = (pfx, s) => {\n    const\n        blnString = 'string' === typeof pfx,\n        [xs, ys] = blnString ? (\n            [pfx.split(''), s.split('')]\n        ) : [pfx, s];\n    const\n        sp_ = (xs, ys) => 0 === xs.length ? (\n            Just(blnString ? ys.join('') : ys)\n        ) : (0 === ys.length || xs[0] !== ys[0]) ? (\n            Nothing()\n        ) : sp_(xs.slice(1), ys.slice(1));\n    return sp_(xs, ys);\n};",
  "stripStart": "// stripStart :: String -> String\nconst stripStart = s => dropWhile(isSpace, s);",
  "subsequences": "// subsequences([1,2,3]) -> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n// subsequences('abc') -> [\"\",\"a\",\"b\",\"ab\",\"c\",\"ac\",\"bc\",\"abc\"]\n\n// subsequences :: [a] -> [[a]]\n// subsequences :: String -> [String]\nconst subsequences = xs => {\n    const\n        cons = (x, xs) => [x].concat(xs),\n        // nonEmptySubsequences :: [a] -> [[a]]\n        nonEmptySubsequences = xxs => {\n            if (xxs.length < 1) return [];\n            const [x, xs] = [xxs[0], xxs.slice(1)];\n            const f = (r, ys) => cons(ys, cons(cons(x, ys), r));\n            return cons([x], nonEmptySubsequences(xs)\n                .reduceRight(f, []));\n        };\n    return ('string' === typeof xs) ? (\n        cons('', nonEmptySubsequences(xs.split(''))\n            .map(x => ''.concat.apply('', x))) // map(concat)\n    ) : cons([], nonEmptySubsequences(xs));\n};",
  "subsets": "// subsets :: [a] -> [[a]]\nconst subsets = xs => {\n    const go = ys =>\n        0 < ys.length ? (() => {\n            const\n                h = ys[0],\n                zs = go(ys.slice(1));\n            return zs.concat(\n                zs.map(z => [h].concat(z))\n            );\n        })() : [\n            []\n        ];\n    return go(xs);\n};",
  "subtract": "// subtract :: Num -> Num -> Num\nconst subtract = (x, y) => y - x;",
  "succ": "// succ :: Enum a => a -> a\nconst succ = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mx] = [x, maxBound(x)].map(fromEnum);\n        return i < mx ? (\n            toEnum(x)(1 + i)\n        ) : Error('succ :: enum out of range.')\n    })() : x < Number.MAX_SAFE_INTEGER ? (\n        1 + x\n    ) : Error('succ :: Num out of range.')\n};",
  "succMay": "// succMay :: Enum a => a -> Maybe a\nconst succMay = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mx] = [x, maxBound(x)].map(fromEnum);\n        return i < mx ? (\n            Just(toEnum(x)(1 + i))\n        ) : Nothing()\n    })() : x < Number.MAX_SAFE_INTEGER ? (\n        Just(1 + x)\n    ) : Nothing()\n};",
  "sum": "// sum :: [Num] -> Num\nconst sum = xs => xs.reduce((a, x) => a + x, 0);",
  "swap": "// swap :: (a, b) -> (b, a)\nconst swap = ab =>\n    Tuple(ab[1], ab[0]);",
  "tail": "// tail :: [a] -> [a]\nconst tail = xs => 0 < xs.length ? xs.slice(1) : [];",
  "tailMay": "// tailMay :: [a] -> Maybe [a]\nconst tailMay = xs =>\n    0 < xs.length ? (\n        Just(xs.slice(1))\n    ) : Nothing();",
  "tails": "// tails :: [a] -> [[a]]\nconst tails = xs => {\n    const\n        es = ('string' === typeof xs) ? (\n            xs.split('')\n        ) : xs;\n    return es.map((_, i) => es.slice(i))\n        .concat([\n            []\n        ]);\n};",
  "take": "// take :: Int -> [a] -> [a]\n// take :: Int -> String -> String\nconst take = (n, xs) =>\n    'GeneratorFunction' !== xs.constructor.constructor.name ? (\n        xs.slice(0, n)\n    ) : [].concat.apply([], Array.from({\n        length: n\n    }, () => {\n        const x = xs.next();\n        return x.done ? [] : [x.value];\n    }));",
  "takeAround": "// takeAround :: (a -> Bool) -> [a] -> [a]\nconst takeAround = (p, xs) => {\n    const ys = takeWhile(p, xs);\n    return ys.length < xs.length ? (\n        ys.concat(takeWhileR(p, xs))\n    ) : ys;\n};",
  "takeBaseName": "// takeBaseName :: FilePath -> String\nconst takeBaseName = strPath =>\n  ('' !== strPath) ? (\n    ('/' !== strPath[strPath.length - 1]) ? (() => {\n      const fn = strPath.split('/').slice(-1)[0];\n      return fn.includes('.') ? (\n        fn.split('.').slice(0, -1).join('.')\n      ) : fn;\n    })() : ''\n  ) : '';",
  "takeCycle": "// First n members of an infinite cycle of xs\n\n// takeCycle :: Int -> [a] -> [a]\nconst takeCycle = (n, xs) => {\n    const lng = xs.length;\n    return (\n            n <= xs ? (\n                xs\n            ) : concat(\n                replicate(\n                    Math.ceil(n / lng),\n                    xs\n                )\n            )\n        )\n        .slice(0, n)\n};",
  "takeDirectory": "// takeDirectory :: FilePath -> FilePath\nconst takeDirectory = strPath =>\n    ('' !== strPath) ? (() => {\n        const xs = (strPath.split('/'))\n            .slice(0, -1);\n        return xs.length > 0 ? (\n            xs.join('/')\n        ) : '.';\n    })() : '.';",
  "takeDropCycle": "// take N Members of an infinite cycle of xs, starting from index I\n\n// takeDropCycle :: Int -> [a] -> [a]\nconst takeDropCycle = (n, i, xs) => {\n    const\n        lng = xs.length,\n        m = n + i;\n    return drop(i,\n        take(m,\n            (lng >= m ? xs : concat(replicate(Math.ceil(m / lng), xs)))\n        )\n    );\n};",
  "takeExtension": "// takeExtension :: FilePath -> String\nconst takeExtension = strPath => {\n    const\n        xs = strPath.split('.'),\n        lng = xs.length;\n    return 1 < lng ? (\n        '.' + xs[lng - 1]\n    ) : '';\n};",
  "takeFileName": "// takeFileName :: FilePath -> FilePath\nconst takeFileName = strPath =>\n    '' !== strPath ? (\n        ('/' !== strPath[strPath.length - 1]) ? (\n            strPath.split('/')\n            .slice(-1)[0]\n        ) : ''\n    ) : '';",
  "takeFromThenTo": "// takeFromThenTo :: Int -> Int -> Int -> [a] -> [a]\nconst takeFromThenTo = (a, b, z, xs) => {\n    const ixs = enumFromThenTo(a, b, z);\n    return 'GeneratorFunction' !== xs.constructor.constructor.name ? (\n        map(i => xs[i], ixs)\n    ) : (() => {\n        const g = zipGen(enumFrom(0), take(z, xs));\n        return concatMap(i => {\n            const mb = index(g)(i);\n            return mb.Nothing ? [] : [mb.Just];\n        }, ixs);\n    })();\n};",
  "takeIterate": "// takeIterate n f x == [x, f x, f (f x), ...]\n\n// takeIterate :: Int -> (a -> a) -> a -> [a]\nconst takeIterate = (n, f, x) =>\n    snd(mapAccumL((a, _, i) => {\n        const v = 0 !== i ? f(a) : x;\n        return [v, v];\n    }, x, Array.from({\n        length: n\n    })));",
  "takeWhile": "// takeWhile :: (a -> Bool) -> [a] -> [a]\n// takeWhile :: (Char -> Bool) -> String -> String\nconst takeWhile = (p, xs) =>\n    xs.constructor.constructor.name !==\n    'GeneratorFunction' ? (() => {\n        const lng = xs.length;\n        return 0 < lng ? xs.slice(\n            0,\n            until(\n                i => lng === i || !p(xs[i]),\n                i => 1 + i,\n                0\n            )\n        ) : [];\n    })() : takeWhileGen(p, xs);",
  "takeWhileGen": "// takeWhileGen :: (a -> Bool) -> Gen [a] -> [a]\nconst takeWhileGen = (p, xs) => {\n    const ys = [];\n    let\n        nxt = xs.next(),\n        v = nxt.value;\n    while (!nxt.done && p(v)) {\n        ys.push(v);\n        nxt = xs.next();\n        v = nxt.value\n    }\n    return ys;\n};",
  "takeWhileR": "// takeWhileR :: (a -> Bool) -> [a] -> [a]\nconst takeWhileR = (p, xs) => {\n    let i = xs.length;\n    while (i-- && p(xs[i])) {}\n    return xs.slice(i + 1);\n};",
  "tempFilePath": "// File name template to temporary path\n// Random digit sequence inserted between template base and extension\n\n// tempFilePath :: String -> IO FilePath\nconst tempFilePath = template =>\n  ObjC.unwrap($.NSTemporaryDirectory()) +\n    takeBaseName(template) + Math.random()\n    .toString()\n    .substring(3) + takeExtension(template);",
  "then": "// then (>>) :: Monad m => m a -> m b -> m b\nconst then = (ma, mb) =>\n    (Array.isArray(ma) ? (\n        thenList\n    ) : isMaybe(ma) ? (\n        thenMay\n    ) : thenIO)(\n        ...[ma, mb]\n    )",
  "thenIO": "// thenIO (>>) :: IO a -> IO b -> IO b\nconst thenIO = (ma, mb) => mb;",
  "thenList": "// thenList (>>) :: [a] -> [b] -> [b]\nconst thenList = (xs, ys) =>\n    concatMap(_ => ys, xs);",
  "thenMay": "// thenMay (>>) :: Maybe a -> Maybe b -> Maybe b\nconst thenMay = (mbx, mby) =>\n    mbx.Nothing ? mbx : mby;",
  "toEnum": "// The first argument is a sample of the type\n// allowing the function to make the right mapping\n\n// toEnum :: a -> Int -> a\nconst toEnum = e => x =>\n    ({\n        'number': Number,\n        'string': String.fromCodePoint,\n        'boolean': Boolean,\n        'object': v => e.min + v\n    } [typeof e])(x);",
  "toListTree": "// toListTree :: Tree a -> [a]\nconst toListTree = tree => {\n    const go = x => [\n      x.root,\n      ...[].concat.apply([], x.nest.map(go))\n    ];\n    return go(tree);\n};",
  "toLower": "// toLower :: String -> String\nconst toLower = s => s.toLocaleLowerCase();",
  "toRatio": "// toRatio :: Real -> Ratio\nconst toRatio = n =>\n    approxRatio(1e-12, n);",
  "toSentence": "// Sentence case - initial string capitalized and rest lowercase\n\n// toSentence :: String -> String\nconst toSentence = s =>\n    (0 < s.length) ? (\n        s[0].toUpperCase() + s.slice(1)\n        .toLowerCase()\n    ) : s;",
  "toTitle": "// NB this does not model any regional or cultural conventions.\n// It simply simply capitalizes the first character of each word.\n\n// toTitle :: String -> String\nconst toTitle = s =>\n    regexMatches(/(\\w)(\\w*)(\\b[\\W]*|$)/g, s)\n    .map(ms => ms[1].toUpperCase() + ms[2].toLowerCase() + ms[3])\n    .join('');",
  "toUpper": "// toUpper :: String -> String\nconst toUpper = s => s.toLocaleUpperCase();",
  "transpose": "// If some of the rows are shorter than the following rows, \n// their elements are skipped:\n// > transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\n\n// transpose :: [[a]] -> [[a]]\nconst transpose = xss => {\n    const go = xss =>\n        0 < xss.length ? (() => {\n            const\n                h = xss[0],\n                t = xss.slice(1);\n            return 0 < h.length ? (\n                [\n                    [h[0]].concat(t.reduce(\n                        (a, xs) => a.concat(\n                            0 < xs.length ? (\n                                [xs[0]]\n                            ) : []\n                        ),\n                        []\n                    ))\n                ].concat(go([h.slice(1)].concat(\n                    t.map(xs => xs.slice(1))\n                )))\n            ) : go(t);\n        })() : [];\n    return go(xss);\n};",
  "traverse": "// traverse :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)\nconst traverse = (f, tx) => {\n    const t = tx.type;\n    return (\n        undefined !== t ? (\n            'Either' === t ? (\n                traverseLR\n            ) : 'Maybe' === t ? (\n                traverseMay\n            ) : 'Node' === t ? (\n                traverseTree\n            ) : 'Tuple' === t ? (\n                traverseTuple\n            ) : traverseList\n        ) : traverseList\n    )(f, tx)\n};",
  "traverseLR": "// traverseLR :: Applicative f => (t -> f b) -> Either a t -> f (Either a b)\nconst traverseLR = (f, lr) =>\n    undefined !== lr.Left ? (\n        fmap(Right, f(lr.Right))\n    ) : [lr]; //??",
  "traverseList": "// - Map each element of a structure to an action,\n// - evaluate these actions from left to right,\n// - and collect the results.\n\n//    traverse f = List.foldr cons_f (pure [])\n//      where cons_f x ys = liftA2 (:) (f x) ys\n\n// traverseList :: (Applicative f) => (a -> f b) -> [a] -> f [b]\nconst traverseList = (f, xs) => {\n    const lng = xs.length;\n    return 0 < lng ? (() => {\n        const\n            vLast = f(xs[lng - 1]),\n            t = vLast.type || 'List';\n        return xs.slice(0, -1).reduceRight(\n            (ys, x) => liftA2(cons, f(x), ys),\n            liftA2(cons, vLast, pureT(t, []))\n        );\n    })() : [[]];\n};",
  "traverseMay": "// traverseMay :: Applicative f => (t -> f a) -> Maybe t -> f (Maybe a)\nconst traverseMay = (f, mb) =>\n    mb.Nothing ? (\n        [mb]\n    ) : fmap(Just, f(mb.Just));",
  "traverseTree": "// traverse f (Node x ts) = liftA2 Node (f x) (traverse (traverse f) ts)\nconst traverseTree = (f, node) => {\n    const go = x =>\n        liftA2(\n            Node, f(x.root),\n            traverseList(go, x.nest)\n        );\n    return go(node);\n};",
  "traverseTuple": "// traverseTuple :: Functor f => (t -> f b) -> (a, t) -> f (a, b)\nconst traverseTuple = (f, tpl) =>\n    fmap(curry(Tuple)(tpl[0]), f(tpl[1]));",
  "treeLeaves": "// treeLeaves :: Tree -> [Tree]\nconst treeLeaves = tree => {\n  const nest = tree.nest;\n  return (0 < nest.length) ? (\n    concatMap(treeLeaves, nest)\n  ) : [tree];\n};",
  "treeMatches": "// A list of all nodes in the tree which match \n// a predicate p.\n// For the first match only, see findTree.\n\n// treeMatches :: (a -> Bool) -> Tree a -> [Tree a]\nconst treeMatches = (p, tree) => {\n    const go = node =>\n        p(node.root) ? (\n            [node]\n        ) : concatMap(go, node.nest);\n    return go(tree);\n};",
  "truncate": "// truncate :: Num -> Int\nconst truncate = x =>\n    'Ratio' === x.type ? (\n        properFracRatio(x)[0]\n    ) : properFraction(x)[0];",
  "tupleFromList": "// tupleFromList :: [a] -> (a, a ...)\nconst tupleFromList = xs =>\n    TupleN(...xs);",
  "typeName": "// typeName :: a -> String\nconst typeName = v => {\n    const t = typeof v;\n    return 'object' === t ? (\n        Array.isArray(v) ? (\n            'List'\n        ) : null !== v ? (\n            v.type || 'Dict'\n        ) : 'Bottom'\n    ) : {\n        'boolean': 'Bool',\n        'number' : 'Num',\n        'string' : 'String'\n    }[t] || 'Bottom';\n};",
  "unQuoted": "// unQuoted :: String -> String\nconst unQuoted = s =>\n    dropAround(x => 34 === x.codePointAt(0), s);",
  "uncons": "// uncons :: [a] -> Maybe (a, [a])\nconst uncons = xs => {\n    const lng = length(xs);\n    return (0 < lng) ? (\n        lng < Infinity ? (\n            Just(Tuple(xs[0], xs.slice(1))) // Finite list\n        ) : (() => {\n            const nxt = take(1, xs);\n            return 0 < nxt.length ? (\n                Just(Tuple(nxt[0], xs))\n            ) : Nothing();\n        })() // Lazy generator\n    ) : Nothing();\n};",
  "uncurry": "// Given a curried/default function, returns an\n// equivalent function on a tuple or list pair.\n\n// uncurry :: (a -> b -> c) -> ((a, b) -> c)\nconst uncurry = f => args =>\n    1 < f.length ? (\n        f(args[0], args[1])\n    ) : f(args[0])(args[1]);",
  "unfoldForest": "// | Build a forest from a list of seed values\n\n// unfoldForest :: (b -> (a, [b])) -> [b] -> [Tree]\nconst unfoldForest = (f, xs) =>\n    xs.map(b => unfoldTree(f, b));",
  "unfoldTree": "// | Build a tree from a seed value\n\n// unfoldTree :: (b -> (a, [b])) -> b -> Tree a\nconst unfoldTree = (f, b) => {\n    const tpl = f(b);\n    return Node(tpl[0], unfoldForest(f, tpl[1]));\n};",
  "unfoldl": "// unfoldl(x => 0 !== x ? Just([x - 1, x]) : Nothing(), 10);\n// --> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// unfoldl :: (b -> Maybe (b, a)) -> b -> [a]\nconst unfoldl = (f, v) => {\n    let\n        xr = [v, v],\n        xs = [];\n    while (true) {\n        const mb = f(xr[0]);\n        if (mb.Nothing) {\n            return xs\n        } else {\n            xr = mb.Just;\n            xs = [xr[1]].concat(xs);\n        }\n    }\n};",
  "unfoldr": "// The 'unfoldr' function is a *dual* to 'foldr': while 'foldr'\n// reduces a list to a summary value, 'unfoldr' builds a list from\n// a seed value.  The function takes the element and returns 'Nothing'\n// if it is done producing the list or returns 'Just' @(a,b)@, in which\n// case, @a@ is a prepended to the list and @b@ is used as the next\n// element in a recursive call.\n//\n// unfoldr(x => 0 !== x ? Just([x, x - 1]) : Nothing(), 10);\n// --> [10,9,8,7,6,5,4,3,2,1]\n\n// (x => Maybe [value, remainder] -> initial value -> values\n\n// unfoldr :: (b -> Maybe (a, b)) -> b -> [a]\nconst unfoldr = (f, v) => {\n    let\n        xr = [v, v],\n        xs = [];\n    while (true) {\n        const mb = f(xr[1]);\n        if (mb.Nothing) {\n            return xs\n        } else {\n            xr = mb.Just;\n            xs.push(xr[0])\n        }\n    }\n};",
  "union": "// union :: [a] -> [a] -> [a]\nconst union = (xs, ys) =>\n  unionBy((a, b) => a === b, xs, ys);",
  "unionBy": "// unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst unionBy = (fnEq, xs, ys) => {\n    const sx = nubBy(fnEq, xs);\n    return sx.concat(\n        sx.reduce(\n            (a, x) => deleteBy(fnEq, x, a),\n            nubBy(fnEq, ys)\n        )\n    );\n};",
  "unionSet": "// unionSet :: Ord a => Set a -> Set a -> Set a\nconst unionSet = (s, s1) =>\n    Array.from(s1.values())\n    .reduce(\n        (a, x) => (a.add(x), a),\n        new Set(s)\n    );",
  "unlines": "// unlines :: [String] -> String\nconst unlines = xs => xs.join('\\n');",
  "unsnoc": "// If the list is empty returns Nothing, otherwise returns \n// Just the init and the last.\n\n// unsnoc :: [a] -> Maybe ([a], a)\nconst unsnoc = xs =>\n    (0 < xs.length) ? (\n        Just(Tuple(xs.slice(0, -1), xs.slice(-1)[0]))\n    ) : Nothing();",
  "until": "// until :: (a -> Bool) -> (a -> a) -> a -> a\nconst until = (p, f, x) => {\n    let v = x;\n    while (!p(v)) v = f(v);\n    return v;\n};",
  "unwords": "// unwords :: [String] -> String\nconst unwords = xs => xs.join(' ');",
  "unwrap": "// unwrap :: NSObject -> a\nconst unwrap = ObjC.unwrap;",
  "unzip": "// unzip :: [(a,b)] -> ([a],[b])\nconst unzip = xys =>\n    xys.reduce(\n        (a, x) => Tuple(...[0, 1].map(\n            i => a[i].concat(x[i])\n        )),\n        Tuple([], [])\n    );",
  "unzip3": "// unzip3 :: [(a,b,c)] -> ([a],[b],[c])\nconst unzip3 = xyzs =>\n    xyzs.reduce(\n        (a, x) => TupleN.apply(null, [0, 1, 2].map(\n            i => a[i].concat(x[i])\n        )),\n        TupleN([], [], [])\n    );",
  "unzip4": "// unzip4 :: [(a,b,c,d)] -> ([a],[b],[c],[d])\nconst unzip4 = wxyzs =>\n    wxyzs.reduce(\n        (a, x) => TupleN.apply(null, [0, 1, 2, 3].map(\n            i => a[i].concat(x[i])\n        )),\n        TupleN([], [], [], [])\n    );",
  "unzipN": "// unzipN :: [(a,b,...)] -> ([a],[b],...)\nconst unzipN = tpls =>\n    TupleN(...tpls.reduce(\n        (a, tpl) => a.map(\n            (x, i) => x.concat(tpl[i])\n        ),\n        replicate(\n            0 < tpls.length ? (\n                tpls[0].length\n            ) : 0, []\n        )\n    ));",
  "variance": "// variance :: [Num] -> Num\nconst variance = xs => {\n    const\n        lng = xs.length,\n        mean = xs.reduce((a, b) => a + b, 0) / lng;\n    return xs.reduce(\n        (a, b) => a + Math.pow(b - mean, 2),\n        0\n    ) / (lng - 1);\n};",
  "words": "// words :: String -> [String]\nconst words = s => s.split(/\\s+/);",
  "wrap": "// wrap :: a -> NSObject\nconst wrap = ObjC.wrap;",
  "writeFile": "// writeFile :: FilePath -> String -> IO ()\nconst writeFile = (strPath, strText) =>\n    $.NSString.alloc.initWithUTF8String(strText)\n    .writeToFileAtomicallyEncodingError(\n        $(strPath)\n        .stringByStandardizingPath, false,\n        $.NSUTF8StringEncoding, null\n    );",
  "writeFileLR": "// writeFileLR :: FilePath -> Either String IO FilePath\nconst writeFileLR = (strPath, strText) => {\n    const\n        e = $(),\n        fp = $(strPath)\n        .stringByStandardizingPath;\n    return $.NSString.alloc.initWithUTF8String(strText)\n        .writeToFileAtomicallyEncodingError(\n            fp, false,\n            $.NSUTF8StringEncoding, e\n        ) ? (\n            Right(ObjC.unwrap(fp))\n        ) : Left(ObjC.unwrap(e.localizedDescription));\n};",
  "writeTempFile": "// File name template -> string data -> IO temporary path\n\n// writeTempFile :: String -> String -> IO FilePath\nconst writeTempFile = (template, txt) => {\n    const\n        strPath = ObjC.unwrap($.NSTemporaryDirectory()) +\n        takeBaseName(template) + Math.random()\n        .toString()\n        .substring(3) + takeExtension(template);\n    return (writeFile(strPath, txt), strPath);\n};",
  "zip": "// Use of `take` and `length` here allows for zipping with non-finite \n// lists - i.e. generators like cycle, repeat, iterate.\n\n// zip :: [a] -> [b] -> [(a, b)]\nconst zip = (xs, ys) => {\n    const lng = Math.min(length(xs), length(ys));\n    return Infinity !== lng ? (() => {\n        const bs = take(lng, ys);\n        return take(lng, xs).map((x, i) => Tuple(x, bs[i]));\n    })() : zipGen(xs, ys);\n};",
  "zip3": "// zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]\nconst zip3 = (xs, ys, zs) =>\n    xs.slice(0, Math.min(length(xs), length(ys), length(zs)))\n    .map((x, i) => TupleN(x, ys[i], zs[i]));",
  "zip4": "// zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]\nconst zip4 = (ws, xs, ys, zs) =>\n    ws.slice(0, minimum([ws, xs, ys, zs].map(length)))\n    .map((w, i) => TupleN(w, xs[i], ys[i], zs[i]));",
  "zipGen": "// zipGen :: Gen [a] -> Gen [b] -> Gen [(a, b)]\nconst zipGen = (ga, gb) => {\n    function* go(ma, mb) {\n        let\n            a = ma,\n            b = mb;\n        while(!a.Nothing && !b.Nothing) {\n            let\n                ta = a.Just,\n                tb = b.Just\n            yield(Tuple(fst(ta), fst(tb)));\n            a = uncons(snd(ta));\n            b = uncons(snd(tb));\n        }\n    }\n    return go(uncons(ga), uncons(gb));\n};",
  "zipN": "// zipN :: [a] -> [b] -> ... -> [(a, b ...)]\nfunction zipN() {\n    const args = Array.from(arguments);\n    return 1 < args.length ? map(\n        (x, i) => TupleN(...map(y => y[i], args)),\n        take(\n            Math.min(...map(length, args)),\n            args[0]\n        )\n    ) : args;\n}",
  "zipWith": "// Use of `take` and `length` here allows zipping with non-finite lists\n// i.e. generators like cycle, repeat, iterate.\n\n// zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst zipWith = (f, xs, ys) => {\n    const\n        lng = Math.min(length(xs), length(ys)),\n        as = take(lng, xs),\n        bs = take(lng, ys);\n    return Array.from({\n        length:lng\n    }, (_, i) => f(as[i], bs[i], i));\n};",
  "zipWith3": "// zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]\nconst zipWith3 = (f, xs, ys, zs) =>\n    Array.from({\n        length: Math.min(length(xs), length(ys), length(zs))\n    }, (_, i) => f(xs[i], ys[i], zs[i]));",
  "zipWith4": "// zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]\nconst zipWith4 = (f, ws, xs, ys, zs) =>\n    Array.from({\n        length: minimum([ws, xs, ys, zs].map(length))\n    }, (_, i) => f(ws[i], xs[i], ys[i], zs[i]));",
  "zipWithN": "// zipWithN :: (a -> b -> ... -> c) -> ([a], [b] ...) -> [c]\nfunction zipWithN() {\n    const\n        args = Array.from(arguments),\n        rows = args.slice(1),\n        f = args[0];\n    return 1 < rows.length ? map(\n        i => f(...map(r => r[i], rows)),\n        enumFromTo(\n            0,\n            Math.min(...map(length, rows)) -1,\n        )\n    ) : rows;\n}\n\n// or\n\n// zipWithN :: (a -> b -> ... -> c) -> ([a], [b] ...) -> [c]\n// const zipWithN = (f, tplLists) =>\n//     map(x => f(...Array.from(x)),\n//         zipN(...Array.from(tplLists))\n//     );"
}