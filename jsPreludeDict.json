{
  "Action": "// Action :: (a -> b) -> a -> Action b\nconst Action = f =>\n    // Constructor for an action.\n    x => ({\n        type: 'Action',\n        act: f,\n        arg: x\n    });",
  "Just": "// Just :: a -> Maybe a\nconst Just = x => ({\n    type: 'Maybe',\n    Nothing: false,\n    Just: x\n});",
  "Left": "// Left :: a -> Either a b\nconst Left = x => ({\n    type: 'Either',\n    Left: x\n});",
  "Node": "// Node :: a -> [Tree a] -> Tree a\nconst Node = v =>\n    // Constructor for a Tree node which connects a\n    // value of some kind to a list of zero or\n    // more child trees.\n    xs => ({\n        type: 'Node',\n        root: v,\n        nest: xs || []\n    });",
  "Nothing": "// Nothing :: Maybe a\nconst Nothing = () => ({\n    type: 'Maybe',\n    Nothing: true,\n});",
  "Right": "// Right :: b -> Either a b\nconst Right = x => ({\n    type: 'Either',\n    Right: x\n});",
  "Tuple": "// Tuple (,) :: a -> b -> (a, b)\nconst Tuple = a =>\n    b => ({\n        type: 'Tuple',\n        '0': a,\n        '1': b,\n        length: 2\n    });",
  "Tuple3": "// Tuple3 (,,) :: a -> b -> c -> (a, b, c)\nconst Tuple3 = a => b => c => ({\n  type: 'Tuple3',\n  '0': a,\n  '1': b,\n  '2': c,\n  length: 3\n});",
  "TupleN": "// TupleN :: a -> b ...  -> (a, b ... )\nfunction TupleN() {\n    const\n        args = Array.from(arguments),\n        n = args.length;\n    return 1 < n ? Object.assign(\n        args.reduce((a, x, i) => Object.assign(a, {\n            [i]: x\n        }), {\n            type: 'Tuple' + (2 < n ? n.toString() : ''),\n            length: n\n        })\n    ) : args[0];\n};",
  "abs": "// abs :: Num -> Num\nconst abs = \n// Absolute value of a given number - without the sign.\n  Math.abs;",
  "add": "// add (+) :: Num a => a -> a -> a\nconst add = a =>\n    // Curried addition.\n    b => a + b;",
  "all": "// all :: (a -> Bool) -> [a] -> Bool\nconst all = p =>\n    // True if p(x) holds for every x in xs.\n    xs => xs.every(p);",
  "allTree": "// allTree :: (a -> Bool) -> Tree a -> Bool\nconst allTree = p =>\n    // True if p holds for all nodes of the\n    // tree to which allTree(p) is applied.\n    tree => foldTree(x => xs => p(x) && xs.every(Boolean))(\n        tree\n    );",
  "and": "// and :: [Bool] -> Bool\nconst and = xs =>\n    // True unless any value in xs is false.\n    xs.every(Boolean);",
  "any": "// any :: (a -> Bool) -> [a] -> Bool\nconst any = p =>\n    // True if p(x) holds for at least\n    // one item in xs.\n    xs => xs.some(p);",
  "anyTree": "// anyTree :: (a -> Bool) -> Tree a -> Bool\nconst anyTree = p =>\n    // True if p holds for any node of the\n    // tree to which anyTree(p) is applied.\n    foldTree(x => xs => p(x) || xs.some(Boolean));",
  "ap": "// ap (<*>) :: Monad m => m (a -> b) -> m a -> m b\nconst ap = mf =>\n    // Applies wrapped functions to wrapped values, \n    // for example applying a list of functions to a list of values\n    // or applying Just(f) to Just(x), Right(f) to Right(x), etc\n    mx => {\n        const t = mx.type;\n        return (\n            undefined !== t ? (\n                'Either' === t ? (\n                    apLR\n                ) : 'Maybe' === t ? (\n                    apMay\n                ) : 'Node' === t ? (\n                    apTree\n                ) : 'Tuple' === t ? (\n                    apTuple\n                ) : apList\n            ) : apList\n        )(mf)(mx);\n    };",
  "apFn": "// apFn :: (a -> b -> c) -> (a -> b) -> a -> c\nconst apFn = f =>\n    // Applicative instance for functions.\n    g => x => f(x)(\n        g(x)\n    )",
  "apLR": "// apLR (<*>) :: Either e (a -> b) -> Either e a -> Either e b\nconst apLR = flr =>\n  // Either application of a possible function in Either\n  // to a possible value in Either, or a Left value.\n  liftA2LR(identity)(flr)",
  "apList": "// apList (<*>) :: [(a -> b)] -> [a] -> [b]\nconst apList = fs =>\n    // The sequential application of each of a list\n    // of functions to each of a list of values.\n    xs => fs.flatMap(\n        f => xs.map(f)\n    );",
  "apMay": "// apMay (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\nconst apMay = mf =>\n    // Just an application of Maybe a function to\n    // to Maybe a value, or Nothing.\n    liftA2May(x => x)(mf);",
  "apTree": "// apTree (<*>) :: Tree (a -> b) -> Tree a -> Tree b\nconst apTree = tf =>\n    // A new tree derived by applying each of a tree\n    // of functions to each node value in another tree.\n    liftA2Tree(\n        x => x\n    )(tf)",
  "apTuple": "// apTuple (<*>) :: Monoid m => (m, (a -> b)) -> (m, a) -> (m, b)\nconst apTuple = tpl => \n  liftA2Tuple(x => x)(tpl)",
  "append": "// append (++) :: [a] -> [a] -> [a]\n// append (++) :: String -> String -> String\nconst append = xs =>\n    // A list or string composed by\n    // the concatenation of two others.\n    ys => xs.concat(ys);",
  "appendFile": "// appendFile :: FilePath -> String -> IO Bool\nconst appendFile = fp =>\n    // The file at fp updated with a new string\n    // appended to its existing contents.\n    txt => {\n        const\n            oFullPath = ObjC.wrap(fp)\n            .stringByStandardizingPath,\n            ref = Ref();\n        return $.NSFileManager.defaultManager\n            .fileExistsAtPathIsDirectory(\n                oFullPath\n                .stringByStandardizingPath, ref\n            ) ? (\n                0 === ref[0] ? (() => {\n                    const // Not a directory\n                        oData = ObjC.wrap(txt)\n                        .dataUsingEncoding($.NSUTF8StringEncoding),\n                        h = $.NSFileHandle.fileHandleForWritingAtPath(\n                            oFullPath\n                        );\n                    return (\n                        h.seekToEndOfFile, // Effect, and\n                        h.writeData(oData),\n                        h.closeFile,\n                        true // value.\n                    );\n                })() : false // Text appending to directory is undefined\n            ) : doesDirectoryExist(takeDirectory(ObjC.unwrap(fp))) ? (\n                writeFile(oFullPath)(txt), // Effect, and\n                true // value.\n            ) : false;\n    };",
  "appendFileMay": "// appendFileMay :: FilePath -> String -> Maybe IO FilePath\nconst appendFileMay = strPath =>\n    // Just the fully-expanded file path of \n    // any file at found strPath, after it has been\n    // updated by appending the given string, or \n    // Nothing if no file is found at that path,\n    // or the file is found but can not be updated.\n    txt => {\n        const\n            oFullPath = ObjC.wrap(strPath)\n            .stringByStandardizingPath,\n            strFullPath = ObjC.unwrap(oFullPath),\n            ref = Ref();\n        return $.NSFileManager.defaultManager\n            .fileExistsAtPathIsDirectory(\n                oFullPath\n                .stringByStandardizingPath, ref\n            ) ? (\n                0 === ref[0] ? (() => {\n                    const // Not a directory\n                        oData = ObjC.wrap(txt)\n                        .dataUsingEncoding($.NSUTF8StringEncoding),\n                        h = $.NSFileHandle\n                        .fileHandleForWritingAtPath(oFullPath);\n                    return (\n                        h.seekToEndOfFile, // Effect, and\n                        h.writeData(oData),\n                        h.closeFile, {\n                            Nothing: false,\n                            Just: strFullPath\n                        } // value.\n                    );\n                })() : Nothing()\n                // Text appending to directory is undefined\n            ) : doesDirectoryExist(takeDirectory(strFullPath)) ? (\n                writeFile(oFullPath)(txt), // Effect, and\n                Just(strFullPath) // value\n            ) : Nothing();\n    };",
  "appendGen": "// appendGen (++) :: Gen [a] -> Gen [a] -> Gen [a]\nconst appendGen = xs =>\n    // A new generator composed from the \n    // concatenation of two existing generators.\n    function* (ys) {\n        for (let vs of [xs, ys]) {\n            let nxt = vs.next()\n            while (!nxt.done) {\n                yield nxt.value\n                nxt = vs.next()\n            }\n        }\n    };",
  "apply": "// apply ($) :: (a -> b) -> a -> b\nconst apply = f =>\n    // Application operator.\n    x => f(x);",
  "applyN": "// applyN :: Int -> (a -> a) -> a -> a\nconst applyN = n =>\n    // The value of n applications of f to x.\n    // (Church numeral n)\n    f => x => Array.from({\n            length: n\n        }, () => f)\n        .reduce((a, g) => g(a), x);",
  "approxRatio": "// approxRatio :: Float -> Float -> Ratio\nconst approxRatio = epsilon =>\n    // An ratio derived by approximation\n    // (at granularity epsilon) to the float n.\n    n => {\n        const\n            gcde = (e, x, y) => {\n                const _gcd = (a, b) => (b < e ? a : _gcd(b, a % b));\n                return _gcd(abs(x), abs(y));\n            },\n            c = gcde(Boolean(epsilon) ? epsilon : (1 / 10000), 1, abs(n)),\n            r = ratio(quot(abs(n))(c))(quot(1, c));\n        return {\n            type: 'Ratio',\n            n: r.n * signum(n),\n            d: r.d\n        };\n    };",
  "argvLength": "// argvLength :: Function -> Int\nconst argvLength = f =>\n    f.length;",
  "assocs": "// assocs :: Map k a -> [(k, a)]\nconst assocs = m =>\n    Object.entries(m).map(\n        kv => Tuple(...kv)\n    );",
  "base64decode": "// base64decode :: String -> String\nconst base64decode = s =>\n    ObjC.unwrap(\n        $.NSString.alloc.initWithDataEncoding(\n            $.NSData.alloc.initWithBase64EncodedStringOptions(\n                s, 0\n            ),\n            $.NSUTF8StringEncoding\n        )\n    );",
  "base64encode": "// base64encode :: String -> String\nconst base64encode = s =>\n    ObjC.unwrap(\n        $.NSString.stringWithString(s)\n        .dataUsingEncoding(\n            $.NSUTF8StringEncoding\n        ).base64EncodedStringWithOptions(0)\n    );",
  "bind": "// bind (>>=) :: Monad m => m a -> (a -> m b) -> m b\nconst bind = m =>\n    mf => (Array.isArray(m) ? (\n        bindList\n    ) : (() => {\n        const t = m.type;\n        return 'Either' === t ? (\n            bindLR\n        ) : 'Maybe' === t ? (\n            bindMay\n        ) : 'Tuple' === t ? (\n            bindTuple\n        ) : ('function' === typeof m) ? (\n            bindFn\n        ) : undefined;\n    })()(m)(mf));",
  "bindFn": "// bindFn (>>=) :: (a -> b) -> (b -> a -> c) -> a -> c\nconst bindFn = f =>\n    // Binary operator applied over f x and x.\n    bop => x => bop(f(x))(x);",
  "bindLR": "// bindLR (>>=) :: Either a -> \n// (a -> Either b) -> Either b\nconst bindLR = m =>\n    mf => undefined !== m.Left ? (\n        m\n    ) : mf(m.Right);",
  "bindList": "// bindList (>>=) :: [a] -> (a -> [b]) -> [b]\nconst bindList = xs =>\n    mf => xs.flatMap(mf);",
  "bindMay": "// bindMay (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\nconst bindMay = mb =>\n    mf => mb.Nothing ? (\n        mb\n    ) : mf(mb.Just);",
  "bindTuple": "// bindTuple (>>=) :: Monoid a => (a, a) -> (a -> (a, b)) -> (a, b)\nconst bindTuple = tpl =>\n    f => {\n        const t2 = f(tpl[1]);\n        return Tuple(mappend(tpl[0])(t2[0]))(\n            t2[1]\n        );\n    };",
  "bool": "// bool :: a -> a -> Bool -> a\nconst bool = f =>\n    t => p => p ? t : f;",
  "break": "// break :: (a -> Bool) -> [a] -> ([a], [a])\nconst break_ = p =>\n    xs => {\n        for (var i = 0, lng = xs.length;\n            (i < lng) && !p(xs[i]); i++) {};\n        return Tuple(xs.slice(0, i))(\n            xs.slice(i)\n        );\n    };\n",
  "breakOn": "// breakOn :: String -> String -> (String, String)\nconst breakOn = pat =>\n    // Needle -> Haystack -> (prefix before match, match + rest)\n    src => 0 < pat.length ? (() => {\n        const xs = src.split(pat);\n        return 1 < xs.length ? Tuple(\n            xs[0], src.slice(xs[0].length)\n        ) : Tuple(src)('');\n    })() : undefined;",
  "breakOnAll": "// breakOnAll :: String -> String -> [(String, String)]\nconst breakOnAll = pat =>\n    src => '' !== pat ? (\n        src.split(pat)\n        .reduce((a, x, i, xs) =>\n            0 < i ? (\n                a.concat([\n                    Tuple(xs.slice(0, i).join(pat))(\n                        pat + xs.slice(i).join(pat)\n                    )\n                ])\n            ) : a, [])\n    ) : undefined;",
  "breakOnMay": "// Needle -> Haystack -> maybe (prefix before match, match + rest)\n\n// breakOnMay :: String -> String -> Maybe (String, String)\nconst breakOnMay = pat =>\n    src => Boolean(pat) ? (() => {\n        const xs = src.split(pat);\n        return Just(0 < xs.length ? Tuple(\n            xs[0], src.slice(xs[0].length)\n        ) : Tuple(src)(''));\n    })() : Nothing();",
  "bulleted": "// bulleted :: String -> String -> String\nconst bulleted = strTab =>\n    s => s.split(/[\\r\\n]/).map(\n        x => '' !== x ? strTab + '- ' + x : x\n    ).join('\\n');",
  "cartesianProduct": "// cartesianProduct :: [a] -> [b] -> [(a, b)]\nconst cartesianProduct = xs =>\n    ys => xs.flatMap(\n        x => ys.flatMap(Tuple(x))\n    );",
  "caseOf": "// caseOf :: [(a -> Bool, b)] -> b -> a ->  b\nconst caseOf = pvs =>\n    // List of (Predicate, value) tuples -> Default value \n    //         -> Value to test -> Output value\n    otherwise => x => {\n        const mb = pvs.reduce((a, pv) =>\n            a.Nothing ? (\n                pv[0](x) ? Just(pv[1]) : a\n            ) : a, Nothing());\n        return mb.Nothing ? otherwise : mb.Just;\n    };",
  "catMaybes": "// catMaybes :: [Maybe a] -> [a]\nconst catMaybes = mbs =>\n    mbs.flatMap(m => m.Nothing ? [] : [m.Just]);",
  "ceiling": "// The least integer not less than x\n\n// ceiling :: Num -> Int\nconst ceiling = x => {\n    const\n      nr = properFraction(x),\n      n = nr[0]\n    return 0 < nr[1] ? 1 + n : n;\n};",
  "center": "// center :: Int -> Char -> String -> String\nconst center = n =>\n    // Size of space -> filler Char -> String -> Centered String\n    c => s => {\n        const gap = n - s.length;\n        return 0 < gap ? (() => {\n            const pre = c.repeat(Math.floor(gap / 2));\n            return pre + s + pre + c.repeat(gap % 2);\n        })() : s\n    };",
  "chars": "// chars :: String -> [Char]\nconst chars = s =>\n    s.split('');",
  "chop": "// chop :: ([a] -> (b, [a])) -> [a] -> [b]\nconst chop = f => {\n    // A segmentation of xs by tail recursion with a\n    // function which returns a (prefix, residue) tuple.\n    const go = xs =>\n        0 < xs.length ? (() => {\n            const [b, bs] = Array.from(f(xs));\n            return cons(b)(go(bs))\n        })() : [];\n    return go;\n};",
  "chr": "// chr :: Int -> Char\nconst chr = x =>\n    String.fromCodePoint(x);",
  "chunksOf": "// chunksOf :: Int -> [a] -> [[a]]\nconst chunksOf = n =>\n    xs => enumFromThenTo(0)(n)(\n        xs.length - 1\n    ).reduce(\n        (a, i) => a.concat([xs.slice(i, (n + i))]),\n        []\n    );",
  "combine": "// combine :: FilePath -> FilePath -> FilePath\nconst combine = folderPath =>\n    // A filePath composed from two parts,\n    // with intercalation of '/' if needed.\n    fileName => folderPath + (\n        folderPath.endsWith('/') || fileName.startsWith('/') ? (\n            ''\n        ) : '/'\n    ) + fileName;",
  "compare": "// compare :: a -> a -> Ordering\nconst compare = a =>\n  b => a < b ? -1 : (a > b ? 1 : 0);",
  "comparing": "// comparing :: (a -> b) -> (a -> a -> Ordering)\nconst comparing = f =>\n    x => y => {\n        const\n            a = f(x),\n            b = f(y);\n        return a < b ? -1 : (a > b ? 1 : 0);\n    };",
  "compose": "// compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\nconst compose = (...fs) =>\n    fs.reduce(\n        (f, g) => x => f(g(x)), \n        x => x\n    );",
  "composeListR": "// composeListR :: [(a -> a)] -> (a -> a)\nconst composeListR = fs =>\n    x => fs.reduce((a, f) => f(a), x);",
  "composeR": "// composeR (>>>) :: (a -> b) -> (b -> c) -> a -> c\nconst composeR = f =>\n    g => x => f(g(x));",
  "concat": "// concat :: [[a]] -> [a]\n// concat :: [String] -> String\nconst concat = xs =>\n    0 < xs.length ? (\n        xs.every(x => 'string' === typeof x) ? (\n            ''\n        ) : []\n    ).concat(...xs) : xs;",
  "concatMap": "// concatMap :: (a -> [b]) -> [a] -> [b]\nconst concatMap = f =>\n    xs => xs.flatMap(f);",
  "cons": "// cons :: a -> [a] -> [a]\nconst cons = x =>\n    xs => Array.isArray(xs) ? (\n        [x].concat(xs)\n    ) : 'GeneratorFunction' !== xs\n    .constructor.constructor.name ? (\n        x + xs\n    ) : ( // cons(x)(Generator)\n        function* () {\n            yield x;\n            let nxt = xs.next()\n            while (!nxt.done) {\n                yield nxt.value;\n                nxt = xs.next();\n            }\n        }\n    )();",
  "constant": "// constant :: a -> b -> a\nconst constant = k =>\n    _ => k;",
  "copyFileLR": "// copyFileLR :: FilePath -> FilePath -> Either String IO ()\nconst copyFileLR = fpFrom =>\n    fpTo => {\n        const fpTargetFolder = takeDirectory(fpTo);\n        return doesFileExist(fpFrom) ? (\n            doesDirectoryExist(fpTargetFolder) ? (() => {\n                const\n                    e = $(),\n                    blnCopied = ObjC.unwrap(\n                        $.NSFileManager.defaultManager\n                        .copyItemAtPathToPathError(\n                            $(fpFrom).stringByStandardizingPath,\n                            $(fpTo).stringByStandardizingPath,\n                            e\n                        )\n                    );\n                return blnCopied ? (\n                    Right(blnCopied)\n                ) : Left(ObjC.unwrap(e.localizedDescription));\n\n            })() : Left(\n                'Target folder not found: ' + fpTargetFolder\n            )\n        ) : Left('Source file not found: ' + fpFrom);\n    };",
  "createDirectoryIfMissingLR": "// createDirectoryIfMissingLR :: Bool -> FilePath -> \n// Either String FilePath\nconst createDirectoryIfMissingLR = blnParents =>\n    dirPath => {\n        const fp = filePath(dirPath);\n        return doesPathExist(fp) ? (\n            Right(fp)\n        ) : (() => {\n            const\n                e = $(),\n                blnOK = $.NSFileManager.defaultManager[\n                    'createDirectoryAtPath' +\n                    'WithIntermediateDirectoriesAttributesError'\n                ](fp, blnParents, undefined, e);\n            return blnOK ? (\n                Right(fp)\n            ) : Left(e.localizedDescription);\n        })();\n    };",
  "curry": "// curry :: ((a, b) -> c) -> a -> b -> c\nconst curry = f =>\n    a => b => f(a, b);",
  "curryN": "// curryN :: Curry a b => a -> b\nconst curryN = f =>\n    // A curried function derived from a\n    // function over a tuple of any order.\n    (...args) => {\n        const\n            go = xs => f.length <= xs.length ? (\n                f(...xs)\n            ) : (...ys) => go(xs.concat(ys));\n        return go(args);\n    };",
  "cycle": "// cycle :: [a] -> Generator [a]\nfunction* cycle(xs) {\n    const lng = xs.length;\n    let i = 0;\n    while (true) {\n        yield(xs[i])\n        i = (1 + i) % lng;\n    }\n}",
  "decodedPath": "// decodedPath :: Percent Encoded String -> FilePath\nconst decodedPath = decodeURI;",
  "degrees": "// degrees :: Float x => Radians x -> Degrees x\nconst degrees = r =>\n    (180 / Math.PI) * r;",
  "delete": "// delete :: Eq a => a -> [a] -> [a]\nconst delete_ = x => {\n    // xs with first instance of x (if any) removed.\n    const go = xs =>\n        0 < xs.length ? (\n            (x === xs[0]) ? (\n                xs.slice(1)\n            ) : [xs[0]].concat(go(xs.slice(1)))\n        ) : [];\n    return go;\n};",
  "deleteAt": "// deleteAt :: Int -> [a] -> [a]\nconst deleteAt = i =>\n    xs => i <= xs.length ? (() => {\n        const lr = splitAt(i)(xs);\n        return lr[0].concat(lr[1].slice(1));\n    })() : xs;",
  "deleteBy": "// deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]\nconst deleteBy = fEq =>\n    x => {\n        const go = xs => 0 < xs.length ? (\n            fEq(x)(xs[0]) ? (\n                xs.slice(1)\n            ) : [xs[0]].concat(go(xs.slice(1)))\n        ) : [];\n        return go;\n    };",
  "deleteFirst": "// deleteFirst :: a -> [a] -> [a]\nconst deleteFirst = x => {\n    const go = xs => 0 < xs.length ? (\n        x === xs[0] ? (\n            xs.slice(1)\n        ) : [xs[0]].concat(go(xs.slice(1)))\n    ) : [];\n    return go;\n};",
  "deleteFirstsBy": "// deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst deleteFirstsBy = fEq =>\n    // The first list purged of the first instance of\n    // each predicate-matching element in the second list.\n    foldl(flip(deleteBy(fEq)));",
  "deleteKey": "// deleteKey :: String -> Dict -> Dict\nconst deleteKey = k =>\n    // A new dictionary, without the key k.\n    dct => {\n        const dct2 = Object.assign({}, dct2);\n        return (delete dct2[k], dct2);\n    };",
  "dictFromList": "// dictFromList :: [(k, v)] -> Dict\nconst dictFromList = kvs =>\n    Object.fromEntries(kvs);",
  "difference": "// difference :: Eq a => [a] -> [a] -> [a]\nconst difference = xs =>\n    ys => {\n        const s = new Set(ys);\n        return xs.filter(x => !s.has(x));\n    };",
  "differenceGen": "// differenceGen :: Gen [a] -> Gen [a] -> Gen [a]\nconst differenceGen = ga => {\n    return function*(gb) {\n        // All values of generator stream ga except any\n        // already seen in generator stream gb.\n        const\n            stream = zipGen(ga)(gb),\n            sb = new Set([]);\n        let xy = take(1)(stream);\n        while (0 < xy.length) {\n            const [x, y] = Array.from(xy[0]);\n            sb.add(y);\n            if (!sb.has(x)) yield x;\n            xy = take(1)(stream);\n        }\n    }\n};",
  "digitToInt": "// digitToInt :: Char -> Int\nconst digitToInt = c => {\n    const\n        ord = x => x.codePointAt(0),\n        oc = ord(c);\n    return 48 > oc || 102 < oc ? (\n        undefined\n    ) : (() => {\n        const\n            dec = oc - ord('0'),\n            hexu = oc - ord('A'),\n            hexl = oc - ord('a');\n        return 9 >= dec ? (\n            dec\n        ) : 0 <= hexu && 5 >= hexu  ? (\n            10 + hexu\n        ) : 0 <= hexl && 5 >= hexl ? (\n            10 + hexl\n        ) : undefined;\n    })();\n};",
  "div": "// div :: Int -> Int -> Int\nconst div = x =>\n    y => Math.floor(x / y);",
  "doesDirectoryExist": "// doesDirectoryExist :: FilePath -> IO Bool\nconst doesDirectoryExist = fp => {\n    const ref = Ref();\n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            $(fp)\n            .stringByStandardizingPath, ref\n        ) && ref[0];\n};",
  "doesFileExist": "// doesFileExist :: FilePath -> IO Bool\nconst doesFileExist = fp => {\n    const ref = Ref();\n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            $(fp)\n            .stringByStandardizingPath, ref\n        ) && 1 !== ref[0];\n};",
  "doesPathExist": "// doesPathExist :: FilePath -> IO Bool\nconst doesPathExist = fp =>\n\t$.NSFileManager.defaultManager\n\t.fileExistsAtPath(\n\t\t$(fp).stringByStandardizingPath\n\t);",
  "draw": "// draw :: Tree String -> [String]\nconst draw = node => {\n    // shift :: String -> String -> [String] -> [String]\n    const shifted = (first, other, xs) =>\n        zipWithList(append)(\n            cons(first)(\n              replicate(xs.length - 1)(\n                other\n              )\n            )\n        )(xs);\n    // drawSubTrees :: [Tree String] -> [String]\n    const drawSubTrees = xs => {\n        const lng = xs.length;\n        return 0 < lng ? (\n            1 < lng ? append(\n                cons('│')(\n                    shifted('├─ ', '│  ', draw(xs[0]))\n                )\n            )(\n                drawSubTrees(xs.slice(1))\n            ) : cons('│')(\n              shifted('└─ ', '   ', draw(xs[0]))\n            )\n        ) : [];\n    };\n    return append(lines(node.root))(\n        drawSubTrees(node.nest)\n    );\n};",
  "drawForest": "// drawForest :: [Tree String] -> String\nconst drawForest = trees =>\n    trees.map(drawTree).join('\\n');",
  "drawTree": "// drawTree :: Tree String -> String\nconst drawTree = tree =>\n    unlines(draw(tree));",
  "drawTree2": "// drawTree2 :: Bool -> Bool -> Tree String -> String\nconst drawTree2 = blnCompact => blnPruned => tree => {\n    // Tree design and algorithm inspired by the Haskell snippet at:\n    // https://doisinkidney.com/snippets/drawing-trees.html\n    const\n        // Lefts, Middle, Rights\n        lmrFromStrings = xs => {\n            const [ls, rs] = Array.from(splitAt(\n                Math.floor(xs.length / 2)\n            )(xs));\n            return TupleN(ls, rs[0], rs.slice(1));\n        },\n        stringsFromLMR = lmr =>\n        Array.from(lmr).reduce((a, x) => a.concat(x), []),\n        fghOverLMR = (f, g, h) => lmr => {\n            const [ls, m, rs] = Array.from(lmr);\n            return TupleN(ls.map(f), g(m), rs.map(h));\n        };\n    const lmrBuild = (f, w) => wsTree => {\n        const\n            leftPad = n => s => ' '.repeat(n) + s,\n            xs = wsTree.nest,\n            lng = xs.length,\n            [nChars, x] = Array.from(wsTree.root);\n\n        // LEAF NODE --------------------------------------\n        return 0 === lng ? (\n            TupleN([], '─'.repeat(w - nChars) + x, [])\n\n            // NODE WITH SINGLE CHILD -------------------------\n        ) : 1 === lng ? (() => {\n            const indented = leftPad(1 + w);\n            return fghOverLMR(\n                indented,\n                z => '─'.repeat(w - nChars) + x + '─' + z,\n                indented\n            )(f(xs[0]));\n\n            // NODE WITH CHILDREN -----------------------------\n        })() : (() => {\n            const\n                cFix = x => xs => x + xs,\n                treeFix = (l, m, r) => compose(\n                    stringsFromLMR,\n                    fghOverLMR(cFix(l), cFix(m), cFix(r))\n                ),\n                _x = '─'.repeat(w - nChars) + x,\n                indented = leftPad(w),\n                lmrs = xs.map(f);\n            return fghOverLMR(\n                indented,\n                s => _x + ({\n                    '┌': '┬',\n                    '├': '┼',\n                    '│': '┤',\n                    '└': '┴'\n                })[s[0]] + s.slice(1),\n                indented\n            )(lmrFromStrings(\n                intercalate(\n                    blnCompact ? [] : ['│']\n                )(\n                    [treeFix(' ', '┌', '│')(lmrs[0])]\n                    .concat(init(lmrs.slice(1)).map(\n                        treeFix('│', '├', '│')\n                    ))\n                    .concat([treeFix('│', '└', ' ')(\n                        lmrs[lmrs.length - 1]\n                    )])\n                )\n            ));\n        })();\n    };\n    const\n        measuredTree = fmapTree(\n            v => {\n                const s = ' ' + v + ' ';\n                return Tuple(s.length)(s)\n            })(tree),\n        levelWidths = levels(measuredTree)\n        .reduce(\n            (a, level) => a.concat(maximum(level.map(fst))),\n            []\n        ),\n        treeLines = stringsFromLMR(\n            levelWidths.reduceRight(\n                lmrBuild, x => x\n            )(measuredTree)\n        );\n    return unlines(\n        blnPruned ? (\n            treeLines.filter(\n                s => s.split('')\n                .some(c => !' │'.includes(c))\n            )\n        ) : treeLines\n    );\n};",
  "drop": "// drop :: Int -> [a] -> [a]\n// drop :: Int -> Generator [a] -> Generator [a]\n// drop :: Int -> String -> String\nconst drop = n =>\n    xs => Infinity > length(xs) ? (\n        xs.slice(n)\n    ) : (take(n)(xs), xs);",
  "dropAround": "// dropAround :: (a -> Bool) -> [a] -> [a]\n// dropAround :: (Char -> Bool) -> String -> String\nconst dropAround = p =>\n    xs => dropWhile(p)(\n        dropWhileEnd(p)(xs)\n    );",
  "dropFileName": "// dropFileName :: FilePath -> FilePath\nconst dropFileName = fp =>\n    '' !== fp ? (() => {\n        const\n          xs = (fp.split('/'))\n          .slice(0, -1);\n        return xs.length > 0 ? (\n            xs.join('/') + '/'\n        ) : './';\n    })() : './';",
  "dropLength": "// dropLength :: [a] -> [b] -> [b]\nconst dropLength = xs =>\n    ys => {\n        const go = (x, y) =>\n            0 < x.length ? (\n                0 < y.length ? (\n                    go(x.slice(1), y.slice(1))\n                ) : []\n            ) : y;\n        return go(xs, ys);\n    };",
  "dropLengthMaybe": "// dropLengthMaybe :: [a] -> [b] -> Maybe [b]\nconst dropLengthMaybe = xs =>\n    ys => {\n        const go = (x, y) =>\n            0 < x.length ? (\n                0 < y.length ? (\n                    go(x.slice(1), y.slice(1))\n                ) : Nothing()\n            ) : Just(y);\n        return go(xs, ys);\n    };",
  "dropWhile": "// dropWhile :: (a -> Bool) -> [a] -> [a]\n// dropWhile :: (Char -> Bool) -> String -> String\nconst dropWhile = p =>\n    xs => {\n        const lng = xs.length;\n        return 0 < lng ? xs.slice(\n            until(i => i === lng || !p(xs[i]))(\n                i => 1 + i\n            )(0)\n        ) : [];\n    };",
  "dropWhileEnd": "// dropWhileEnd :: (a -> Bool) -> [a] -> [a]\n// dropWhileEnd :: (Char -> Bool) -> String -> String\nconst dropWhileEnd = p =>\n    xs => {\n        let i = xs.length;\n        while (i-- && p(xs[i])) {}\n        return xs.slice(0, i + 1);\n    };",
  "dropWhileGen": "// dropWhileGen :: (a -> Bool) -> Gen [a] -> [a]\nconst dropWhileGen = p =>\n    xs => {\n        let\n            nxt = xs.next(),\n            v = nxt.value;\n        while (!nxt.done && p(v)) {\n            nxt = xs.next();\n            v = nxt.value;\n        }\n        return cons(v)(xs);\n    };",
  "either": "// either :: (a -> c) -> (b -> c) -> Either a b -> c\nconst either = fl =>\n    fr => e => 'Either' === e.type ? (\n        undefined !== e.Left ? (\n            fl(e.Left)\n        ) : fr(e.Right)\n    ) : undefined;",
  "elem": "// elem :: Eq a => a -> [a] -> Bool\n// elem :: Char -> String -> Bool\nconst elem = x =>\n    xs => {\n        const t = xs.constructor.name;\n        return 'Array' !== t ? (\n            xs['Set' !== t ? 'includes' : 'has'](x)\n        ) : xs.some(eq(x));\n    };",
  "elemAtMay": "// elemAtMay :: Int -> Dict -> Maybe (String, a)\n// elemAtMay :: Int -> [a] -> Maybe a\nconst elemAtMay = i =>\n    // Just the item at the indexed position in an array,\n    // or in the lexically sorted key-values of a dict,\n    // or Nothing, if the index is out of range.\n    x => {\n        const\n            bln = Array.isArray(x),\n            k = bln ? i : Object.keys(x)\n            .sort()[i],\n            v = x[k];\n        return undefined !== v ? (\n            Just(bln ? v : Tuple(k, v))\n        ) : Nothing();\n    };",
  "elemIndex": "// elemIndex :: Eq a => a -> [a] -> Maybe Int\nconst elemIndex = x =>\n    xs => {\n        const i = xs.indexOf(x);\n        return -1 === i ? (\n            Nothing()\n        ) : Just(i);\n    };",
  "elemIndices": "// elemIndices :: Eq a => a -> [a] -> [Int]\nconst elemIndices = x =>\n    xs => xs.flatMap((y, i) => y === x ? (\n        [i]\n    ) : []);",
  "elems": "// elems :: Map k a -> [a]\n// elems :: Set a -> [a]\nconst elems = x =>\n    'Set' !== x.constructor.name ? (\n        Object.values(x)\n    ) : Array.from(x.values());",
  "encodedPath": "// encodedPath :: FilePath -> Percent Encoded String\nconst encodedPath = encodeURI;",
  "enumFrom": "// enumFrom :: Enum a => a -> [a]\nfunction* enumFrom(x) {\n    // A non-finite succession of enumerable\n    // values, starting with the value x.\n    let v = x;\n    while (true) {\n        yield v;\n        v = succ(v);\n    }\n}",
  "enumFromPairs": "// enumFromPairs :: String -> [(String, Int)] -> Dict\nconst enumFromPairs = name =>\n    kvs => {\n        const\n            iMax = kvs[kvs.length - 1][1],\n            iMin = kvs[0][1];\n        return kvs.reduce(\n            (a, kv) => {\n                return Object.assign(\n                    a, {\n                        [kv[0]]: {\n                            'type': 'enum',\n                            'name': name,\n                            'key': kv[0],\n                            'max': iMax,\n                            'min': iMin,\n                            'value': kv[1]\n                        },\n                        [kv[1]]: kv[0]\n                    }\n                )\n            }, {}\n        );\n    };",
  "enumFromThen": "// enumFromThen :: Int -> Int -> Gen [Int]\nconst enumFromThen = x =>\n    // A non-finite stream of integers,\n    // starting with x and y, and continuing\n    // with the same interval.\n    function* (y) {\n        const d = y - x;\n        let v = y + d;\n        yield x;\n        yield y;\n        while (true) {\n            yield v;\n            v = d + v;\n        }\n    };",
  "enumFromThenTo": "// enumFromThenTo :: Int -> Int -> Int -> [Int]\nconst enumFromThenTo = x1 =>\n    x2 => y => {\n        const d = x2 - x1;\n        return Array.from({\n            length: Math.floor(y - x2) / d + 2\n        }, (_, i) => x1 + (d * i));\n    };",
  "enumFromThenToChar": "// enumFromThenToChar :: Char -> Char -> Char -> [Char]\nconst enumFromThenToChar = x1 =>\n    x2 => y => {\n        const [i1, i2, iY] = Array.from([x1, x2, y])\n            .map(x => x.charCodeAt(0)),\n            d = i2 - i1;\n        return Array.from({\n            length: (Math.floor(iY - i2) / d) + 2\n        }, (_, i) => String.fromCodePoint(i1 + (d * i)));\n    };",
  "enumFromTo": "// enumFromTo :: Int -> Int -> [Int]\nconst enumFromTo = m =>\n    n => Array.from({\n        length: 1 + n - m\n    }, (_, i) => m + i);",
  "enumFromToChar": "// enumFromToChar :: Char -> Char -> [Char]\nconst enumFromToChar = m => n => {\n    const [intM, intN] = [m, n].map(x => x.charCodeAt(0));\n    return Array.from({\n        length: Math.floor(intN - intM) + 1\n    }, (_, i) => String.fromCodePoint(intM + i));\n};",
  "enumFromTo_": "// enumFromTo_ :: Enum a => a -> a -> [a]\nconst enumFromTo_ = m => n => {\n    const\n        [x, y] = [m, n].map(fromEnum),\n        b = x + ('number' !== typeof m ? 0 : m - x);\n    return Array.from({\n        length: 1 + (y - x)\n    }, (_, i) => toEnum(m)(b + i));\n};",
  "eq": "// eq (==) :: Eq a => a -> a -> Bool\nconst eq = a =>\n    // True when a and b are equivalent in the terms\n    // defined below for their shared data type.\n    b => {\n        const t = typeof a;\n        return t !== typeof b ? (\n            false\n        ) : 'object' !== t ? (\n            'function' !== t ? (\n                a === b\n            ) : a.toString() === b.toString()\n        ) : (() => {\n            const kvs = Object.entries(a);\n            return kvs.length !== Object.keys(b).length ? (\n                false\n            ) : kvs.every(([k, v]) => eq(v)(b[k]));\n        })();\n    };",
  "evalJSLR": "// evalJSLR :: String -> Either String a\nconst evalJSLR = s => {\n    try {\n        return Right(eval('(' + s + ')'))\n    } catch (e) {\n        return Left(e.message);\n    };\n};",
  "evalJSMay": "// evalJSMay :: String -> Maybe a\nconst evalJSMay = s => {\n    try {\n        return Just(eval('(' + s + ')'))\n    } catch (e) {\n        return Nothing();\n    };\n};",
  "even": "// even :: Int -> Bool\nconst even = n => 0 === n % 2;",
  "exp": "// exp :: Float -> Float\nconst exp = Math.exp;",
  "fTable": "// fTable :: String -> (a -> String) -> (b -> String)\n//                      -> (a -> b) -> [a] -> String\nconst fTable = s => xShow => fxShow => f => xs => {\n    // Heading -> x display function ->\n    //           fx display function ->\n    //    f -> values -> tabular string\n    const\n        ys = xs.map(xShow),\n        w = Math.max(...ys.map(length));\n    return s + '\\n' + zipWith(\n        a => b => a.padStart(w, ' ') + ' -> ' + b\n    )(ys)(\n        xs.map(x => fxShow(f(x)))\n    ).join('\\n');\n};",
  "fanArrow": "// fanArrow (&&&) :: (a -> b) -> (a -> c) -> (a -> (b, c))\nconst fanArrow = f =>\n    // A function from x to a tuple of (f(x), g(x))\n    g => x => Tuple(f(x))(g(x));",
  "filePath": "// filePath :: String -> FilePath\nconst filePath = s =>\n    // The given file path with any tilde expanded\n    // to the full user directory path.\n    ObjC.unwrap(ObjC.wrap(s)\n        .stringByStandardizingPath);",
  "filePathTree": "// filePathTree :: filePath -> [Tree String] -> Tree FilePath\nconst filePathTree = fpAnchor => trees => {\n    const go = fp => tree => {\n        const path = `${fp}/${tree.root}`;\n        return Node(path)(\n            tree.nest.map(go(path))\n        );\n    };\n    return Node(fpAnchor)(\n      trees.map(go(fpAnchor))\n    );\n};",
  "fileSize": "// fileSize :: FilePath -> Either String Int\nconst fileSize = fp =>\n  bindLR(fileStatus(fp))(\n    dct => Right(ObjC.unwrap(dct.NSFileSize))\n  );",
  "fileStatus": "// fileStatus :: FilePath -> Either String Dict\nconst fileStatus = fp => {\n    const\n        e = $(),\n        dct = $.NSFileManager.defaultManager\n        .attributesOfItemAtPathError(fp, e);\n    return dct.isNil() ? (\n        Left(ObjC.unwrap(e.localizedDescription))\n    ) : Right(ObjC.deepUnwrap(dct));\n};",
  "fileUTI": "// ObjC.import('AppKit')\n\n// fileUTI :: FilePath -> Either String String\nconst fileUTI = fp => {\n    const\n        e = $(),\n        uti = $.NSWorkspace.sharedWorkspace\n        .typeOfFileError(fp, e);\n    return uti.isNil() ? (\n        Left(ObjC.unwrap(e.localizedDescription))\n    ) : Right(ObjC.unwrap(uti));\n};",
  "filter": "// filter :: (a -> Bool) -> [a] -> [a]\nconst filter = f => xs => xs.filter(f);",
  "filterTree": "// filterTree (a -> Bool) -> Tree a -> [a]\nconst filterTree = p =>\n    // List of all root values in the tree \n    // which match the predicate p.\n    foldTree(x => xs =>\n        concat(p(x) ? [x, ...xs] : xs)\n    )",
  "filteredSubTrees": "// filteredSubTrees :: (Tree a -> Bool) -> Tree a -> [Tree a]\nconst filteredSubTrees = p => {\n    const go = tree => (\n        p(tree.root) ? (\n            [tree]\n        ) : []\n    ).concat(tree.nest.flatMap(go));\n    return go;\n};",
  "filteredTree": "// filteredTree (a -> Bool) -> Tree a -> Tree a\nconst filteredTree = p =>\n    // A tree including only those children\n    // which either match the predicate p, or have\n    // descendants which match the predicate p.\n    foldTree(x => xs =>\n        Node(x)(xs.filter(\n            tree => (0 < tree.nest.length) || (\n                p(tree.root)\n            )\n        ))\n    );",
  "find": "// find :: (a -> Bool) -> [a] -> Maybe a\nconst find = p =>\n    xs => Array.isArray(xs) ? (() => {\n        const i = xs.findIndex(p);\n        return -1 !== i ? (\n            Just(xs[i])\n        ) : Nothing();\n    })() : (() => {\n        const\n            mb = until(tpl => {\n                const nxt = tpl[0];\n                return nxt.done || p(nxt.value);\n            })(\n                tpl => Tuple(tpl[1].next())(\n                    tpl[1]\n                )\n            )(Tuple(xs.next())(xs))[0];\n        return mb.done ? (\n            Nothing()\n        ) : Just(mb.value);\n    })();",
  "findIndex": "// findIndex(isSpace)(\"hello world\")\n//-> {\"type\":\"Maybe\",\"Nothing\":false,\"Just\":5}\n\n// findIndex(even)([3, 5, 7, 8, 9])\n//-> {\"type\":\"Maybe\",\"Nothing\":false,\"Just\":3}\n\n// findIndex(isUpper)(\"all lower case\")\n//-> {\"type\":\"Maybe\",\"Nothing\":true}\n\n// findIndex :: (a -> Bool) -> [a] -> Maybe Int\nconst findIndex = p =>\n    //  Just the index of the first element in\n    //  xs for which p(x) is true, or \n    //  Nothing if there is no such element.\n    xs => {\n        const\n            i = (\n                'string' !== typeof xs ? (\n                    xs\n                ) : xs.split('')\n            ).findIndex(p);\n        return -1 !== i ? (\n            Just(i)\n        ) : Nothing();\n    };",
  "findIndexR": "// findIndexR :: (a -> Bool) -> [a] -> Maybe Int\nconst findIndexR = p =>\n    //  Just the index of the last element in\n    //  xs for which p(x) is true, or \n    //  Nothing if there is no such element.\n    xs => {\n        const i = reverse('string' !== typeof xs ? (\n            xs\n        ) : xs.split('')).findIndex(p);\n        return -1 !== i ? (\n            Just(xs.length - (1 + i))\n        ) : Nothing();\n    };",
  "findIndices": "// findIndices(matching([2, 3]), [1, 2, 3, 1, 2, 3])\n//-> {2, 5}\n\n// findIndices :: (a -> Bool) -> [a] -> [Int]\n// findIndices :: (String -> Bool) -> String -> [Int]\nconst findIndices = p => xs =>\n    xs.flatMap((x, i) => p(x, i, xs) ? (\n        [i]\n    ) : []);",
  "findTree": "// The first of any nodes in the tree which match the predicate p\n// (For all matches, see treeMatches)\n\n// findTree :: (a -> Bool) -> Tree a -> Maybe Tree a\nconst findTree = p => {\n    const go = tree =>\n        p(tree.root) ? (\n            Just(tree)\n        ) : (() => {\n            const\n                xs = tree.nest,\n                lng = xs.length;\n            return 0 < lng ? until(tpl => lng <= tpl[0] || !tpl[1].Nothing)(\n                tpl => Tuple(1 + tpl[0])(\n                    go(xs[tpl[0]])\n                )\n            )(\n                Tuple(0)(\n                    Nothing()\n                )\n            )[1] : Nothing()\n        })();\n    return go;\n};",
  "firstArrow": "// firstArrow :: (a -> b) -> ((a, c) -> (b, c))\nconst firstArrow = f => \n    // A simple function lifted to one which applies\n    // to a tuple, transforming only its first item.\n    xy => Tuple(f(xy[0]))(\n       xy[1]\n    );",
  "flatten": "// flatten :: NestedList a -> [a]\nconst flatten = nest => nest.flat(Infinity);",
  "flattenTree": "// flattenTree :: Tree a -> [a]\nconst flattenTree = tree => {\n    const\n        go = (xs, node) => [node.root].concat(\n            node.nest.reduceRight(go, xs)\n        );\n    return go([], tree);\n};",
  "flip": "// flip :: (a -> b -> c) -> b -> a -> c\nconst flip = f =>\n    1 < f.length ? (\n        (a, b) => f(b, a)\n    ) : (x => y => f(y)(x));",
  "floor": "// floor :: Num -> Int\nconst floor = x => {\n    const\n        nr = (\n            'Ratio' !== x.type ? (\n                properFraction\n            ) : properFracRatio\n        )(x),\n        n = nr[0];\n    return 0 > nr[1] ? n - 1 : n;\n};",
  "fmap": "// fmap (<$>) :: Functor f => (a -> b) -> f a -> f b\nconst fmap = f => fa =>\n    Array.isArray(fa) ? (\n        fa.map(f)\n    ) : 'string' !== typeof fa ? (() => {\n        const t = fa.type;\n        return ('Either' === t ? (\n            fmapLR(f)(fa)\n        ) : 'Maybe' === t ? (\n            fmapMay(f)(fa)\n        ) : 'Node' === t ? (\n            fmapTree(f)(fa)\n        ) : 'Tuple' === t ? (\n            fmapTuple(f)(fa)\n        ) : undefined)\n    })() : fa.split('').map(f);",
  "fmapGen": "// fmapGen <$> :: (a -> b) -> Gen [a] -> Gen [b]\nconst fmapGen = f =>\n    function*(gen) {\n        let v = take(1)(gen);\n        while (0 < v.length) {\n            yield(f(v[0]))\n            v = take(1)(gen)\n        }\n    };",
  "fmapLR": "// fmapLR (<$>) :: (a -> b) -> Either a a -> Either a b\nconst fmapLR = f => lr =>\n    undefined === lr.Left ? (\n        Right(f(lr.Right))\n    ) : lr;",
  "fmapMay": "// fmapMay (<$>) :: (a -> b) -> Maybe a -> Maybe b\nconst fmapMay = f => mb =>\n    mb.Nothing ? (\n        mb\n    ) : Just(f(mb.Just));",
  "fmapTree": "// fmapTree :: (a -> b) -> Tree a -> Tree b\nconst fmapTree = f => {\n    // A new tree. The result of a structure-preserving\n    // application of f to each root in the existing tree.\n    const go = tree => Node(f(tree.root))(\n        tree.nest.map(go)\n    );\n    return go;\n};",
  "fmapTuple": "// fmapTuple (<$>) :: (a -> b) -> (a, a) -> (a, b)\nconst fmapTuple = f => tpl =>\n    Tuple(tpl[0])(\n        f(tpl[1])\n    );",
  "foldMapTree": "// foldMapTree :: Monoid m => (a -> m) -> Tree a -> m\nconst foldMapTree = f => {\n    // Result of mapping each element of the tree to\n    // a monoid, and combining with mappend.\n    const go = tree =>\n        0 < tree.nest.length ? mappend(f(tree.root))(\n            foldl1(mappend)(tree.nest.map(go))\n        ) : f(tree.root);\n    return go;\n};",
  "foldTree": "// foldTree :: (a -> [b] -> b) -> Tree a -> b\nconst foldTree = f => {\n    // The catamorphism on trees. A summary\n    // value obtained by a depth-first fold.\n    const go = tree => f(tree.root)(\n        tree.nest.map(go)\n    );\n    return go;\n};",
  "foldl": "// foldl :: (a -> b -> a) -> a -> [b] -> a\nconst foldl = f => \n    a => xs => xs.reduce((x, y) => f(x)(y), a);",
  "foldl1": "// foldl1 :: (a -> a -> a) -> [a] -> a\nconst foldl1 = f =>\n    // Left to right reduction of the non-empty list xs, \n    // using the binary operator f, with the head of xs\n    // as the initial acccumulator value.\n    xs => 1 < xs.length ? xs.slice(1)\n    .reduce(uncurry(f), xs[0]) : xs[0];",
  "foldl1May": "// foldl1May :: (a -> a -> a) -> [a] -> Maybe a\nconst foldl1May = f => xs =>\n    0 < xs.length ? (\n        Just(xs.slice(1)\n            .reduce(uncurry(f), xs[0]))\n    ) : Nothing();",
  "foldlTree": "// foldlTree :: (b -> a -> b) -> b -> Tree a -> b\nconst foldlTree = f => \n    acc => node => {\n  const go = (a, x) =>\n    x.nest.reduce(go, f(a)(x));\n  return go(acc, node);\n};",
  "foldr": "// Note that that the Haskell signature of foldr differs from that of\n// foldl - the positions of accumulator and current value are reversed\n\n// foldr :: (a -> b -> b) -> b -> [a] -> b\nconst foldr = f => a => xs =>\n    xs.reduceRight((a, x) => f(x)(a), a);",
  "foldr1": "// foldr1 :: (a -> a -> a) -> [a] -> a\nconst foldr1 = f => xs =>\n    0 < xs.length ? init(xs)\n    .reduceRight(uncurry(f), last(xs)) : [];",
  "foldr1May": "// foldr1May :: (a -> a -> a) -> [a] -> Maybe a\nconst foldr1May = f => xs =>\n    0 < xs.length ? (\n        Just(xs.slice(0, -1)\n            .reduceRight(uncurr(f), xs.slice(-1)[0]))\n    ) : Nothing();",
  "foldrTree": "// foldrTree :: (a -> b -> b) -> b -> Tree a -> b\nconst foldrTree = f => acc => node => {\n    const go = (a, x) =>\n        x.nest.reduceRight(go, f(x.root)(a));\n    return go(acc, node);\n};",
  "fpAppend": "// fpAppend :: FilePath -> FilePath -> FilePath\nconst fpAppend = fp =>\n    // Two paths combined with a path separator. \n    // Just the second path if that starts \n    // with a path separator.\n    fp1 => Boolean(fp) && Boolean(fp1) ? (\n        '/' === fp1.slice(0, 1) ? (\n            fp1\n        ) : '/' === fp.slice(-1) ? (\n            fp + fp1\n        ) : fp + '/' + fp1\n    ) : fp + fp1;",
  "fromEnum": "// fromEnum :: Enum a => a -> Int\nconst fromEnum = x =>\n    typeof x !== 'string' ? (\n        x.constructor === Object ? (\n            x.value\n        ) : parseInt(Number(x))\n    ) : x.codePointAt(0);",
  "fromLeft": "// | Return the contents of a 'Left'-value or a default value otherwise.\n\n// fromLeft :: a -> Either a b -> a\nconst fromLeft = def => lr =>\n  isLeft(lr) ? lr.Left : def;",
  "fromMaybe": "// fromMaybe :: a -> Maybe a -> a\nconst fromMaybe = def => mb => mb.Nothing ? def : mb.Just;",
  "fromRight": "// | Return the contents of a 'Right'-value or a default value otherwise.\n\n// fromRight :: b -> Either a b -> b\nconst fromRight = def => lr =>\n  isRight(lr) ? lr.Right : def;",
  "fst": "// fst :: (a, b) -> a\nconst fst = tpl =>\n    // First member of a pair.\n    tpl[0];",
  "ft": "// Abbreviation for quick testing\n\n// ft :: (Int, Int) -> [Int]\nconst ft = m => n =>\n    Array.from({\n        length: 1 + n - m\n    }, (_, i) => m + i);",
  "gcd": "// gcd :: Int -> Int -> Int\nconst gcd = x => y => {\n    const\n        _gcd = (a, b) => (0 === b ? a : _gcd(b, a % b)),\n        abs = Math.abs;\n    return _gcd(abs(x), abs(y));\n};",
  "genericIndexMay": "// genericIndexMay :: [a] -> Int -> Maybe a\nconst genericIndexMay = xs => i =>\n    (i < xs.length && 0 <= i) ? Just(xs[i]) : Nothing();",
  "getCurrentDirectory": "// getCurrentDirectory :: IO FilePath\nconst getCurrentDirectory = () =>\n    ObjC.unwrap($.NSFileManager.defaultManager.currentDirectoryPath);",
  "getDirectoryContents": "// getDirectoryContents :: FilePath -> IO [FilePath]\nconst getDirectoryContents = fp =>\n    ObjC.deepUnwrap(\n        $.NSFileManager.defaultManager\n        .contentsOfDirectoryAtPathError(\n            $(fp)\n            .stringByStandardizingPath, null\n        )\n    );",
  "getDirectoryContentsLR": "// getDirectoryContentsLR :: FilePath -> Either String IO [FilePath]\nconst getDirectoryContentsLR = fp => {\n    const\n        error = $(),\n        xs = $.NSFileManager.defaultManager\n        .contentsOfDirectoryAtPathError(\n            $(fp).stringByStandardizingPath,\n            error\n        );\n    return xs.isNil() ? (\n        Left(ObjC.unwrap(error.localizedDescription))\n    ) : Right(ObjC.deepUnwrap(xs))\n};",
  "getFinderDirectory": "// getFinderDirectory :: IO FilePath\nconst getFinderDirectory = () =>\n    decodeURIComponent(\n        Application('Finder')\n        .insertionLocation()\n        .url()\n        .slice(7)\n    );",
  "getHomeDirectory": "// getHomeDirectory :: IO FilePath\nconst getHomeDirectory = () =>\n    ObjC.unwrap($.NSHomeDirectory());",
  "getTemporaryDirectory": "// getTemporaryDirectory :: IO FilePath\nconst getTemporaryDirectory = () =>\n    ObjC.unwrap($.NSTemporaryDirectory());",
  "group": "// group :: [a] -> [[a]]\nconst group = xs => {\n    // A list of lists, each containing only equal elements,\n    // such that the concatenation of these lists is xs.\n    const go = xs =>\n        0 < xs.length ? (() => {\n            const\n                h = xs[0],\n                i = xs.findIndex(x => h !== x);\n            return i !== -1 ? (\n                [xs.slice(0, i)].concat(go(xs.slice(i)))\n            ) : [xs];\n        })() : [];\n    return go(xs);\n};",
  "groupBy": "// groupBy :: (a -> a -> Bool) -> [a] -> [[a]]\nconst groupBy = fEq => xs =>\n    // // Typical usage: groupBy(on(eq)(f), xs)\n    0 < xs.length ? (() => {\n        const\n            tpl = xs.slice(1).reduce(\n                (gw, x) => {\n                    const\n                        gps = gw[0],\n                        wkg = gw[1];\n                    return fEq(wkg[0])(x) ? (\n                        Tuple(gps)(wkg.concat([x]))\n                    ) : Tuple(gps.concat([wkg]))([x]);\n                },\n                Tuple([])([xs[0]])\n            );\n        return tpl[0].concat([tpl[1]])\n    })() : [];",
  "groupSortBy": "// groupSortBy :: (a -> a -> Ordering) -> [a] -> [[a]]\nconst groupSortBy = f =>\n    compose(\n        groupBy(a => b => 0 == f(a)(b)),\n        sortBy(f)\n    );",
  "groupSortOn": "// groupSortOn :: (a -> b) -> [a] -> [[a]]\nconst groupSortOn = f =>\n    compose(\n        map(map(snd)),\n        groupBy(on(eq)(fst)),\n        sortBy(comparing(fst)),\n        map(fanArrow(f)(identity))\n    );",
  "gt": "// gt :: Ord a => a -> a -> Bool\nconst gt = x => y =>\n    'Tuple' === x.type ? (\n        x[0] > y[0]\n    ) : (x > y);",
  "head": "// head :: [a] -> a\nconst head = xs => xs.length ? xs[0] : undefined;",
  "headMay": "// headMay :: [a] -> Maybe a\nconst headMay = xs =>\n    0 < xs.length ? Just(xs[0]) : Nothing();",
  "identity": "// identity :: a -> a\nconst identity = x =>\n    // The identity function. (`id`, in Haskell)\n    x;",
  "if_": "// if_ :: Bool -> a -> a -> a\nconst if_ = bln => x => y => bln ? x : y;",
  "indented": "// indented :: String -> String -> String\nconst indented = strIndent => s =>\n    s.split(/[\\r\\n]/).map(\n        x => '' !== x ? strIndent + x : x\n    ).join('\\n')",
  "index": "// index (!!) :: [a] -> Int -> Maybe a\n// index (!!) :: Generator (Int, a) -> Int -> Maybe a\n// index (!!) :: String -> Int -> Maybe Char\nconst index = xs => i => {\n    const s = xs.constructor.constructor.name;\n    return 'GeneratorFunction' !== s ? (() => {\n        const v = xs[i];\n        return undefined !== v ? Just(v) : Nothing();\n    })() : (() => {\n        const v = until(x => x.done || i <= fst(x.value))(\n            () => xs.next()\n        )(xs.next());\n        return v.done ? Nothing() : Just(snd(v.value));\n    })();\n};",
  "indexForest": "// indexForest :: [Tree (a,  { nodeSum :: Int })] -> Int ->\n// Maybe Tree (a, { nodeSum :: Int })\nconst indexForest = trees =>\n    // Index into a forest of measured trees.\n    // (see measuredTree)\n    i => 0 < trees.length ? (() => {\n        const\n            headNode = trees[0],\n            headSize = headNode.root[1].nodeSum;\n        return i > (headSize - 1) ? (\n            indexForest(trees.slice(1))(i - headSize)\n        ) : indexTree(headNode)(i);\n    })() : Nothing();",
  "indexOf": "// indexOf :: Eq a => [a] -> [a] -> Maybe Int\n// indexOf :: String -> String -> Maybe Int\nconst indexOf = needle => haystack =>\n    'string' !== typeof haystack ? (\n        findIndex(xs => isPrefixOf(needle)(xs))(\n          tails(haystack)\n        )\n    ) : (() => {\n        const i = haystack.indexOf(needle);\n        return -1 !== i ? (\n            Just(i)\n        ) : Nothing();\n    })();",
  "indexTree": "// indexTree :: Tree (a,  { nodeSum :: Int }) -> Int ->\n//              Maybe Tree (a,  { nodeSum :: Int })\nconst indexTree = tree =>\n    // Index into a measured tree. (see measuredTree)\n    i => 0 !== i ? (\n        i > (tree.root[1].nodeSum - 1) ? (\n            Nothing()\n        ) : indexForest(tree.nest)(i - 1)\n    ) : Just(tree);",
  "init": "// init :: [a] -> [a]\nconst init = xs =>\n    // All elements of a list except the last.\n    0 < xs.length ? (\n        xs.slice(0, -1)\n    ) : undefined;",
  "initMay": "// initMay :: [a] -> Maybe [a]\nconst initMay = xs =>\n    0 < xs.length ? Just(xs.slice(0, -1)) : Nothing();",
  "inits": "// inits([1, 2, 3]) -> [[], [1], [1, 2], [1, 2, 3]\n// inits('abc') -> [\"\", \"a\", \"ab\", \"abc\"]\n\n// inits :: [a] -> [[a]]\n// inits :: String -> [String]\nconst inits = xs => [\n        []\n    ]\n    .concat(('string' === typeof xs ? xs.split('') : xs)\n        .map((_, i, lst) => lst.slice(0, 1 + i)));",
  "insert": "// insert :: Ord a => a -> [a] -> [a]\nconst insert = x => ys => {\n    const cmp = (a, b) => a < b ? -1 : (a > b ? 1 : 0);\n    for (var i = 0, lng = ys.length; i < lng && cmp(x, ys[i]) > 0; i++) {};\n    return ys.slice(0, i)\n        .concat(x)\n        .concat(ys.slice(i));\n};",
  "insertBy": "// insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]\nconst insertBy = cmp => x => ys => {\n    for (var i = 0, lng = ys.length; i < lng && cmp(x, ys[i]) > 0; i++) {};\n    return ys.slice(0, i)\n        .concat(x)\n        .concat(ys.slice(i));\n};",
  "insertDict": "// insertDict :: String -> a -> Dict -> Dict\nconst insertDict = k => v => dct =>\n    Object.assign({}, dct, {\n        [k]: v\n    });",
  "intToDigit": "// intToDigit :: Int -> Char\nconst intToDigit = n =>\n    n >= 0 && n < 16 ? (\n        '0123456789ABCDEF'.charAt(n)\n    ) : '?';",
  "intercalate": "// intercalate :: [a] -> [[a]] -> [a]\n// intercalate :: String -> [String] -> String\nconst intercalate = sep => xs =>\n    0 < xs.length && 'string' === typeof sep &&\n    'string' === typeof xs[0] ? (\n        xs.join(sep)\n    ) : concat(intersperse(sep)(xs));",
  "intercalateS": "// intercalateS :: String -> [String] -> String\nconst intercalateS = s =>\n    // The concatenation of xs\n    // interspersed with copies of s.\n    xs => xs.join(s);",
  "intersect": "// intersect :: (Eq a) => [a] -> [a] -> [a]\nconst intersect = xs => ys => {\n    const s = new Set(ys);\n    return xs.filter(x => s.has(x));\n};",
  "intersectBy": "// intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst intersectBy = eq => xs => ys => {\n    return (0 < xs.length && 0 < ys.length) ?\n    xs.filter(x => ys.some(eq(x))) : [];\n};",
  "intersectListsBy": "// intersectListsBy :: (a -> a -> Bool) -> [[a]] -> [a]\nconst intersectListsBy = eq => xs =>\n    foldr1((a => x => intersectBy(eq)(a)(x)))(\n        xs\n    );",
  "intersection": "// intersection :: Ord a => Set a -> Set a -> Set a\nconst intersection = s => s1 =>\n    new Set([...s].filter(x => s1.has(x)));",
  "intersperse": "// intersperse(0, [1,2,3]) -> [1, 0, 2, 0, 3]\n\n// intersperse :: a -> [a] -> [a]\n// intersperse :: Char -> String -> String\nconst intersperse = sep => xs => {\n    const bln = 'string' === typeof xs;\n    return xs.length > 1 ? (\n        (bln ? concat : x => x)(\n            (bln ? (\n                xs.split('')\n            ) : xs)\n            .slice(1)\n            .reduce((a, x) => a.concat([sep, x]), [xs[0]])\n        )) : xs;\n};",
  "isAlpha": "// isAlpha :: Char -> Bool\nconst isAlpha = c =>\n    /[A-Za-z\\u00C0-\\u00FF]/.test(c);",
  "isChar": "// isChar :: a -> Bool\nconst isChar = x =>\n    ('string' === typeof x) && (1 === x.length);",
  "isDigit": "// isDigit :: Char -> Bool\nconst isDigit = c => {\n    const n = c.codePointAt(0);\n    return 48 <= n && 57 >= n;\n};",
  "isInfixOf": "// isInfixOf :: (Eq a) => [a] -> [a] -> Bool\n// isInfixOf :: String -> String -> Bool\nconst isInfixOf = needle => haystack =>\n    'string' !== typeof haystack ? (() => {\n        const\n            lng = needle.length,\n            go = xs => lng <= xs.length ? (\n                isPrefixOf(needle)(xs) || go(xs.slice(1))\n            ) : false;\n        return go(haystack);\n    })() : haystack.includes(needle);",
  "isLeft": "// isLeft :: Either a b -> Bool\nconst isLeft = lr =>\n    ('Either' === lr.type) && (undefined !== lr.Left);",
  "isLower": "// isLower :: Char -> Bool\nconst isLower = c =>\n    /[a-z]/.test(c);",
  "isMaybe": "// isMaybe :: a -> Bool\nconst isMaybe = x =>\n    'Maybe' === x.type;",
  "isNull": "// isNull :: [a] -> Bool\n// isNull :: String -> Bool\nconst isNull = xs =>\n    1 > xs.length;",
  "isPrefixOf": "// isPrefixOf :: [a] -> [a] -> Bool\n// isPrefixOf :: String -> String -> Bool\nconst isPrefixOf = xs =>\n    // True if and only if xs is a prefix of ys.\n    ys => {\n        const go = (xs, ys) => {\n            const intX = xs.length;\n            return 0 < intX ? (\n                ys.length >= intX ? xs[0] === ys[0] && go(\n                    xs.slice(1), ys.slice(1)\n                ) : false\n            ) : true;\n        };\n        return 'string' !== typeof xs ? (\n            go(xs, ys)\n        ) : ys.startsWith(xs);\n    };",
  "isRight": "// isRight :: Either a b -> Bool\nconst isRight = lr =>\n  ('undefined' !== typeof lr) && \n  ('Either' === lr.type) && (undefined !== lr.Right);",
  "isSortedBy": "// The 'isSortedBy' function returns true iff the predicate returns true\n// for all adjacent pairs of elements in the list.\n\n// isSortedBy :: (a -> a -> Bool) -> [a] -> Bool\nconst isSortedBy = cmp => xs =>\n    xs.length < 2 || all(x => x < 1, zipWith(cmp, xs, tail(xs)));",
  "isSpace": "// isSpace :: Char -> Bool\nconst isSpace = c => /\\s/.test(c);",
  "isSubsequenceOf": "// isSubsequenceOf :: Eq a => [a] -> [a] -> Bool\n// isSubsequenceOf :: String -> String -> Bool\nconst isSubsequenceOf = xs => ys => {\n    const iss = (a, b) =>\n        a.length > 0 ? (\n            b.length > 0 ? (\n                iss((a[0] === b[0] ? a.slice(1) : a), b.slice(1))\n            ) : false\n        ) : true;\n    return iss.apply(\n        null, 'string' === typeof xs ? [\n            xs.split(''), ys.split('')\n        ] : [xs, ys]\n    );\n};",
  "isSubsetOf": "// isSubsetOf :: Ord a => Set a -> Set a -> Bool\nconst isSubsetOf = a => b => {\n    for (let x of a) {\n        if (!b.has(x)) return false;\n    }\n    return true;\n};",
  "isSuffixOf": "// isSuffixOf :: Eq a => [a] -> [a] -> Bool\n// isSuffixOf :: String -> String -> Bool\nconst isSuffixOf = ns => hs => {\n    const go = delta =>\n        eq(ns)(dropLength(delta)(hs));\n    return 'string' !== typeof hs ? (\n        bindMay(dropLengthMaybe(ns)(hs))(\n          go\n        )\n    ) : hs.endsWith(ns);\n};",
  "isUpper": "// isUpper :: Char -> Bool\nconst isUpper = c =>\n    /[A-Z]/.test(c);",
  "iso8601Local": "// iso8601Local :: Date -> String\nconst iso8601Local = dte =>\n    new Date(dte - (6E4 * dte.getTimezoneOffset()))\n    .toISOString();",
  "iterate": "// iterate :: (a -> a) -> a -> Gen [a]\nconst iterate = f =>\n    function* (x) {\n        let v = x;\n        while (true) {\n            yield(v);\n            v = f(v);\n        }\n    };",
  "iterateUntil": "// iterateUntil :: (a -> Bool) -> (a -> a) -> a -> [a]\nconst iterateUntil = p => f =>\n    function*(x) {\n        let v = x;\n        while (!p(v)) {\n            yield(v);\n            v = f(v);\n        }\n    };",
  "join": "// join :: Monad m => m (m a) -> m a\nconst join = x => bind(x)(\n    identity\n);",
  "jsonFromTree": "// jsonFromTree :: Tree a -> String\nconst jsonFromTree = tree => {\n    // A recursive [root, nest] JSON format,\n    // in which `root` is a value string, and `nest`\n    // is a possibly empty list of [`root`, `nest`] pairs.\n    const go = node => [node.root, node.nest.map(go)];\n    return JSON.stringify(go(tree));\n};",
  "jsonLog": "// jsonLog :: a -> IO ()\nconst jsonLog = (...args) =>\n    console.log(\n        args\n        .map(JSON.stringify)\n        .join(' -> ')\n    );",
  "jsonParseLR": "// jsonParseLR :: String -> Either String a\nconst jsonParseLR = s => {\n    try {\n        return Right(JSON.parse(s));\n    } catch (e) {\n        return Left(`${e.message} (line:${e.line} col:${e.column})`);\n    }\n};",
  "justifyLeft": "// justifyLeft :: Int -> Char -> String -> String\nconst justifyLeft = n =>\n    // The string s, followed by enough padding (with\n    // the character c) to reach the string length n.\n    c => s => n > s.length ? (\n        s.padEnd(n, c)\n    ) : s;",
  "justifyRight": "// justifyRight :: Int -> Char -> String -> String\nconst justifyRight = n =>\n    // The string s, preceded by enough padding (with\n    // the character c) to reach the string length n.\n    c => s => n > s.length ? (\n        s.padStart(n, c)\n    ) : s;",
  "kCompose": "// kCompose (>=>) :: Monad m => \n// [(a -> m a)] -> (a -> m a)\nconst kCompose = (...fs) =>\n    // Left Right composition of a sequence\n    // of functions which lift a raw value\n    // of the same type into the same monad.\n    x => 0 < fs.length ? (\n        fs.slice(1).reduce(\n            (m, f) => bind(m)(f),\n            fs[0](x)\n        )\n    ) : x;",
  "keys": "// keys :: Dict -> [String]\nconst keys = Object.keys;",
  "kleisliCompose": "// kleisliCompose (>=>) :: Monad m => (a -> m b) ->\n// (b -> m c) -> (a -> m c)\nconst kleisliCompose = f =>\n    // Kleisli composition of two functions which\n    // each lift their values into the same monad.\n    g => x => bind(f(x))(g);",
  "last": "// last :: [a] -> a\nconst last = xs =>\n    // The last item of a list.\n    0 < xs.length ? xs.slice(-1)[0] : undefined;",
  "lastMay": "// lastMay :: [a] -> Maybe a\nconst lastMay = xs => 0 < xs.length ? (\n    Just(xs.slice(-1)[0])\n) : Nothing();",
  "lcm": "// lcm :: Int -> Int -> Int\nconst lcm = x =>\n    // The smallest positive integer divisible\n    // without remainder by both x and y.\n    y => (x === 0 || y === 0) ? (\n        0\n    ) : Math.abs(Math.floor(x / gcd(x)(y)) * y);",
  "lefts": "// lefts :: [Either a b] -> [a]\nconst lefts = xs =>\n    xs.flatMap(\n        x => ('Either' === x.type) && (undefined !== x.Left) ? (\n            [x.Left]\n        ) : []\n    );",
  "length": "// length :: [a] -> Int\nconst length = xs =>\n    // Returns Infinity over objects without finite \n    // length. This enables zip and zipWith to choose \n    // the shorter argument when one is non-finite, \n    // like cycle, repeat etc\n    (Array.isArray(xs) || 'string' === typeof xs) ? (\n        xs.length\n    ) : Infinity;",
  "levelNodes": "// levelNodes :: Tree a -> [[Tree a]]\nconst levelNodes = tree =>\n  iterateUntil(xs => 1 > xs.length)(\n    xs => xs.flatMap(x => x.nest)\n  )([tree]);",
  "levels": "// levels :: Tree a -> [[a]]\nconst levels = tree =>\n    map(map(root))(\n        takeWhile(xs => 0 < xs.length)(\n            iterate(concatMap(nest))([\n                tree\n            ])\n        )\n    );",
  "liftA2": "// Lift a binary function to actions.\n// liftA2 f a b = fmap f a <*> b\n\n// liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\nconst liftA2 = f => a => b => {\n    const t = typeName(a);\n    return (\n        'Bottom' !== t ? (\n            '(a -> b)' === t ? (\n                liftA2Fn\n            ) : 'Either' === t ? (\n                liftA2LR\n            ) : 'Maybe' === t ? (\n                liftA2May\n            ) : 'Tuple' === t ? (\n                liftA2Tuple\n            ) : 'Node' === t ? (\n                liftA2Tree\n            ) : liftA2List\n        ) : liftA2List\n    )(f)(a)(b);\n};",
  "liftA2Fn": "// liftA2Fn :: (a0 -> b -> c) -> (a -> a0) -> (a -> b) -> a -> c\nconst liftA2Fn = op => f => g =>\n    // Lift a binary function to a composition\n    // over two other functions.\n    // liftA2 (*) (+ 2) (+ 3) 7 == 90\n    x => op(f(x))(g(x));",
  "liftA2LR": "// liftA2LR :: (a -> b -> c) -> Either d a -> Either d b -> Either d c\nconst liftA2LR = f =>\n    a => b => bindLR(a)(\n        x => bindLR(b)(\n            compose(Right, f(x))\n        )\n    );",
  "liftA2List": "// liftA2List :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst liftA2List = f => xs => ys =>\n    // The binary operator f lifted to a function over two\n    // lists. f applied to each pair of arguments in the\n    // cartesian product of xs and ys.\n    xs.flatMap(\n        x => ys.map(f(x))\n    );",
  "liftA2May": "// liftA2May :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\nconst liftA2May = f => a => b =>\n    a.Nothing ? a : b.Nothing ? b : Just(f(a.Just)(b.Just));",
  "liftA2Tree": "// liftA2Tree :: (a -> b -> c) -> Tree a -> Tree b -> Tree c\nconst liftA2Tree = f => tx => ty => {\n    const go = tx =>\n        Node(f(tx.root)(ty.root))(\n            Boolean(ty.nest) ? (\n                ty.nest.map(\n                    fmapTree(f(tx.root))\n                )\n                .concat(tx.nest.map(go))\n            ) : []\n        );\n    return go(tx);\n};",
  "liftA2Tuple": "// liftA2Tuple :: Monoid m => \n// (a -> b -> c) -> (m, a) -> (m, b) -> (m, c)\nconst liftA2Tuple = f => a => b =>\n    Tuple(mappend(a[0])(b[0]))(\n        f(a[1])(b[1])\n    );",
  "liftMmay": "// liftMmay :: (a -> b) -> (Maybe a -> Maybe b)\nconst liftMmay = f =>\n    mb => mb.Nothing ? (\n        mb\n    ) : Just(f(mb.Just))",
  "lines": "// lines :: String -> [String]\nconst lines = s =>\n    // A list of strings derived from a single\n    // newline-delimited string.\n    0 < s.length ? (\n        s.split(/[\\r\\n]/)\n    ) : [];",
  "list": "// list :: TupleN(a) -> [a]\nconst list = tpl =>\n    Array.from(tpl);",
  "listDirectory": "// listDirectory :: FilePath -> [FilePath]\nconst listDirectory = fp =>\n\tObjC.unwrap(\n\t\t$.NSFileManager.defaultManager\n\t\t.contentsOfDirectoryAtPathError(\n\t\t\tObjC.wrap(fp)\n\t\t\t.stringByStandardizingPath,\n\t\t\tnull\n\t\t))\n\t.map(ObjC.unwrap);",
  "listFromMaybe": "// listFromMaybe :: Maybe a -> [a]\nconst listFromMaybe = mb =>\n    // A singleton list derived from a Just value, \n    // or an empty list derived from Nothing.\n    mb.Nothing ? [] : [mb.Just];",
  "listFromTree": "// listFromTree :: Tree a -> [a]\nconst listFromTree = tree => {\n    const go = x => [\n      x.root,\n      ...[].concat.apply([], x.nest.map(go))\n    ];\n    return go(tree);\n};",
  "listFromTuple": "// listFromTuple :: (a, a ...) -> [a]\nconst listFromTuple = tpl =>\n    Array.from(tpl);",
  "listToMaybe": "// The listToMaybe function returns Nothing on \n// an empty list or Just the head of the list.\n\n// listToMaybe :: [a] -> Maybe a\nconst listToMaybe = xs =>\n    0 < xs.length ? (\n        Just(xs[0])\n    ) : Nothing();",
  "log": "// log :: Float -> Float\nconst log = Math.log;",
  "lookup": "// lookup :: Eq a => a -> Container -> Maybe b\nconst lookup = k => m =>\n    (Array.isArray(m) ? (\n        lookupTuples\n    ) : lookupDict)(k)(m);",
  "lookupDict": "// lookupDict :: a -> Dict -> Maybe b\nconst lookupDict = k => dct => {\n    const v = dct[k];\n    return undefined !== v ? (\n        Just(v)\n    ) : Nothing();\n};",
  "lookupTuples": "// lookupTuples :: Eq a => a -> [(a, b)] -> Maybe b\nconst lookupTuples = k => kvs =>\n    bindMay(\n      find(x => k === fst(x))(\n        kvs\n      )\n    )(x => Just(snd(x)));",
  "lt": "// lt (<) :: Ord a => a -> a -> Bool\nconst lt = a => \n    b => a < b;",
  "mReturn": "// Not required in JS, which has first functions by default.\n// Included only for comparison with AS, which has to derive\n// first class functions by lifting 'handlers' into 'scripts'\n// as anonymous |λ|() functions.\n\n// In JS, mReturn is just an alternate name for identity.\n\n// mReturn :: First-class m => (a -> b) -> m (a -> b)\nconst mReturn = x => identity(x);",
  "map": "// map :: (a -> b) -> [a] -> [b]\nconst map = f =>\n    // The list obtained by applying f \n    // to each element of xs.\n    // (The image of xs under f).\n    xs => (\n        Array.isArray(xs) ? (\n            xs\n        ) : xs.split('')\n    ).map(f);",
  "mapAccumL": "// Map-accumulation is a combination of map and a catamorphism;\n// it applies a function to each element of a list, passing an\n// accumulating parameter from left to right, and returning a final\n// value of this accumulator together with the new list.\n\n// mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\nconst mapAccumL = f => acc => xs =>\n    xs.reduce((a, x) => {\n        const pair = f(a[0])(x);\n        return Tuple(pair[0])(a[1].concat(pair[1]));\n    }, Tuple(acc)([]));",
  "mapAccumL_Tree": "// mapAccumL_Tree :: (acc -> x -> (acc, y))\n// -> acc -> Tree -> (acc, Tree)\nconst mapAccumL_Tree = f => {\n    const go = a => x => {\n        const\n            pair = f(a)(root(x)),\n            tpl = mapAccumL(go)(pair[0])(nest(x));\n        return Tuple(tpl[0])(\n            Node(pair[1])(tpl[1])\n        );\n    };\n    return go;\n};",
  "mapAccumR": "// mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\nconst mapAccumR = f => acc => xs =>\n    // A tuple of an accumulation and a list derived by a\n    // combined map and fold,\n    // with accumulation from right to left.\n    xs.reduceRight((a, x) => {\n        const pair = f(a[0])(x);\n        return Tuple(pair[0])([pair[1]].concat(a[1]));\n    }, Tuple(acc)([]));",
  "mapKeys": "// A function mapped over the keys of a record\n\n// A function mapped over the keys of a record\n// mapKeys :: (Key -> Key) -> IntMap a -> IntMap a\nconst mapKeys = f => dct =>\n    mapFromList(\n        map(kv => [f(read(kv[0]))(kv[1])])(\n            zip(keys(dct))(\n                elems(dct)\n            )\n        )\n    );",
  "mapMaybe": "// The mapMaybe function is a version of map which can throw out\n// elements. In particular, the functional argument returns\n// something of type Maybe b. If this is Nothing, no element is\n// added on to the result list. If it just Just b, then b is\n// included in the result list.\n\n// mapMaybe :: (a -> Maybe b) -> [a] -> [b]\nconst mapMaybe = mf => xs =>\n  xs.reduce(\n    (a, x) => maybe(a)(\n        j => a.concat(j)\n    )(mf(x)),\n    []\n  );",
  "mapMaybeGen": "// mapMaybeGen :: (a -> Maybe b) -> Gen [a] -> Gen [b]\nconst mapMaybeGen = mf =>\n    function*(gen) {\n        let v = take(1, gen);\n        while (0 < v.length) {\n            let mb = mf(v[0]);\n            if (!mb.Nothing) yield mb.Just\n            v = take(1, gen);\n        }\n    };",
  "mappend": "// mappend (<>) :: Monoid a => a -> a -> a\nconst mappend = a =>\n    // Associative operation \n    // defined for various monoid types.\n    b => {\n        const t = a.type;\n        return (\n            Boolean(t) ? (\n                'Maybe' === t ? (\n                    mappendMaybe\n                ) : mappendTuple\n            ) : 'function' !== typeof a ? (\n                append\n            ) : a.toString() !== 'x => y => f(y)(x)' ? (\n                mappendFn\n            ) : mappendOrd\n        )(a)(b);\n    };",
  "mappendFn": "// mappendFn :: Monoid b => (a -> b) -> (a -> b) -> (a -> b)\nconst mappendFn = f => g =>\n    x => mappend(f(x))(\n        g(x)\n    );",
  "mappendMaybe": "// mappendMaybe (<>) :: Maybe a -> Maybe a -> Maybe a\nconst mappendMaybe = a => b =>\n    a.Nothing ? (\n        b\n    ) : b.Nothing ? (\n        a\n    ) : Just(\n        mappend(a.Just)(\n            b.Just\n        )\n    );",
  "mappendOrd": "// mappendOrd (<>) :: Ordering -> Ordering -> Ordering\nconst mappendOrd = cmp => cmp1 =>\n    a => b => {\n        const x = cmp(a)(b);\n        return 0 !== x ? (\n            x\n        ) : cmp1(a)(b);\n    };",
  "mappendTuple": "// mappendTuple (<>) :: (a, b) -> (a, b) -> (a, b)\nconst mappendTuple = t => t2 =>\n    Tuple(\n        mappend(t[0])(\n            t1[0]\n        )\n    )(mappend(t[1])(\n        t1[1]\n    ));",
  "matching": "// Returns a sequence-matching function for findIndices etc\n// findIndices(matching([2, 3]), [1, 2, 3, 1, 2, 3])\n// -> [1, 4]\n\n// matching :: [a] -> (a -> Int -> [a] -> Bool)\nconst matching = pat => {\n    const\n        lng = pat.length,\n        bln = 0 < lng,\n        h = bln ? pat[0] : undefined;\n    return x => i => src =>\n        bln && h == x &&\n        eq(pat)(\n            src.slice(i, lng + i)\n        );\n};",
  "max": "// max :: Ord a => a -> a -> a\nconst max = a => b => gt(b)(a) ? b : a;",
  "maxBound": "// maxBound :: a -> a\nconst maxBound = x => {\n    const e = x.enum;\n    return Boolean(e) ? (\n        e[e[x.max]]\n    ) : {\n        'number': Number.MAX_SAFE_INTEGER,\n        'string': String.fromCodePoint(65535),\n        'boolean': true\n    }[typeof x];\n};",
  "maximum": "// maximum :: Ord a => [a] -> a\nconst maximum = xs =>\n    // The largest value in a non-empty list.\n    0 < xs.length ? (\n        xs.slice(1).reduce(\n            (a, x) => x > a ? (\n                x\n            ) : a, xs[0]\n        )\n    ) : undefined;",
  "maximumBy": "//  Ordering: (LT|EQ|GT):\n//  GT: 1 (or other positive n)\n//\tEQ: 0\n//  LT: -1 (or other negative n) \n\n// maximumBy :: (a -> a -> Ordering) -> [a] -> a\nconst maximumBy = f => xs =>\n    0 < xs.length ? (\n        xs.slice(1)\n        .reduce((a, x) => 0 < f(x)(a) ? x : a, xs[0])\n    ) : undefined;",
  "maximumByMay": "//Ordering: (LT|EQ|GT):\n//  GT: 1 (or other positive n)\n//\tEQ: 0\n//  LT: -1 (or other negative n) \n\n// maximumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\nconst maximumByMay = f => xs =>\n    xs.length > 0 ? (\n        Just(xs.slice(1)\n            .reduce((a, x) => 0 < f(x, a) ? x : a, xs[0]))\n    ) : Nothing();",
  "maximumMay": "// maximumMay :: Ord a => [a] -> Maybe a\nconst maximumMay = xs =>\n    0 < xs.length ? (\n        Just(xs.slice(1)\n            .reduce((a, x) => (x > a ? x : a), xs[0]))\n    ) : Nothing();",
  "maybe": "// maybe :: b -> (a -> b) -> Maybe a -> b\nconst maybe = v =>\n    // Default value (v) if m is Nothing, or f(m.Just)\n    f => m => m.Nothing ? v : f(m.Just);",
  "mconcatOrd": "// mconcatOrd :: [Ordering] -> Ordering\nconst mconcatOrd = cmps =>\n    // A sort compare function derived from\n    // a list of such functions, providing\n    // for composition of n-ary sorts.\n    0 < cmps.length ? (\n        foldl(\n            mappendOrd\n        )(cmps[0])(cmps.slice(1))\n    ) : compare;",
  "mean": "// mean :: [Num] -> Num\nconst mean = xs =>\n  xs.reduce((a, x) => a + x, 0) / xs.length;",
  "measuredTree": "// measuredTree :: Tree a -> Tree (a, (Int, Int, Int, Int))\nconst measuredTree = tree => {\n    // A tree in which each node is tupled with\n    // a (leafSum, layerSum, nodeSum) measure of its sub-tree,\n    // where leafSum is the number of descendant leaves,\n    // and layerSum is the number of descendant levels,\n    // and nodeSum counts all nodes, including the root.\n    // Index is a position in a zero-based top-down\n    // left to right series. \n    // For additional parent indices, see parentIndexedTree.\n    const whni = (w, h, n, i) => ({\n        leafSum: w,\n        layerSum: h,\n        nodeSum: n,\n        index: i\n    });\n    let i = 0;\n    return foldTree(\n        x => {\n            let topDown = i++;\n            return xs => Node(\n                Tuple(x)(\n                    0 < xs.length ? (() => {\n                        const dct = xs.reduce(\n                            (a, node) => {\n                                const dimns = node.root[1];\n                                return whni(\n                                    a.leafSum + dimns.leafSum,\n                                    max(a.layerSum)(\n                                        dimns.layerSum\n                                    ),\n                                    a.nodeSum + dimns.nodeSum,\n                                    topDown\n                                );\n                            }, whni(0, 0, 0, topDown)\n                        );\n                        return whni(\n                            dct.leafSum,\n                            1 + dct.layerSum,\n                            1 + dct.nodeSum,\n                            topDown\n                        );\n                    })() : whni(1, 0, 1, topDown)\n                )\n            )(xs);\n        }\n    )(tree);\n};",
  "member": "// member :: Key -> Dict -> Bool\nconst member = k => dct => k in dct;",
  "min": "// min :: Ord a => a -> a -> a\nconst min = a => b => b < a ? b : a;",
  "minBound": "// minBound :: a -> a\nconst minBound = x => {\n    const e = x.enum;\n    return Boolean(e) ? (\n        e[e[0]]\n    ) : {\n        'number': Number.MIN_SAFE_INTEGER,\n        'string': String.fromCodePoint(0),\n        'boolean': false\n    }[typeof x];\n};",
  "minimum": "// minimum :: Ord a => [a] -> a\nconst minimum = xs =>\n    0 < xs.length ? (\n        xs.slice(1)\n        .reduce((a, x) => x < a ? x : a, xs[0])\n    ) : undefined;",
  "minimumBy": "//Ordering: (LT|EQ|GT):\n//  GT: 1 (or other positive n)\n//\tEQ: 0\n//  LT: -1 (or other negative n)\n\n// minimumBy :: (a -> a -> Ordering) -> [a] -> a\nconst minimumBy = f => xs =>\n    xs.reduce((a, x) => undefined === a ? x : (\n        0 > f(x)(a) ? x : a\n    ), undefined);",
  "minimumByMay": "// minimumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\nconst minimumByMay = f =>\n    xs => xs.reduce((a, x) =>\n        a.Nothing ? Just(x) : (\n            f(x)(a.Just) < 0 ? Just(x) : a\n        ), Nothing());",
  "minimumMay": "// minimumMay :: [a] -> Maybe a\nconst minimumMay = xs =>\n    0 < xs.length ? (\n        Just(xs.slice(1)\n            .reduce((a, x) => x < a ? x : a, xs[0])\n        )\n    ) : Nothing();",
  "mod": "// mod :: Int -> Int -> Int\nconst mod = n => d => n % d;",
  "modificationTime": "// modificationTime :: FilePath -> Either String Date\nconst modificationTime = fp =>\n    bindLR(fileStatus(fp))(\n       dct => Right(ObjC.unwrap(dct.NSFileModificationDate))\n    );",
  "mul": "// mul (*) :: Num a => a -> a -> a\nconst mul = a => b => a * b;",
  "ne": "// ne :: a -> a -> Bool\nconst ne = a => b => a !== b;",
  "negate": "// negate :: Num -> Num\nconst negate = n => -n;",
  "nest": "// nest :: Tree a -> [a]\nconst nest = tree => {\n    // Allowing for lazy (on-demand) evaluation.\n    // If the nest turns out to be a function –\n    // rather than a list – that function is applied\n    // here to the root, and returns a list.\n    const xs = tree.nest;\n    return 'function' !== typeof xs ? (\n        xs\n    ) : xs(root(x));\n};",
  "newUUID": "// newUUID :: () -> IO UUID String\nconst newUUID = () =>\n    ObjC.unwrap($.NSUUID.UUID.UUIDString);",
  "not": "// not :: Bool -> Bool\nconst not = b => !b;",
  "notElem": "// notElem :: Eq a => a -> [a] -> Bool\nconst notElem = x => xs =>\n    !xs.includes(x);",
  "nub": "// nub :: [a] -> [a]\nconst nub = xs => \n  nubBy(eq)(xs);",
  "nubBy": "// nubBy :: (a -> a -> Bool) -> [a] -> [a]\nconst nubBy = fEq => {\n    const go = xs => 0 < xs.length ? (() => {\n        const x = xs[0];\n        return [x].concat(\n            go(xs.slice(1)\n                .filter(y => !fEq(x)(y))\n            )\n        )\n    })() : [];\n    return go;\n};",
  "odd": "// odd :: Int -> Bool\nconst odd = n => !even(n);",
  "on": "// on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\nconst on = f =>\n    // e.g. sortBy(on(compare,length), xs)\n    g => a => b => f(g(a))(g(b));",
  "op": "// Derive a function from the name of a JS infix operator\n\n// op :: String -> (a -> a -> b)\nconst op = strOp =>\n    eval(`(a, b) => a ${strOp} b`);",
  "or": "// or :: [Bool] -> Bool\nconst or = xs =>\n    xs.some(Boolean);",
  "ord": "// ord :: Char -> Int\nconst ord = c => c.codePointAt(0);",
  "ordering": "// ordering :: () -> Ordering\nconst\n    ordering = enumFromPairs(\n        'Ordering', \n        [['LT', -1], ['EQ', 0], ['GT', 1]]\n    ),\n    LT = ordering.LT,\n    EQ = ordering.EQ,\n    GT = ordering.GT;",
  "outdented": "// All lines in the string outdented by the same amount\n// (just enough to ensure that the least indented lines \n//  have no remaining indent)\n// All relative indents are left unchanged\n\n// outdented :: String -> String\nconst outdented = s => {\n    const\n        rgx = /^ */, // Leading space characters.\n        xs = lines(s),\n        n = length(minimumBy(comparing(length))(\n            xs.map(txt => rgx.exec(txt)[0])\n        ));\n    return unlines(map(drop(n))(xs));\n};",
  "parentIndexedTree": "// parentIndexedTree :: Tree (a, {...index :: Int}) ->\n// Tree (a, {...index :: Int, parent :: Maybe Int})\nconst parentIndexedTree = tree => {\n    // A tree additionally decorated with parent indices,\n    // derived from a measured tree already decorated with\n    // node indices. (See measuredTree).\n    const go = mb => node => {\n        const\n            x = node.root,\n            measures = x[1];\n        return Node(Tuple(x[0])(\n            Object.assign(measures, {\n                parent: mb\n            })\n        ))(node.nest.map(go(Just(measures.index))));\n    };\n    return go(Nothing())(tree);\n};",
  "partition": "// partition :: (a -> Bool) -> [a] -> ([a], [a])\nconst partition = p => xs =>\n    xs.reduce(\n        (a, x) =>\n        p(x) ? (\n            Tuple(a[0].concat(x))(a[1])\n        ) : Tuple(a[0])(a[1].concat(x)),\n        Tuple([])([])\n    );",
  "partitionEithers": "// partitionEithers :: [Either a b] -> ([a],[b])\nconst partitionEithers = xs =>\n    xs.reduce(\n        (a, x) => undefined !== x.Left ? (\n            Tuple(a[0].concat(x.Left))(a[1])\n        ) : Tuple(a[0])(a[1].concat(x.Right)),\n        Tuple([])([])\n    );",
  "permutations": "// permutations :: [a] -> [[a]]\nconst permutations = xs =>\n    xs.reduceRight(\n        (a, x) => a.flatMap(\n            xs => Array.from({\n                length: 1 + xs.length\n            }, (_, i) => i)\n            .map(n => xs.slice(0, n)\n                .concat(x)\n                .concat(xs.slice(n))\n            )\n        ),\n        [[]]\n    );",
  "permutationsWithRepetition": "// permutationsWithRepetition :: Int -> [a] -> [[a]]\nconst permutationsWithRepetition = n => xs =>\n    0 < xs.length ? (\n        map(flatten)(\n            foldl1(x => cartesianProduct(xs, x))(\n                replicate(n)(xs)\n            )\n        )\n    ) : [];",
  "pi": "// pi :: Float\nconst pi = Math.PI;",
  "plus": "// plus :: Num -> Num -> Num\nconst plus = a => b => a + b;",
  "postorder": "// postorder :: Tree a -> [a]\nconst postorder = t => {\n    // List of reoot elements of tree flattened\n    // bottom-up into a postorder list.\n    const go = (xs, x) =>\n        nest(x).reduce(go, xs).concat(root(x));\n    return go([], t);\n};",
  "pred": "// pred :: Enum a => a -> a\nconst pred = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mn] = [x, minBound(x)].map(fromEnum);\n        return i > mn ? (\n            toEnum(x)(i - 1)\n        ) : Error('succ :: enum out of range.')\n    })() : x > Number.MIN_SAFE_INTEGER ? (\n        x - 1\n    ) : Error('succ :: Num out of range.')\n};",
  "predMay": "// predMay :: Enum a => a -> Maybe a\nconst predMay = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mn] = [x, minBound(x)].map(fromEnum);\n        return i > mn ? (\n            Just(toEnum(x)(i - 1))\n        ) : Nothing()\n    })() : x > Number.MIN_SAFE_INTEGER ? (\n        Just(x - 1)\n    ) : Nothing()\n};",
  "print": "// print :: a -> IO ()\nconst print = x => {\n    const s = show(x);\n    return (\n        typeof document !== 'undefined' ? (\n            document.writeln(s)\n        ) : typeof draft !== 'undefined' ? (\n            editor.setText(\n                editor.getText() + '\\n' + s\n            )\n        ) : (\n            console.log(s),\n            s\n        )\n    );\n};",
  "product": "// product :: [Num] -> Num\nconst product = xs =>\n    xs.reduce((a, x) => a * x, 1);",
  "properFracRatio": "// properFracRatio :: Ratio -> (Int, Ratio)\nconst properFracRatio = nd => {\n    const [q, r] = Array.from(quotRem(nd.n, nd.d));\n    return Tuple(q, ratio(r, nd.d));\n};",
  "properFraction": "// properFraction :: Real -> (Int, Real)\nconst properFraction = n => {\n    const i = Math.floor(n) + (n < 0 ? 1 : 0);\n    return Tuple(i)(n - i);\n};",
  "pureLR": "// pureLR :: a -> Either e a\nconst pureLR = x => Right(x);",
  "pureList": "// pureList :: a -> [a]\nconst pureList = x => [x];",
  "pureMay": "// pureMay :: a -> Maybe a\nconst pureMay = x => Just(x);",
  "pureT": "// Given a type name string, returns a \n// specialised 'pure', where\n// 'pure' lifts a value into a particular functor.\n\n// pureT :: String -> f a -> (a -> f a)\nconst pureT = t => x =>\n    'List' !== t ? (\n        'Either' === t ? (\n            pureLR(x)\n        ) : 'Maybe' === t ? (\n            pureMay(x)\n        ) : 'Node' === t ? (\n            pureTree(x)\n        ) : 'Tuple' === t ? (\n            pureTuple(x)\n        ) : pureList(x)\n    ) : pureList(x);",
  "pureTree": "// pureTree :: a -> Tree a\nconst pureTree = x =>\n    Node(x)([]);",
  "pureTuple": "// pureTuple :: a -> (a, a)\nconst pureTuple = x =>\n    Tuple('')(x);",
  "quickSort": "// Included only for comparison with AppleScript\n// sort and sortBy are faster and more flexible\n\n// quickSort :: (Ord a) => [a] -> [a]\nconst quickSort = xs =>\n    xs.length > 1 ? (() => {\n        const\n            h = xs[0],\n            lessMore = partition(x => x <= h)(\n                xs.slice(1)\n            );\n        return [].concat.apply(\n            [], [quickSort(lessMore[0]), h, quickSort(lessMore[1])]\n        );\n    })() : xs;",
  "quickSortBy": "// Included only for comparison with AppleScript\n// sort and sortBy are faster and more flexible\n\n// quickSortBy :: (a -> a -> Ordering) -> [a] -> [a]\nconst quickSortBy = cmp => xs =>\n    xs.length > 1 ? (() => {\n        const\n            h = xs[0],\n            lessMore = partition(x => 1 !== cmp(x, h))(\n                xs.slice(1)\n            );\n        return [].concat.apply(\n            [], [quickSortBy(cmp, lessMore[0]), h, quickSortBy(cmp, lessMore[1])]\n        );\n    })() : xs;",
  "quot": "// quot :: Int -> Int -> Int\nconst quot = n =>\n    m => Math.floor(n / m);",
  "quotRem": "// quotRem :: Int -> Int -> (Int, Int)\nconst quotRem = m => n => \n  Tuple(Math.floor(m / n))(\n      m % n\n  );",
  "quoted": "// quoted :: Char -> String -> String\nconst quoted = c =>\n    // A string flanked on both sides\n    // by a specified quote character.\n    s => c + s + c",
  "radians": "// radians :: Float x => Degrees x -> Radians x\nconst radians = x =>\n    (Math.PI / 180) * x;",
  "raise": "// raise :: Num -> Int -> Num\nconst raise = n => e => Math.pow(n, e);",
  "randomRInt": "// e.g. map(randomRInt(1, 10), ft(1, 20))\n\n// randomRInt :: Int -> Int -> IO () -> Int\nconst randomRInt = low => high => () =>\n    low + Math.floor(\n        (Math.random() * ((high - low) + 1))\n    );",
  "range": "// The list of values in the subrange defined by a bounding pair.\n\n// range([0, 2]) -> [0,1,2]\n// range([[0,0], [2,2]]) \n//  -> [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\n// range([[0,0,0],[1,1,1]])\n//  -> [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]\n\n// range :: Ix a => (a, a) -> [a]\nfunction range() {\n    const\n        args = Array.from(arguments),\n        ab = 1 !== args.length ? (\n            args\n        ) : args[0],\n        [as, bs] = [ab[0], ab[1]].map(\n            x => Array.isArray(x) ? (\n                x\n            ) : (undefined !== x.type) &&\n            (x.type.startsWith('Tuple')) ? (\n                listFromTuple(x)\n            ) : [x]\n        ),\n        an = as.length;\n    return (an === bs.length) ? (\n        1 < an ? (\n            traverseList(x => x)(\n                as.map((_, i) => enumFromTo(as[i])(bs[i]))\n            )\n        ) : enumFromTo(as[0])(bs[0])\n    ) : [];\n};",
  "ratio": "// ratio :: Int -> Int -> Ratio Int\nconst ratio = x => y => {\n  const go = (x, y) =>\n    0 !== y ? (() => {\n      const d = gcd(x)(y);\n      return {\n        type: 'Ratio',\n        'n': quot(x)(d), // numerator\n        'd': quot(y)(d) // denominator\n      };\n    })() : undefined;\n  return go(x * signum(y), abs(y));\n};",
  "ratioDiv": "// ratioDiv :: Rational -> Rational -> Rational\nconst ratioDiv = n1 => n2 => {\n    const [r1, r2] = map(rational)(\n        [n1, n2]\n    );\n    return ratio(r1.n * r2.d)(\n        r1.d * r2.n\n    );\n};",
  "ratioMinus": "// ratioMinus :: Rational -> Rational -> Rational\nconst ratioMinus = n1 => n2 => {\n    const [r1, r2] = [n1, n2].map(rational);\n    const d = lcm(r1.d)(r2.d);\n    return ratio((r1.n * (d / r1.d)) - (r2.n * (d / r2.d)))(\n        d\n    );\n};",
  "ratioMult": "// ratioMult :: Rational -> Rational -> Rational\nconst ratioMult = n1 => n2 => {\n    const [r1, r2] = map(rational)(\n        [n1, n2]\n    );\n    return ratio(r1.n * r2.n)(\n        r1.d * r2.d\n    );\n};",
  "ratioPlus": "// ratioPlus :: Rational -> Rational -> Rational\nconst ratioPlus = n1 =>\n    n2 => {\n        const [r1, r2] = [n1, n2].map(rational);\n        const d = lcm(r1.d)(r2.d);\n        return ratio((r1.n * (d / r1.d)) + (r2.n * (d / r2.d)))(\n            d\n        );\n    };",
  "rational": "// rational :: Num a => a -> Rational\nconst rational = x =>\n    isNaN(x) ? x : Number.isInteger(x) ? (\n        ratio(x)(1)\n    ) : approxRatio(undefined)(x);",
  "read": "// read :: Read a => String -> a\nconst read = JSON.parse;",
  "readFile": "// readFile :: FilePath -> IO String\nconst readFile = fp => {\n    // The contents of a text file at the\n    // path file fp.\n    const\n        e = $(),\n        ns = $.NSString\n        .stringWithContentsOfFileEncodingError(\n            $(fp).stringByStandardizingPath,\n            $.NSUTF8StringEncoding,\n            e\n        );\n    return ObjC.unwrap(\n        ns.isNil() ? (\n            e.localizedDescription\n        ) : ns\n    );\n};",
  "readFileLR": "// readFileLR :: FilePath -> Either String IO String\nconst readFileLR = fp => {\n    const\n        e = $(),\n        ns = $.NSString\n        .stringWithContentsOfFileEncodingError(\n            $(fp).stringByStandardizingPath,\n            $.NSUTF8StringEncoding,\n            e\n        );\n    return ns.isNil() ? (\n        Left(ObjC.unwrap(e.localizedDescription))\n    ) : Right(ObjC.unwrap(ns));\n};",
  "readLR": "// readLR :: Read a => String -> Either String a\nconst readLR = s => {\n    try {\n        return Right(JSON.parse(s))\n    } catch (e) {\n        return Left(e.message);\n    };\n};",
  "recip": "// recip :: Num -> Num\nconst recip = n =>\n    0 !== n ? (1 / n) : undefined;",
  "recipMay": "// recipMay :: Num -> Maybe Num\nconst recipMay = n =>\n    0 === n ? (\n        Nothing()\n    ) : Just(1 / n);",
  "regexMatches": "// regexMatches :: Regex -> String -> [[String]]\nconst regexMatches = rgx =>\n    // All matches for the given regular expression\n    // in the supplied string s.\n    s => {\n        // Recompiled to ensure that any supplied \n        // regex is interpreted as global.\n        const r = new RegExp(rgx, 'g');\n        return unfoldr(\n            m => Boolean(m) ? (\n                Just(Tuple(m)(r.exec(s)))\n            ) : Nothing()\n        )(r.exec(s))\n    };",
  "rem": "// rem :: Int -> Int -> Int\nconst rem = n => m => n % m;",
  "removeFile": "// removeFile :: FilePath -> Either String String\nconst removeFile = fp => {\n  const error = $();\n  return $.NSFileManager.defaultManager\n    .removeItemAtPathError(fp, error) ? (\n      Right('Removed: ' + fp)\n    ) : Left(ObjC.unwrap(error.localizedDescription));\n};",
  "renameFile": "// renameFile :: FilePath -> FilePath -> IO ()\nconst renameFile = fp => fp2 => {\n    const error = $();\n    return $.NSFileManager.defaultManager\n        .moveItemAtPathToPathError(fp, fp2, error) ? (\n            Right('Moved to: ' + fp2)\n        ) : Left(ObjC.unwrap(error.localizedDescription));\n};",
  "repeat": "// repeat :: a -> Generator [a]\nfunction* repeat(xs) {\n    while(true) yield xs;\n}",
  "replace": "// replace :: String -> String -> String -> String\n// replace :: Regex -> String -> String -> String\nconst replace = needle => strNew => strHaystack =>\n    strHaystack.replace(\n      'string' !== typeof needle ? (\n        needle\n      ) : new RegExp(needle, 'g'),\n      strNew\n    );",
  "replicate": "// replicate :: Int -> a -> [a]\nconst replicate = n =>\n    // A list of n copies of x.\n    x => Array.from({\n        length: n\n    }, () => x);",
  "replicateM": "// Instance for lists (arrays) only here\n\n// replicateM :: Int -> [a] -> [[a]]\nconst replicateM = n => xs => {\n    const go = x => 0 >= x ? [\n        []\n    ] : liftA2List(cons)(\n        xs\n    )(go(x - 1));\n    return go(n);\n};",
  "replicateString": "// replicateString :: Int -> String -> String\nconst replicateString = n => \n    s => s.repeat(n);",
  "reverse": "// reverse :: [a] -> [a]\nconst reverse = xs =>\n    'string' !== typeof xs ? (\n        xs.slice(0).reverse()\n    ) : xs.split('').reverse().join('');",
  "rights": "// rights :: [Either a b] -> [b]\nconst rights = xs =>\n    xs.flatMap(\n        x => ('Either' === x.type) && (\n            undefined !== x.Right\n        ) ? [x.Right] : []\n    );",
  "root": "// root :: Tree a -> a\nconst root = tree => tree.root;",
  "rotate": "// rotate :: Int -> [a] -> [a]\nconst rotate = n => xs => {\n    const lng = xs.length;\n    return Infinity > lng ? (\n        take(lng)(\n            drop(lng - n)(\n                cycle(xs)\n            )\n        )\n    ) : undefined;\n};",
  "round": "// round :: a -> Int\nconst round = x => {\n    const\n        nr = properFraction(x),\n        [n, r] = [nr[0], nr[1]],\n        m = n + (r < 0 ? -1 : 1),\n        sign = signum(abs(r) - 0.5);\n    return (-1 === sign) ? n : (\n        0 === sign ? (even(n) ? n : m) : (\n            1 === sign ? m : undefined\n        )\n    );\n};",
  "roundTo": "// roundTo :: Int -> Float -> Float\nconst roundTo = n => x => {\n    const d = Math.pow(10, n);\n    return Math.round(x * d) / d;\n};",
  "runAction": "// runAction :: Action a -> a\nconst runAction = act =>\n    // Evaluation of an action.\n    act['act'](act['arg']);",
  "safeMay": "// safeMay :: (a -> Bool) -> (a -> b) -> Maybe b\nconst safeMay = p => f => x =>\n    p(x) ? Just(f(x)) : Nothing();",
  "scanl": "// scanl :: (b -> a -> b) -> b -> [a] -> [b]\nconst scanl = f => startValue => xs =>\n    xs.reduce((a, x) => {\n        const v = f(a[0])(x);\n        return Tuple(v)(a[1].concat(v));\n    }, Tuple(startValue)([startValue]))[1];",
  "scanl1": "// scanl1 is a variant of scanl that has no starting value argument\n\n// scanl1 :: (a -> a -> a) -> [a] -> [a]\nconst scanl1 = f => xs =>\n    xs.length > 0 ? (\n        scanl(f)(\n            xs[0]\n        )(xs.slice(1))\n    ) : [];",
  "scanr": "// scanr :: (b -> a -> b) -> b -> [a] -> [b]\nconst scanr = f => startValue => xs =>\n    xs.reduceRight((a, x) => {\n        const v = f(x)(a[0]);\n        return Tuple(v)([v].concat(a[1]));\n    }, Tuple(startValue)([startValue]))[1];",
  "scanr1": "// scanr1 :: (a -> a -> a) -> [a] -> [a]\nconst scanr1 = f =>\n    // scanr1 is a variant of scanr that has no \n    // seed-value argument, and assumes that\n    // xs is not empty.\n    xs => xs.length > 0 ? (\n        scanr(f)(\n            xs.slice(-1)[0]\n        )(xs.slice(0, -1))\n    ) : [];",
  "secondArrow": "// secondArrow :: (a -> b) -> ((c, a) -> (c, b))\nconst secondArrow = f =>\n    // A function over a simple value lifted\n    // to a function over a tuple.\n    // f (a, b) -> (a, f(b))\n    xy => Tuple(xy[0])(\n        f(xy[1])\n    );",
  "sequenceA": "// sequenceA :: (Applicative f, Traversable t) => t (f a) -> f (t a)\nconst sequenceA = tfa =>\n    traverse(x => x)(\n        tfa\n    );",
  "setCurrentDirectory": "// setCurrentDirectory :: String -> IO ()\nconst setCurrentDirectory = strPath =>\n    $.NSFileManager.defaultManager\n    .changeCurrentDirectoryPath(\n        ObjC.wrap(strPath)\n        .stringByStandardizingPath\n    );",
  "setFromList": "// setFromList :: Ord a => [a] -> Set a\nconst setFromList = xs =>\n    new Set(xs);",
  "setInsert": "// setInsert :: Ord a => a -> Set a -> Set a\nconst setInsert = x => oSet =>\n    oSet.add(x);",
  "setMember": "// setMember :: Ord a => a -> Set a -> Bool\nconst setMember = x => oSet =>\n    oSet.has(x);",
  "setSize": "// setSize :: Set a -> Int\nconst setSize = oSet =>\n    oSet.size;",
  "shift": "// shift :: Int -> [a] -> [a]\nconst shift = n => xs => {\n    const lng = length(xs);\n    return Infinity > lng ? (\n        take(lng)(\n          drop(n)(cycle(xs))\n        )\n    ) : (drop(n)(xs), xs);\n};",
  "show": "// show :: a -> String\n// show :: a -> Int -> Indented String\nconst show = x => {\n    const\n        e = ('function' !== typeof x) ? (\n            x\n        ) : {\n            type: 'Function',\n            f: x\n        };\n    return JSON.stringify(e, (_, v) => {\n        const\n            f = ((null !== v) && (undefined !== v)) ? (() => {\n                const t = v.type;\n                return 'Either' === t ? (\n                    showLR\n                ) : 'Function' === t ? (\n                    dct => 'λ' + dct.f.toString()\n                ) : 'Maybe' === t ? (\n                    showMaybe\n                ) : 'Ordering' === t ? (\n                    showOrdering\n                ) : 'Ratio' === t ? (\n                    showRatio\n                ) : 'string' === typeof t && t.startsWith('Tuple') ? (\n                    showTuple\n                ) : undefined;\n            })() : showUndefined;\n        return Boolean(f) ? (\n            f(v)\n        ) : 'string' !== typeof v ? (\n            v\n        ) : v;\n    })\n};",
  "showBinary": "// showBinary :: Int -> String\nconst showBinary = n => {\n    const binaryChar = n => 0 !== n ? '1' : '0';\n    return showIntAtBase(2)(\n        binaryChar\n    )(n)('');\n};",
  "showDate": "// showDate :: Date -> String\nconst showDate = JSON.stringify;",
  "showDict": "// showDict :: Dict -> String\nconst showDict = show;",
  "showForest": "// showForest :: [Tree a] -> String\nconst showForest = xs =>\n    unlines(xs.map(x => drawTree2(false)(true)(\n        fmapTree(show)(\n            x\n        )\n    )));",
  "showHex": "// showHex :: Int -> String\nconst showHex = n =>\n    showIntAtBase(16)(\n        intToDigit\n    )(n)('');",
  "showIntAtBase": "// showIntAtBase :: Int -> (Int -> Char) -> Int -> String -> String\nconst showIntAtBase = base => toChr => n => rs => {\n    const go = ([n, d], r) => {\n        const r_ = toChr(d) + r;\n        return 0 !== n ? (\n            go(Array.from(quotRem(n)(base)), r_)\n        ) : r_;\n    };\n    return 1 >= base ? (\n        'error: showIntAtBase applied to unsupported base'\n    ) : 0 > n ? (\n        'error: showIntAtBase applied to negative number'\n    ) : go(Array.from(quotRem(n)(base)), rs);\n};",
  "showJSON": "// showJSON :: a -> String\nconst showJSON = x =>\n    // Indented JSON representation of the value x.\n    JSON.stringify(x, null, 2);",
  "showLR": "// showLR :: Either a b -> String\nconst showLR = lr => {\n    const k = undefined !== lr.Left ? (\n        'Left'\n    ) : 'Right';\n    return k + '(' + unQuoted(show(lr[k])) + ')';\n};",
  "showList": "// showList :: [a] -> String\nconst showList = x => show(x);",
  "showLog": "// showLog :: a -> IO ()\nconst showLog = (...args) =>\n    console.log(\n        args\n        .map(JSON.stringify)\n        .join(' -> ')\n    );",
  "showMaybe": "// showMaybe :: Maybe a -> String\nconst showMaybe = mb =>\n    mb.Nothing ? (\n        'Nothing'\n    ) : 'Just(' + unQuoted(show(mb.Just)) + ')';",
  "showMenuLR": "// showMenuLR :: Bool -> String -> [String] -> \n// Either String [String]\nconst showMenuLR = blnMult =>\n    title => xs => 0 < xs.length ? (() => {\n        const sa = Object.assign(\n            Application('System Events'), {\n                includeStandardAdditions: true\n            });\n        sa.activate();\n        const v = sa.chooseFromList(xs, {\n            withTitle: title,\n            withPrompt: 'Select' + (\n                blnMult ? (\n                    ' one or more of ' +\n                    xs.length.toString()\n                ) : ':'\n            ),\n            defaultItems: xs[0],\n            okButtonName: 'OK',\n            cancelButtonName: 'Cancel',\n            multipleSelectionsAllowed: blnMult,\n            emptySelectionAllowed: false\n        });\n        return Array.isArray(v) ? (\n            Right(v)\n        ) : Left('User cancelled ' + title + ' menu.');\n    })() : Left(title + ': No items to choose from.');",
  "showOrdering": "// showOrdering :: Ordering -> String\nconst showOrdering = e =>\n    0 < e.value ? (\n        'GT'\n    ) : 0 > e.value ? (\n        'LT'\n    ) : 'EQ';",
  "showOutline": "// showOutline :: Tree String -> String\nconst showOutline = tree => {\n    const go = indent => tree =>\n        unlines(\n            [indent + tree.root]\n            .concat(tree.nest.flatMap(go('    ' + indent)))\n        );\n    return go('')(tree);\n};",
  "showPrecision": "// showPrecision :: Int -> Float -> String\nconst showPrecision = n => x => {\n    // A string showing a floating point number\n    // at a given degree of precision.\n    const d = Math.pow(10, n);\n    return str(Math.round(d * x) / d);\n};",
  "showRatio": "// showRatio :: Ratio -> String\nconst showRatio = r =>\n    'Ratio' !== r.type ? (\n        r.toString()\n    ) : r.n.toString() + (\n        1 !== r.d ? (\n            '/' + r.d.toString()\n        ) : ''\n    );",
  "showSet": "// showSet :: Set a -> String\nconst showSet = oSet =>\n    '{' + Array.from(oSet)\n    .map(x => x.toString())\n    .join(',') + '}';",
  "showTree": "// showTree :: Tree a -> String\nconst showTree = x =>\n    drawTree2(false)(true)(\n        fmapTree(show)(x)\n    );",
  "showTuple": "// showTuple :: Tuple -> String\nconst showTuple = tpl =>\n    '(' + enumFromTo(0)(tpl.length - 1)\n    .map(x => unQuoted(show(tpl[x])))\n    .join(',') + ')';",
  "showUndefined": "// showUndefined :: () -> String\nconst showUndefined = () => '(⊥)';",
  "signum": "// | Sign of a number.\n// The functions 'abs' and 'signum' should satisfy the law:\n//\n// > abs x * signum x == x\n//\n// For real numbers, the 'signum' is either @-1@ (negative), @0@ (zero)\n// or @1@ (positive).\n\n// signum :: Num -> Num\nconst signum = n => 0 > n ? -1 : (0 < n ? 1 : 0);",
  "sj": "// Abbreviation of showJSON for quick testing.\n// Default indent size is two, which can be\n// overriden by any integer supplied as the\n// first argument of more than one.\n\n// sj :: a -> String\nfunction sj() {\n    const args = Array.from(arguments);\n    return JSON.stringify.apply(\n        null,\n        1 < args.length && !isNaN(args[0]) ? [\n            args[1], null, args[0]\n        ] : [args[0], null, 2]\n    );\n}",
  "snd": "// snd :: (a, b) -> b\nconst snd = tpl => tpl[1];",
  "snoc": "// snoc :: [a] -> a -> [a]\nconst snoc = xs =>\n    // The mirror image of cons\n    // A new copy of the given list, \n    // with an atom appended at the end.\n    x => xs.concat(x);",
  "sort": "// sort :: Ord a => [a] -> [a]\nconst sort = xs => xs.slice()\n    .sort((a, b) => a < b ? -1 : (a > b ? 1 : 0));",
  "sortBy": "// sortBy :: (a -> a -> Ordering) -> [a] -> [a]\nconst sortBy = f =>\n    xs => xs.slice()\n    .sort((a, b) => f(a)(b));",
  "sortOn": "// sortOn :: Ord b => (a -> b) -> [a] -> [a]\nconst sortOn = f =>\n    // Equivalent to sortBy(comparing(f)), but with f(x)\n    // evaluated only once for each x in xs.\n    // ('Schwartzian' decorate-sort-undecorate).\n    xs => xs.map(\n        fanArrow(f)(identity)\n    )\n    .sort(uncurry(comparing(fst)))\n    .map(snd);",
  "span": "// span, applied to a predicate p and a list xs, returns a tuple of xs of \n// elements that satisfy p and second element is the remainder of the list:\n//\n// > span (< 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])\n// > span (< 9) [1,2,3] == ([1,2,3],[])\n// > span (< 0) [1,2,3] == ([],[1,2,3])\n//\n// span p xs is equivalent to (takeWhile p xs, dropWhile p xs) \n\n// span :: (a -> Bool) -> [a] -> ([a], [a])\nconst span = p => xs => {\n    const iLast = xs.length - 1;\n    return splitAt(\n        until(\n            i => iLast < i || !p(xs[i])\n        )(succ)(0)\n    )(xs);\n};",
  "splitArrow": "// splitArrow (***) :: (a -> b) -> (c -> d) -> ((a, c) -> (b, d))\nconst splitArrow = f =>\n    // The functions f and g combined in a single function\n    // from a tuple (x, y) to a tuple of (f(x), g(y))\n    g => tpl => Tuple(f(tpl[0]))(\n        g(tpl[1])\n    );",
  "splitAt": "// splitAt :: Int -> [a] -> ([a], [a])\nconst splitAt = n => xs => \n  Tuple(xs.slice(0, n))(\n      xs.slice(n)\n  );",
  "splitBy": "// splitBy :: (a -> a -> Bool) -> [a] -> [[a]]\n// splitBy :: (String -> String -> Bool) -> String -> [String]\nconst splitBy = p =>\n    // Splitting not on a delimiter, but wherever the relationship\n    // between consecutive terms matches a binary predicate.\n    xs => (xs.length < 2) ? [xs] : (() => {\n        const\n            bln = 'string' === typeof xs,\n            ys = bln ? xs.split('') : xs,\n            h = ys[0],\n            parts = ys.slice(1)\n            .reduce(([acc, active, prev], x) =>\n                p(prev)(x) ? (\n                    [acc.concat([active]), [x], x]\n                ) : [acc, active.concat(x), x], [\n                    [],\n                    [h],\n                    h\n                ]);\n        return (bln ? (\n            ps => ps.map(cs => ''.concat.apply('', cs))\n        ) : x => x)(parts[0].concat([parts[1]]));\n    })();",
  "splitFileName": "// splitFileName :: FilePath -> (String, String)\nconst splitFileName = strPath =>\n    // Tuple of directory and file name, derived from file path.\n    // Inverse of combine.\n    ('' !== strPath) ? (\n         ('/' !== strPath[strPath.length - 1]) ? (() => {\n            const\n                xs = strPath.split('/'),\n                stem = xs.slice(0, -1);\n            return stem.length > 0 ? (\n                Tuple(stem.join('/') + '/')(xs.slice(-1)[0])\n            ) : Tuple('./')(xs.slice(-1)[0]);\n        })() : Tuple(strPath)('')\n    ) : Tuple('./')('');",
  "splitOn": "// splitOn(\"\\r\\n\", \"a\\r\\nb\\r\\nd\\r\\ne\") //--> [\"a\", \"b\", \"d\", \"e\"]\n// splitOn(\"aaa\", \"aaaXaaaXaaaXaaa\") //--> [\"\", \"X\", \"X\", \"X\", \"\"]\n// splitOn(\"x\", \"x\") //--> [\"\", \"\"]\n// splitOn([3, 1], [1,2,3,1,2,3,1,2,3]) //--> [[1,2],[2],[2,3]]\n\n// splitOn :: [a] -> [a] -> [[a]]\n// splitOn :: String -> String -> [String]\nconst splitOn = pat => src =>\n    /* A list of the strings delimited by\n       instances of a given pattern in s. */\n    ('string' === typeof src) ? (\n        src.split(pat)\n    ) : (() => {\n        const\n            lng = pat.length,\n            tpl = findIndices(matching(pat))(src).reduce(\n                (a, i) => Tuple(\n                    fst(a).concat([src.slice(snd(a), i)])\n                )(lng + i),\n                Tuple([])(0),\n            );\n        return fst(tpl).concat([src.slice(snd(tpl))]);\n    })();",
  "splitRegex": "// splitRegex :: Regex -> String -> [String]\nconst splitRegex = needle => haystack =>\n    haystack.split(needle);",
  "sqrt": "// sqrt :: Num -> Num\nconst sqrt = n =>\n    (0 <= n) ? Math.sqrt(n) : undefined;",
  "sqrtLR": "// sqrtLR :: Num -> Either String Num\nconst sqrtLR = n =>\n    0 > n ? (\n        Left('Square root of negative number: ' + n)\n    ) : Right(Math.sqrt(n));",
  "sqrtMay": "// sqrtMay :: Num -> Maybe Num\nconst sqrtMay = n =>\n    0 > n ? (\n        Nothing()\n    ) : Just(Math.sqrt(n));",
  "str": "// str :: a -> String\nconst str = x =>\n    x.toString();",
  "strip": "// strip :: String -> String\nconst strip = s =>\n    s.trim();",
  "stripEnd": "// stripEnd :: String -> String\nconst stripEnd = s =>\n    s.trimEnd();",
  "stripPrefix": "// stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]\nconst stripPrefix = pfx =>\n    s => {\n        const\n            blnString = 'string' === typeof pfx,\n            [xs, ys] = blnString ? (\n                [pfx.split(''), s.split('')]\n            ) : [pfx, s];\n        const\n            sp_ = (xs, ys) => 0 === xs.length ? (\n                Just(blnString ? ys.join('') : ys)\n            ) : (0 === ys.length || xs[0] !== ys[0]) ? (\n                Nothing()\n            ) : sp_(xs.slice(1), ys.slice(1));\n        return sp_(xs, ys);\n    };",
  "stripStart": "// stripStart :: String -> String\nconst stripStart = s =>\n    s.trimStart();",
  "subTreeAtPath": "// subTreeAtPath :: Tree String -> [String] -> Maybe Tree String\nconst subTreeAtPath = tree => path => {\n    const go = (nest, xs) =>\n        0 < nest.length && 0 < xs.length ? (() => {\n            const h = xs[0];\n            return bindMay(find(t => h === t.root, nest))(\n                t => 1 < xs.length ? (\n                    go(t.nest, xs.slice(1))\n                ) : Just(t)\n            );\n        })() : Nothing();\n    return go([tree], path);\n};",
  "subsequences": "// subsequences([1,2,3]) -> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n// subsequences('abc') -> [\"\",\"a\",\"b\",\"ab\",\"c\",\"ac\",\"bc\",\"abc\"]\n\n// subsequences :: [a] -> [[a]]\n// subsequences :: String -> [String]\nconst subsequences = xs => {\n    const\n        // nonEmptySubsequences :: [a] -> [[a]]\n        nonEmptySubsequences = xxs => {\n            if (xxs.length < 1) return [];\n            const [x, xs] = [xxs[0], xxs.slice(1)];\n            const f = (r, ys) => cons(ys)(cons(cons(x)(ys))(r));\n            return cons([x])(nonEmptySubsequences(xs)\n                .reduceRight(f, []));\n        };\n    return ('string' === typeof xs) ? (\n        cons('')(nonEmptySubsequences(xs.split(''))\n            .map(x => ''.concat.apply('', x))) // map(concat)\n    ) : cons([])(nonEmptySubsequences(xs));\n};",
  "subsets": "// subsets :: [a] -> [[a]]\nconst subsets = xs => {\n    const go = ys =>\n        0 < ys.length ? (() => {\n            const\n                h = ys[0],\n                zs = go(ys.slice(1));\n            return zs.concat(\n                zs.map(z => [h].concat(z))\n            );\n        })() : [\n            []\n        ];\n    return go(xs);\n};",
  "subtract": "// subtract :: Num -> Num -> Num\nconst subtract = x =>\n    y => y - x;",
  "succ": "// succ :: Enum a => a -> a\nconst succ = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mx] = [x, maxBound(x)].map(fromEnum);\n        return i < mx ? (\n            toEnum(x)(1 + i)\n        ) : Error('succ :: enum out of range.')\n    })() : x < Number.MAX_SAFE_INTEGER ? (\n        1 + x\n    ) : Error('succ :: Num out of range.')\n};",
  "succMay": "// succMay :: Enum a => a -> Maybe a\nconst succMay = x => {\n    const t = typeof x;\n    return 'number' !== t ? (() => {\n        const [i, mx] = [x, maxBound(x)].map(fromEnum);\n        return i < mx ? (\n            Just(toEnum(x)(1 + i))\n        ) : Nothing()\n    })() : x < Number.MAX_SAFE_INTEGER ? (\n        Just(1 + x)\n    ) : Nothing()\n};",
  "sum": "// sum :: [Num] -> Num\nconst sum = xs =>\n    // The numeric sum of all values in xs.\n    xs.reduce((a, x) => a + x, 0);",
  "swap": "// swap :: (a, b) -> (b, a)\nconst swap = ab =>\n    // The pair ab with its order reversed.\n    Tuple(ab[1])(\n        ab[0]\n    );",
  "tail": "// tail :: [a] -> [a]\nconst tail = xs =>\n    // A new list consisting of all\n    // items of xs except the first.\n    0 < xs.length ? xs.slice(1) : [];",
  "tailMay": "// tailMay :: [a] -> Maybe [a]\nconst tailMay = xs =>\n    0 < xs.length ? (\n        Just(xs.slice(1))\n    ) : Nothing();",
  "tails": "// tails :: [a] -> [[a]]\nconst tails = xs => {\n    const\n        es = ('string' === typeof xs) ? (\n            xs.split('')\n        ) : xs;\n    return es.map((_, i) => es.slice(i))\n        .concat([\n            []\n        ]);\n};",
  "take": "// take :: Int -> [a] -> [a]\n// take :: Int -> String -> String\nconst take = n =>\n    // The first n elements of a list,\n    // string of characters, or stream.\n    xs => 'GeneratorFunction' !== xs\n    .constructor.constructor.name ? (\n        xs.slice(0, n)\n    ) : [].concat.apply([], Array.from({\n        length: n\n    }, () => {\n        const x = xs.next();\n        return x.done ? [] : [x.value];\n    }));",
  "takeAround": "// takeAround :: (a -> Bool) -> [a] -> [a]\nconst takeAround = p => xs => {\n    const ys = takeWhile(p)(xs);\n    return ys.length < xs.length ? (\n        ys.concat(takeWhileR(p)(xs))\n    ) : ys;\n};",
  "takeBaseName": "// takeBaseName :: FilePath -> String\nconst takeBaseName = strPath =>\n  ('' !== strPath) ? (\n    ('/' !== strPath[strPath.length - 1]) ? (() => {\n      const fn = strPath.split('/').slice(-1)[0];\n      return fn.includes('.') ? (\n        fn.split('.').slice(0, -1).join('.')\n      ) : fn;\n    })() : ''\n  ) : '';",
  "takeCycle": "// First n members of an infinite cycle of xs\n\n// takeCycle :: Int -> [a] -> [a]\nconst takeCycle = n =>\n    // First n elements of a non-finite cycle of xs.\n    xs => {\n        const lng = xs.length;\n        return (\n            n <= xs ? (\n                xs\n            ) : concat(\n                replicate(Math.ceil(n / lng))(\n                    xs\n                )\n            )\n        ).slice(0, n)\n    };",
  "takeDirectory": "// takeDirectory :: FilePath -> FilePath\nconst takeDirectory = strPath =>\n    ('' !== strPath) ? (() => {\n        const xs = (strPath.split('/'))\n            .slice(0, -1);\n        return xs.length > 0 ? (\n            xs.join('/')\n        ) : '.';\n    })() : '.';",
  "takeDropCycle": "// take N Members of an infinite cycle of xs, starting from index I\n\n// take N Members of an infinite cycle of xs, starting from index I\n// takeDropCycle :: Int -> [a] -> [a]\nconst takeDropCycle = n => i => xs => {\n    const\n        lng = xs.length,\n        m = n + i;\n    return drop(i)(\n        take(m)(\n            lng >= m ? (\n                xs\n            ) : concat(\n                replicate(Math.ceil(m / lng)(\n                    xs\n                ))\n            )\n        )\n    )\n};",
  "takeExtension": "// takeExtension :: FilePath -> String\nconst takeExtension = fp => {\n    const fs = fp.split('/');\n    return 0 < fs.length ? (() => {\n        const\n            xs = fs.slice(-1)[0].split('.'),\n            ext = 1 < xs.length ? (\n                xs.slice(-1)[0]\n            ) : '';\n        return '.' + ext;\n    })() : '';\n};",
  "takeFileName": "// takeFileName :: FilePath -> FilePath\nconst takeFileName = strPath =>\n    '' !== strPath ? (\n        ('/' !== strPath[strPath.length - 1]) ? (\n            strPath.split('/')\n            .slice(-1)[0]\n        ) : ''\n    ) : '';",
  "takeFromThenTo": "// takeFromThenTo :: Int -> Int -> Int -> [a] -> [a]\nconst takeFromThenTo = a => b => z => xs => {\n    const ixs = enumFromThenTo(a)(b)(z);\n    return 'GeneratorFunction' !== xs.constructor.constructor.name ? (\n        ixs.map(i => xs[i])\n    ) : (() => {\n        const g = zipGen(enumFrom(0))(\n            take(z)(xs)\n        );\n        return ixs.flatMap(i => {\n            const mb = index(g)(i);\n            return mb.Nothing ? [] : [mb.Just];\n        });\n    })();\n};",
  "takeIterate": "// takeIterate n f x == [x, f x, f (f x), ...]\n\n// takeIterate n f x == [x, f x, f (f x), ...]\n// takeIterate :: Int -> (a -> a) -> a -> [a]\nconst takeIterate = n => f => x =>\n    snd(mapAccumL(a => _ => i => {\n        const v = 0 !== i ? f(a) : x;\n        return [v, v];\n    }, x, Array.from({\n        length: n\n    })));",
  "takeWhile": "// takeWhile :: (a -> Bool) -> [a] -> [a]\n// takeWhile :: (Char -> Bool) -> String -> String\nconst takeWhile = p => xs =>\n    xs.constructor.constructor.name !==\n    'GeneratorFunction' ? (() => {\n        const lng = xs.length;\n        return 0 < lng ? xs.slice(\n            0,\n            until(i => lng === i || !p(xs[i]))(\n                i => 1 + i\n            )(0)\n        ) : [];\n    })() : takeWhileGen(p)(xs);",
  "takeWhileGen": "// takeWhileGen :: (a -> Bool) -> Gen [a] -> [a]\nconst takeWhileGen = p => xs => {\n    const ys = [];\n    let\n        nxt = xs.next(),\n        v = nxt.value;\n    while (!nxt.done && p(v)) {\n        ys.push(v);\n        nxt = xs.next();\n        v = nxt.value\n    }\n    return ys;\n};",
  "takeWhileR": "// takeWhileR :: (a -> Bool) -> [a] -> [a]\nconst takeWhileR = p => xs => {\n    let i = xs.length;\n    while (i-- && p(xs[i])) {}\n    return xs.slice(i + 1);\n};",
  "taskPaperDateString": "// taskPaperDateString :: Date -> String\nconst taskPaperDateString = dte => {\n    const [d, t] = iso8601Local(new Date()).split('T');\n    return [d, t.slice(0, 5)].join(' ');\n};",
  "tempFilePath": "// File name template to temporary path\n// Random digit sequence inserted between template base and extension\n\n// tempFilePath :: String -> IO FilePath\nconst tempFilePath = template =>\n  ObjC.unwrap($.NSTemporaryDirectory()) +\n    takeBaseName(template) + Math.random()\n    .toString()\n    .substring(3) + takeExtension(template);",
  "then": "// then (>>) :: Monad m => m a -> m b -> m b\nconst then = ma => mb =>\n    (Array.isArray(ma) ? (\n        thenList\n    ) : isMaybe(ma) ? (\n        thenMay\n    ) : thenIO)(\n        ...[ma, mb]\n    )",
  "thenIO": "// thenIO (>>) :: IO a -> IO b -> IO b\nconst thenIO = ma => mb => mb;",
  "thenList": "// thenList (>>) :: [a] -> [b] -> [b]\nconst thenList = xs => ys =>\n    xs.flatMap(_ => ys);",
  "thenMay": "// thenMay (>>) :: Maybe a -> Maybe b -> Maybe b\nconst thenMay = mbx => mby =>\n    mbx.Nothing ? mbx : mby;",
  "toEnum": "// The first argument is a sample of the type\n// allowing the function to make the right mapping\n\n// toEnum :: a -> Int -> a\nconst toEnum = e => x =>\n    ({\n        'number': Number,\n        'string': String.fromCodePoint,\n        'boolean': Boolean,\n        'object': v => e.min + v\n    } [typeof e])(x);",
  "toLower": "// toLower :: String -> String\nconst toLower = s =>\n    // Lower-case version of string.\n    s.toLocaleLowerCase();",
  "toRatio": "// toRatio :: Real -> Ratio\nconst toRatio = n =>\n    approxRatio(1e-12)(n);",
  "toSentence": "// toSentence :: String -> String\nconst toSentence = s =>\n    // Sentence case - initial string capitalized \n    // and rest lowercase.\n    (0 < s.length) ? (\n        s[0].toUpperCase() + s.slice(1)\n        .toLowerCase()\n    ) : s;",
  "toTitle": "// NB this does not model any regional or cultural conventions.\n// It simply simply capitalizes the first character of each word.\n\n// toTitle :: String -> String\nconst toTitle = s =>\n    regexMatches(/(\\w)(\\w*)(\\b[\\W]*|$)/g)(s)\n    .map(ms => ms[1].toUpperCase() + ms[2].toLowerCase() + ms[3])\n    .join('');",
  "toUpper": "// toUpper :: String -> String\nconst toUpper = s =>\n    s.toLocaleUpperCase();",
  "transpose": "// If some of the rows are shorter than the following rows, \n// their elements are skipped:\n// > transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\n\n// transpose :: [[a]] -> [[a]]\nconst transpose = xss => {\n    const go = xss =>\n        0 < xss.length ? (() => {\n            const\n                h = xss[0],\n                t = xss.slice(1);\n            return 0 < h.length ? (\n                [\n                    [h[0]].concat(t.reduce(\n                        (a, xs) => a.concat(\n                            0 < xs.length ? (\n                                [xs[0]]\n                            ) : []\n                        ),\n                        []\n                    ))\n                ].concat(go([h.slice(1)].concat(\n                    t.map(xs => xs.slice(1))\n                )))\n            ) : go(t);\n        })() : [];\n    return go(xss);\n};",
  "transpose_": "// transpose_ :: [[a]] -> [[a]]\nconst transpose_ = rows =>\n    // The columns of the input transposed\n    // into new rows.\n    // Simpler version of transpose, assuming input \n    // rows of even length.\n    0 < rows.length ? rows[0].map(\n        (x, i) => rows.flatMap(\n            x => x[i]\n        )\n    ) : [];",
  "traverse": "// traverse :: (Applicative f, Traversable t) => \n// (a -> f b) -> t a -> f (t b)\nconst traverse = f => tx => {\n    const t = tx.type;\n    return (\n        undefined !== t ? (\n            'Either' === t ? (\n                traverseLR\n            ) : 'Maybe' === t ? (\n                traverseMay\n            ) : 'Node' === t ? (\n                traverseTree\n            ) : 'Tuple' === t ? (\n                traverseTuple\n            ) : traverseList\n        ) : traverseList\n    )(f)(tx)\n};",
  "traverseLR": "// instance Traversable (Either a) where\n//    traverse _ (Left x) = pure (Left x)\n//    traverse f (Right y) = Right <$> f y\n\n// traverseLR :: Applicative f => \n// (t -> f b) -> Either a t -> f (Either a b)\nconst traverseLR = f => lr =>\n    undefined !== lr.Left ? (\n        [lr]\n    ) : fmap(Right)(\n        f(lr.Right)\n    );",
  "traverseList": "// traverseList :: (Applicative f) => (a -> f b) -> [a] -> f [b]\nconst traverseList = f =>\n    // Collected results of mapping each element\n    // of a structure to an action, and evaluating\n    // these actions from left to right.\n    xs => 0 < xs.length ? (() => {\n        const\n            vLast = f(xs.slice(-1)[0]),\n            t = vLast.type || 'List';\n        return xs.slice(0, -1).reduceRight(\n            (ys, x) => liftA2(cons)(f(x))(ys),\n            liftA2(cons)(vLast)(pureT(t)([]))\n        );\n    })() : [\n        []\n    ];",
  "traverseMay": "// traverseMay :: Applicative f => (t -> f a) -> Maybe t -> f (Maybe a)\nconst traverseMay = f => mb =>\n    mb.Nothing ? (\n        [mb]\n    ) : fmap(Just)(\n        f(mb.Just)\n    );",
  "traverseTree": "// traverseTree :: Applicative f => (a -> f b) -> Tree a -> f (Tree b)\nconst traverseTree = f => {\n    // traverse f (Node x ts) = liftA2 Node (f x) (traverse (traverse f) ts)\n    const go = tree =>\n        liftA2(Node)(f(tree.root))(\n            traverseList(go)(\n                tree.nest\n            )\n        );\n    return go;\n};",
  "traverseTuple": "// traverseTuple :: Functor f => (t -> f b) -> (a, t) -> f (a, b)\nconst traverseTuple = f => tpl =>\n    fmap(Tuple(tpl[0]))(\n        f(tpl[1])\n    );",
  "treeFromDict": "// treeFromDict :: String -> Dict -> Tree String\nconst treeFromDict = rootLabel =>\n    dict => {\n        const go = x =>\n            'object' !== typeof x ? [] : (\n                Array.isArray(x) ? (\n                    x.flatMap(go)\n                ) : keys(x).map(\n                    k => Node(k)(\n                        go(x[k])\n                    )\n                )\n            );\n        return Node(rootLabel)(\n            go(dict)\n        );\n    };",
  "treeFromJSON": "// treeFromJSON :: JSON String -> Tree a\nconst treeFromJSON = json => {\n    // Assumes a recursive [root, nest] JSON format,\n    // in which `root` is a parseable value string, and `nest`\n    // is a possibly empty list of [`root`, `nest`] pairs.\n    const go = ([root, nest]) =>\n        Node(root)(nest.map(go));\n    return go(JSON.parse(json));\n};",
  "treeFromNestedDict": "// treeFromNestedDict -> Dict -> Either String Tree Dict\nconst treeFromNestedDict = dict => {\n    // A generic Tree structure from a dict\n    // with keys assumed to include no more than\n    // one key to a *list* value,\n    // with this pattern applied recursively\n    // to each child dictionary in such a list.\n    const go = dct => {\n        const\n            kvs = Object.entries(dct),\n            lists = kvs.filter(\n                ([_, v]) => Array.isArray(v)\n            ),\n            lng = lists.length;\n        return 0 < lng ? (\n            1 < lng ? (\n                Left(\n                    'Ambiguous structure :: ' +\n                    lng.toString() + (\n                        ' multiple sublists in:\\n  \"' +\n                        dct.name + (\n                            '\":\\n' + bulleted('    ')(\n                                unlines(lists.map(fst))\n                            )\n                        )\n                    )\n                )\n            ) : (() => {\n                const [nestName, xs] = lists[0];\n                return bindLR(traverseList(go)(xs))(\n                    xs => Right(\n                        Node(\n                            Object.assign(\n                                deleteKey(nestName)(\n                                    dct\n                                ), {\n                                    'List title': nestName\n                                }\n                            )\n                        )(xs)\n                    )\n                );\n            })()\n        ) : Right(Node(dct)([]))\n    };\n    return go(dict);\n};",
  "treeLeaves": "// treeLeaves :: Tree -> [Tree]\nconst treeLeaves = tree => {\n  const nest = tree.nest;\n  return (0 < nest.length) ? (\n    nest.flatMap(treeLeaves)\n  ) : [tree];\n};",
  "treeMatches": "// A list of all nodes in the tree which match \n// a predicate p.\n// For the first match only, see findTree.\n\n// treeMatches :: (a -> Bool) -> Tree a -> [Tree a]\nconst treeMatches = p => {\n    const go = tree =>\n        p(tree.root) ? (\n            [tree]\n        ) : tree.nest.flatMap(go);\n    return go;\n};",
  "treeMenu": "// treeMenu :: Tree String -> IO [String]\nconst treeMenu = tree => {\n    const go = t => {\n        const\n            strTitle = t.root,\n            subs = t.nest,\n            menu = subs.map(root),\n            blnMore = 0 < subs.flatMap(nest).length;\n        return until(tpl => !fst(tpl) || !isNull(snd(tpl)))(\n            tpl => either(\n                x => Tuple(false)([])\n            )(\n                Tuple(true)\n            )(\n                bindLR(showMenuLR(!blnMore)(strTitle)(menu))(\n                    ks => {\n                        const k = ks[0];\n                        return maybe(\n                            Left(k + ': not found in ' +\n                                JSON.stringify(ks)\n                            )\n                        )(Right)(\n                            bindMay(find(x => k === x.root)(subs))(\n                                chosen => Just(\n                                    isNull(chosen.nest) ? (\n                                        ks // Choice made in leaf menu.\n                                    ) : go(chosen)\n                                )\n                            )\n                        );\n                    }\n                )\n            )\n        )(Tuple(true)([]))[1]\n    };\n    return go(tree);\n};",
  "treeMenuBy": "// treeMenuBy :: (a -> String) Tree a -> IO [a]\nconst treeMenuBy = fNodeKey => {\n    const go = tree => {\n        const\n            strTitle = fNodeKey(tree.root),\n            subTrees = nest(tree),\n            menu = subTrees.map(\n                compose(fNodeKey, root)\n            ).sort();\n        return until(\n            tpl => !fst(tpl) || !isNull(snd(tpl))\n        )(\n            tpl => either(\n                x => Tuple(false)([])\n            )(\n                Tuple(true)\n            )(\n                bindLR(\n                    showMenuLR(true)(strTitle)(menu)\n                )(\n                    ks => {\n                        const k0 = ks[0];\n                        return maybe(\n                            Left(\n                                k0 + ': not found in ' +\n                                JSON.stringify(ks)\n                            )\n                        )(Right)(\n                            bindMay(\n                                find(\n                                    x => k0 === fNodeKey(\n                                        x.root\n                                    )\n                                )(subTrees)\n                            )(\n                                firstChosen => Just(\n                                    isNull(\n                                        nest(firstChosen)\n                                    ) ? (\n                                        ks.map(\n                                            k => find(\n                                                x => k === fNodeKey(\n                                                    x.root\n                                                )\n                                            )(subTrees).Just\n                                        )\n                                    ) : go(firstChosen)\n                                )\n                            )\n                        );\n                    }\n                )\n            )\n        )(Tuple(true)([]))[1]\n    };\n    return go;\n};",
  "truncate": "// truncate :: Num -> Int\nconst truncate = x =>\n    'Ratio' === x.type ? (\n        properFracRatio(x)[0]\n    ) : properFraction(x)[0];",
  "tupleFromList": "// tupleFromList :: [a] -> (a, a ...)\nconst tupleFromList = xs =>\n    TupleN(...xs);",
  "typeName": "// typeName :: a -> String\nconst typeName = v => {\n    const t = typeof v;\n    return 'object' === t ? (\n        Array.isArray(v) ? (\n            'List'\n        ) : null !== v ? (\n            v.type || 'Dict'\n        ) : 'Bottom'\n    ) : {\n        'boolean': 'Bool',\n        'number': 'Num',\n        'string': 'String',\n        'function' : '(a -> b)'\n    } [t] || 'Bottom';\n};",
  "unQuoted": "// unQuoted :: String -> String\nconst unQuoted = s =>\n    dropAround(x => 34 === x.codePointAt(0))(\n        s\n    );",
  "uncons": "// uncons :: [a] -> Maybe (a, [a])\nconst uncons = xs => {\n    // Just a tuple of the head of xs and its tail, \n    // Or Nothing if xs is an empty list.\n    const lng = length(xs);\n    return (0 < lng) ? (\n        Infinity > lng ? (\n            Just(Tuple(xs[0])(xs.slice(1))) // Finite list\n        ) : (() => {\n            const nxt = take(1)(xs);\n            return 0 < nxt.length ? (\n                Just(Tuple(nxt[0])(xs))\n            ) : Nothing();\n        })() // Lazy generator\n    ) : Nothing();\n};",
  "uncurry": "// uncurry :: (a -> b -> c) -> ((a, b) -> c)\nconst uncurry = f =>\n    // A function over a pair, derived\n    // from a curried function.\n    (...args) => {\n        const\n            xy = 1 < args.length ? (\n                args\n            ) : args[0];\n        return f(xy[0])(xy[1]);\n    };",
  "uncurryN": "// uncurryN :: Curry a b => b -> a\nconst uncurryN = f =>\n    // A function over a tuple of values, derived from\n    // a curried function of any number of arguments.\n    (...args) => (\n        xs => xs.slice(1).reduce(\n            (a, x) => a(x), \n            f(xs[0])\n        )\n    )(Array.from(\n        1 < args.length ? (\n            args\n        ) : args[0]\n    ));",
  "unfoldForest": "// | Build a forest from a list of seed values\n\n// unfoldForest :: (b -> (a, [b])) -> [b] -> [Tree]\nconst unfoldForest = f => x =>\n    xs.map(unfoldTree(f));",
  "unfoldTree": "// | Build a tree from a seed value\n\n// unfoldTree :: (b -> (a, [b])) -> b -> Tree a\nconst unfoldTree = f => b => {\n    const tpl = f(b);\n    return Node(tpl[0])(\n        unfoldForest(f)(\n            tpl[1]\n        )\n    );\n};",
  "unfoldl": "// unfoldl(x => 0 !== x ? Just([x - 1, x]) : Nothing(), 10);\n// --> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// unfoldl :: (b -> Maybe (b, a)) -> b -> [a]\nconst unfoldl = f => v => {\n    // Dual to reduce or foldl.\n    // Where these reduce a list to a summary value, unfoldl\n    // builds a list from a seed value.\n    // Where f returns Just(a, b), a is appended to the list,\n    // and the residual b is used as the argument for the next\n    // application of f.\n    // Where f returns Nothing, the completed list is returned.\n    let\n        xr = [v, v],\n        xs = [];\n    while (true) {\n        const mb = f(xr[0]);\n        if (mb.Nothing) {\n            return xs\n        } else {\n            xr = mb.Just;\n            xs = [xr[1]].concat(xs);\n        }\n    }\n};",
  "unfoldr": "// The 'unfoldr' function is a *dual* to 'foldr': while 'foldr'\n// reduces a list to a summary value, 'unfoldr' builds a list from\n// a seed value.  The function takes the element and returns 'Nothing'\n// if it is done producing the list or returns 'Just' @(a,b)@, in which\n// case, @a@ is a prepended to the list and @b@ is used as the next\n// element in a recursive call.\n//\n// unfoldr(x => 0 !== x ? Just([x, x - 1]) : Nothing(), 10);\n// --> [10,9,8,7,6,5,4,3,2,1]\n\n// (x => Maybe [value, remainder] -> initial value -> values\n\n// unfoldr :: (b -> Maybe (a, b)) -> b -> [a]\nconst unfoldr = f => v => {\n    let\n        xr = [v, v],\n        xs = [];\n    while (true) {\n        const mb = f(xr[1]);\n        if (mb.Nothing) {\n            return xs\n        } else {\n            xr = mb.Just;\n            xs.push(xr[0])\n        }\n    }\n};",
  "union": "// union :: [a] -> [a] -> [a]\nconst union = xs => ys =>\n  unionBy(a => b => a === b)(\n      xs\n  )(ys);",
  "unionBy": "// unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst unionBy = fnEq => xs => ys => {\n    const sx = nubBy(fnEq)(xs);\n    return sx.concat(\n        sx.reduce(\n            (a, x) => deleteBy(fnEq)(\n                x\n            )(a),\n            nubBy(fnEq)(ys)\n        )\n    );\n};",
  "unionSet": "// unionSet :: Ord a => Set a -> Set a -> Set a\nconst unionSet = s => s1 =>\n    Array.from(s1.values())\n    .reduce(\n        (a, x) => (a.add(x), a),\n        new Set(s)\n    );",
  "unlines": "// unlines :: [String] -> String\nconst unlines = xs =>\n    // A single string formed by the intercalation\n    // of a list of strings with the newline character.\n    xs.join('\\n');",
  "unsnoc": "// If the list is empty returns Nothing, otherwise returns \n// Just the init and the last.\n\n// unsnoc :: [a] -> Maybe ([a], a)\nconst unsnoc = xs =>\n    (0 < xs.length) ? (\n        Just(Tuple(xs.slice(0, -1))(xs.slice(-1)[0]))\n    ) : Nothing();",
  "until": "// until :: (a -> Bool) -> (a -> a) -> a -> a\nconst until = p => f => x => {\n    let v = x;\n    while (!p(v)) v = f(v);\n    return v;\n};",
  "unwords": "// unwords :: [String] -> String\nconst unwords = xs =>\n    // A space-separated string derived\n    // from a list of words.\n    xs.join(' ');",
  "unwrap": "// unwrap :: NSObject -> a\nconst unwrap = ObjC.unwrap;",
  "unzip": "// unzip :: [(a,b)] -> ([a],[b])\nconst unzip = xys =>\n    xys.reduce(\n        (ab, xy) => Tuple(ab[0].concat(xy[0]))(\n            ab[1].concat(xy[1])\n        ),\n        Tuple([])([])\n    );",
  "unzip3": "// unzip3 :: [(a,b,c)] -> ([a],[b],[c])\nconst unzip3 = xyzs =>\n    xyzs.reduce(\n        (a, x) => TupleN.apply(null, [0, 1, 2].map(\n            i => a[i].concat(x[i])\n        )),\n        TupleN([], [], [])\n    );",
  "unzip4": "// unzip4 :: [(a,b,c,d)] -> ([a],[b],[c],[d])\nconst unzip4 = wxyzs =>\n    wxyzs.reduce(\n        (a, x) => TupleN.apply(null, [0, 1, 2, 3].map(\n            i => a[i].concat(x[i])\n        )),\n        TupleN([], [], [], [])\n    );",
  "unzipN": "// unzipN :: [(a,b,...)] -> ([a],[b],...)\nconst unzipN = tpls =>\n    TupleN(...tpls.reduce(\n        (a, tpl) => a.map(\n            (x, i) => x.concat(tpl[i])\n        ),\n        replicate(\n            0 < tpls.length ? (\n                tpls[0].length\n            ) : 0, []\n        )\n    ));",
  "variance": "// variance :: [Num] -> Num\nconst variance = xs => {\n    const\n        lng = xs.length,\n        mean = xs.reduce((a, b) => a + b, 0) / lng;\n    return xs.reduce(\n        (a, b) => a + Math.pow(b - mean, 2),\n        0\n    ) / (lng - 1);\n};",
  "words": "// words :: String -> [String]\nconst words = s => s.split(/\\s+/);",
  "wrap": "// wrap :: a -> NSObject\nconst wrap = ObjC.wrap;",
  "writeFile": "// writeFile :: FilePath -> String -> IO ()\nconst writeFile = fp => s =>\n    $.NSString.alloc.initWithUTF8String(s)\n    .writeToFileAtomicallyEncodingError(\n        $(fp)\n        .stringByStandardizingPath, false,\n        $.NSUTF8StringEncoding, null\n    );",
  "writeFileLR": "// writeFileLR :: FilePath -> Either String IO FilePath\nconst writeFileLR = strPath => strText => {\n    const\n        e = $(),\n        fp = $(strPath)\n        .stringByStandardizingPath;\n    return $.NSString.alloc.initWithUTF8String(strText)\n        .writeToFileAtomicallyEncodingError(\n            fp, false,\n            $.NSUTF8StringEncoding, e\n        ) ? (\n            Right(ObjC.unwrap(fp))\n        ) : Left(ObjC.unwrap(e.localizedDescription));\n};",
  "writeTempFile": "// File name template -> string data -> IO temporary path\n\n// writeTempFile :: String -> String -> IO FilePath\nconst writeTempFile = template =>\n    txt => {\n        const\n            strPath = ObjC.unwrap($.NSTemporaryDirectory()) +\n            takeBaseName(template) + Math.random()\n            .toString()\n            .substring(3) + takeExtension(template);\n        return (writeFile(strPath)(txt), strPath);\n    };",
  "zip": "// zip :: [a] -> [b] -> [(a, b)]\nconst zip = xs =>\n    // Use of `take` and `length` here allows for zipping with non-finite \n    // lists - i.e. generators like cycle, repeat, iterate.\n    ys => {\n        const\n            lng = Math.min(length(xs), length(ys)),\n            vs = take(lng)(ys);\n        return take(lng)(xs).map(\n            (x, i) => Tuple(x)(vs[i])\n        );\n    };",
  "zip3": "// zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]\nconst zip3 = xs => ys => zs =>\n    xs.slice(0, Math.min(length(xs), length(ys), length(zs)))\n    .map((x, i) => TupleN(x, ys[i], zs[i]));",
  "zip4": "// zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]\nconst zip4 = ws => xs => ys => zs =>\n    ws.slice(0, minimum([ws, xs, ys, zs].map(length)))\n    .map((w, i) => TupleN(w, xs[i], ys[i], zs[i]));",
  "zipGen": "// zipGen :: Gen [a] -> Gen [b] -> Gen [(a, b)]\nconst zipGen = ga => gb => {\n    function* go(ma, mb) {\n        let\n            a = ma,\n            b = mb;\n        while(!a.Nothing && !b.Nothing) {\n            let\n                ta = a.Just,\n                tb = b.Just;\n            yield(\n                Tuple(fst(ta))(\n                    fst(tb)\n                )\n            );\n            a = uncons(snd(ta));\n            b = uncons(snd(tb));\n        }\n    }\n    return go(uncons(ga), uncons(gb));\n};",
  "zipList": "// zipList :: [a] -> [b] -> [(a, b)]\nconst zipList = xs => ys => {\n    const\n        lng = Math.min(length(xs), length(ys)),\n        vs = take(lng)(ys);\n    return take(lng)(xs)\n        .map((x, i) => Tuple(x)(vs[i]));\n};",
  "zipN": "// zipN :: [a] -> [b] -> ... -> [(a, b ...)]\nfunction zipN() {\n    const args = Array.from(arguments);\n    return 1 < args.length ? map(\n        (x, i) => TupleN(...map(y => y[i], args)),\n        take(\n            Math.min(...map(length, args)),\n            args[0]\n        )\n    ) : args;\n}",
  "zipWith": "// Use of `take` and `length` here allows zipping with non-finite lists\n// i.e. generators like cycle, repeat, iterate.\n\n// zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst zipWith = f => xs => ys => {\n    const lng = Math.min(length(xs), length(ys));\n    return Infinity > lng ? (() => {\n       const\n            as = take(lng)(xs),\n            bs = take(lng)(ys);\n        return Array.from({\n            length: lng\n        }, (_, i) => f(as[i])(\n            bs[i]\n        ));\n    })() : zipWithGen(f)(xs)(ys);\n};",
  "zipWith3": "// zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]\nconst zipWith3 = f => xs => ys => zs =>\n    Array.from({\n        length: Math.min(length(xs), length(ys), length(zs))\n    }, (_, i) => f(xs[i])(ys[i])(zs[i]));",
  "zipWith4": "// zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]\nconst zipWith4 = f => ws => xs => ys => zs =>\n    Array.from({\n        length: minimum([ws, xs, ys, zs].map(length))\n    }, (_, i) => f(ws[i])(xs[i])(ys[i])(zs[i]));",
  "zipWithGen": "// zipWithGen :: (a -> b -> c) -> \n// Gen [a] -> Gen [b] -> Gen [c]\nconst zipWithGen = f => ga => gb => {\n    function* go(ma, mb) {\n        let\n            a = ma,\n            b = mb;\n        while (!a.Nothing && !b.Nothing) {\n            let\n                ta = a.Just,\n                tb = b.Just\n            yield(f(fst(ta))(fst(tb)));\n            a = uncons(snd(ta));\n            b = uncons(snd(tb));\n        }\n    }\n    return go(uncons(ga), uncons(gb));\n};",
  "zipWithList": "// zipWithList :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst zipWithList = f =>\n    // A list constructed by zipping with a\n    // custom function, rather than with the\n    // default tuple constructor.\n    xs => ys => {\n        const\n            lng = Math.min(length(xs), length(ys)),\n            vs = take(lng)(ys);\n        return take(lng)(xs)\n        .map((x, i) => f(x)(vs[i]));\n    };",
  "zipWithM": "// zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]\nconst zipWithM = f => \n    xs => ys =>\n        sequenceA(\n            zipWith(f)(xs)(ys)\n        );",
  "zipWithN": "// zipWithN :: (a -> b -> ... -> c) -> ([a], [b] ...) -> [c]\nfunction zipWithN() {\n    const\n        args = Array.from(arguments),\n        rows = args.slice(1),\n        f = args[0];\n    return 1 < rows.length ? map(\n        i => f(...map(r => r[i], rows)),\n        enumFromTo(\n            0,\n            Math.min(...map(length, rows)) -1,\n        )\n    ) : rows;\n}\n\n// or\n\n// zipWithN :: (a -> b -> ... -> c) -> ([a], [b] ...) -> [c]\n// const zipWithN = (f, tplLists) =>\n//     map(x => f(...Array.from(x)),\n//         zipN(...Array.from(tplLists))\n//     );"
}