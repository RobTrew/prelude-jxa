{
  "EQ": "// EQ :: Ordering\nconst EQ = {\n  type: 'Ordering',\n  value: 0\n};",
  "GT": "// GT :: Ordering\nconst GT = {\n    type: 'Ordering',\n    value: 1\n};",
  "Just": "// Just :: a -> Just a\nconst Just = x => ({\n    type: 'Maybe',\n    Nothing: false,\n    Just: x\n});",
  "LT": "// LT :: Ordering\nconst LT = {\n  type: 'Ordering',\n  value: -1\n};",
  "Left": "// Left :: a -> Either a b\nconst Left = x => ({\n    type: 'Either',\n    Left: x\n});",
  "Node": "// Node :: a -> [Tree a] -> Tree a\nconst Node = (v, xs) => ({\n    type: 'Node',\n    root: v, // any type of value (consistent across tree)\n    nest: xs || []\n});",
  "Nothing": "// Nothing :: () -> Nothing\nconst Nothing = () => ({\n    type: 'Maybe',\n    Nothing: true,\n});",
  "Ordering": "// Ordering :: Int -> Ordering\nconst Ordering = e =>\n    ({\n        type: 'Ordering',\n        value: (e > 0 ? 1 : e < 0 ? -1 : 0)\n    });",
  "Ratio": "// Ratio :: Int -> Int -> Ratio\nconst Ratio = (n, d) => ({\n    type: 'Ratio',\n    'n': n, // numerator\n    'd': d // denominator\n});",
  "Right": "// Right :: b -> Either a b\nconst Right = x => ({\n    type: 'Either',\n    Right: x\n});",
  "Tuple": "// Tuple (,) :: a -> b -> (a, b)\nconst Tuple = (a, b) => ({\n  type: 'Tuple',\n  '0': a,\n  '1': b,\n  length: 2\n});",
  "TupleN": "// TupleN :: a -> b ...  -> (a, b ... )\nfunction TupleN() {\n    const\n        args = Array.from(arguments),\n        lng = args.length;\n    return lng > 1 ? Object.assign(\n        args.reduce((a, x, i) => Object.assign(a, {\n            [i]: x\n        }), {\n            type: 'Tuple' + (2 < lng ? lng.toString() : ''),\n            length: lng\n        })\n    ) : args[0];\n};",
  "abs": "// | Absolute value.\n\n// abs :: Num -> Num\nconst abs = Math.abs;",
  "all": "// Determines whether all elements of the structure \n// satisfy the predicate.\n\n// all :: (a -> Bool) -> [a] -> Bool\nconst all = (p, xs) => xs.every(p);",
  "and": "// | The conjunction of a container of Bools. \n// True unless any contained value is false.\n\n// and :: [Bool] -> Bool\nconst and = xs =>\n    xs.every(Boolean);",
  "any": "// | True if any contained element satisfies the predicate.\n\n// any :: (a -> Bool) -> [a] -> Bool\nconst any = (p, xs) => xs.some(p);",
  "ap (<*>)": "// Applies wrapped functions to wrapped values, \n// for example applying a list of functions to a list of values\n// or applying Just(f) to Just(x), Right(f) to Right(x), etc\n\n// ap (<*>) :: Monad m => m (a -> b) -> m a -> m b\nconst ap = (mf, mx) => {\n    const t = mx.type;\n    return (\n        undefined !== t ? (\n            'Either' === t ? (\n                apLR\n            ) : 'Maybe' === t ? (\n                apMay\n            ) : 'Node' === t ? (\n                apTree\n            ) : 'Tuple' === t ? (\n                apTuple\n            ) : apList\n        ) : apList\n    )(mf, mx);\n};",
  "apLR (<*>)": "// apLR (<*>) :: Either e (a -> b) -> Either e a -> Either e b\nconst apLR = (flr, lr) => {\n    const pf = (undefined === flr.Left);\n    return pf && (undefined === lr.Left) ? (\n        Right(flr.Right(lr.Right))\n    ) : (pf ? lr : flr);\n};",
  "apList (<*>)": "// e.g. [(*2),(/2), sqrt] <*> [1,2,3]\n// -->  ap([dbl, hlf, root], [1, 2, 3])\n// -->  [2,4,6,0.5,1,1.5,1,1.4142135623730951,1.7320508075688772]\n\n// Each member of a list of functions applied to each\n// of a list of arguments, deriving a list of new values.\n\n// apList (<*>) :: [(a -> b)] -> [a] -> [b]\nconst apList = (fs, xs) => //\n    [].concat.apply([], fs.map(f => //\n        [].concat.apply([], xs.map(x => [f(x)]))));",
  "apMay (<*>)": "// Maybe f applied to Maybe x, deriving a Maybe y\n\n// apMay (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\nconst apMay = (mf, mx) =>\n    mf.Nothing || mx.Nothing ? (\n        Nothing()\n    ) : Just(mf.Just(mx.Just));",
  "apTree (<*>)": "// apTree (<*>) :: Tree (a -> b) -> Tree a -> Tree b\nconst apTree = (tf, tx) => {\n    const go = t =>\n        Node(\n            t.root(tx.root),\n            tx.nest.map(\n                curry(fmapTree)(t.root)\n            ).concat(t.nest.map(go))\n        );\n    return go(tf);\n};",
  "apTuple (<*>)": "// apTuple (<*>) :: Monoid m => (m, (a -> b)) -> (m, a) -> (m, b)\nconst apTuple = (tf, tx) =>\n    Tuple(\n        mappend(tf[0], tx[0]),\n        tf[1](tx[1])\n    );",
  "append (++)": "// append (++) :: [a] -> [a] -> [a]\n// append (++) :: String -> String -> String\nconst append = (xs, ys) => xs.concat(ys);",
  "appendFile": "// appendFile :: FilePath -> String -> IO Bool\nconst appendFile = (strPath, txt) => {\n    const\n        oFullPath = ObjC.wrap(strPath)\n        .stringByStandardizingPath,\n        ref = Ref();\n  \n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            oFullPath\n            .stringByStandardizingPath, ref\n        ) ? (\n            0 === ref[0] ? (() => {\n                const // Not a directory\n                    oData = ObjC.wrap(txt)\n                    .dataUsingEncoding($.NSUTF8StringEncoding),\n                    h = $.NSFileHandle.fileHandleForWritingAtPath(\n                        oFullPath\n                    );\n                return (\n                    h.seekToEndOfFile, // Effect, and\n                    h.writeData(oData),\n                    h.closeFile,\n                    true // value.\n                );\n            })() : false // Text appending to directory is undefined\n        ) : doesDirectoryExist(takeDirectory(ObjC.unwrap(strPath))) ? (\n            writeFile(oFullPath, txt), // Effect, and\n            true // value.\n        ) : false;\n};",
  "appendFileMay": "// appendFileMay :: FilePath -> String -> Maybe IO FilePath\nconst appendFileMay = (strPath, txt) => {\n    const\n        oFullPath = ObjC.wrap(strPath)\n        .stringByStandardizingPath,\n        strFullPath = ObjC.unwrap(oFullPath),\n        ref = Ref();\n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            oFullPath\n            .stringByStandardizingPath, ref\n        ) ? (\n             0 === ref[0] ? (() => {\n                const // Not a directory\n                    oData = ObjC.wrap(txt)\n                    .dataUsingEncoding($.NSUTF8StringEncoding),\n                    h = $.NSFileHandle\n                    .fileHandleForWritingAtPath(oFullPath);\n                return (\n                    h.seekToEndOfFile, // Effect, and\n                    h.writeData(oData),\n                    h.closeFile, {\n                        Nothing: false,\n                        Just: strFullPath\n                    } // value.\n                );\n            })() : Nothing()\n            // Text appending to directory is undefined\n        ) : doesDirectoryExist(takeDirectory(strFullPath)) ? (\n            writeFile(oFullPath, txt), // Effect, and\n            Just(strFullPath) // value\n        ) : Nothing();\n};",
  "apply ($)": "// apply ($) :: (a -> b) -> a -> b\nconst apply = (f, x) => f(x);",
  "approxRatio": "// Epsilon -> Real -> Ratio\n\n// approxRatio :: Real -> Real -> Ratio\nconst approxRatio = (eps, n) => {\n    const\n        gcde = (e, x, y) => {\n            const _gcd = (a, b) => (b < e ? a : _gcd(b, a % b));\n            return _gcd(Math.abs(x), Math.abs(y));\n        },\n        c = gcde(Boolean(eps) ? eps : (1 / 10000), 1, n);\n    return Ratio(\n        Math.floor(n / c), // numerator\n        Math.floor(1 / c) // denominator\n    );\n};",
  "argvLength": "// argvLength :: Function -> Int\nconst argvLength = f => f.length;",
  "assocs": "// assocs :: Map k a -> [(k, a)]\nconst assocs = m =>\n    Object.keys(m).sort().map(k => Tuple(k, m[k]));",
  "bind (>>=)": "// bind (>>=) :: Monad m => m a -> (a -> m b) -> m b\nconst bind = (m, mf) =>\n    (Array.isArray(m) ? (\n        bindList\n    ) : (() => {\n        const t = m.type;\n        return 'Either' === t ? (\n            bindEither\n        ) : 'Maybe' === t ? (\n            bindMaybe\n        ) : 'Tuple' === t ? (\n            bindTuple\n        ) : x => Left('No bind instance found for type: ' + t);\n    })()(m, mf));",
  "bindLR (>>=)": "// bindLR (>>=) :: Either a -> (a -> Either b) -> Either b\nconst bindLR = (m, mf) =>\n    m.Right !== undefined ? (\n        mf(m.Right)\n    ) : m;",
  "bindList (>>=)": "// bindList (>>=) :: [a] -> (a -> [b]) -> [b]\nconst bindList = (xs, mf) => \n  [].concat.apply([], xs.map(mf));",
  "bindMay (>>=)": "// bindMay (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\nconst bindMay = (mb, mf) =>\n    mb.Nothing ? mb : mf(mb.Just);",
  "bindTuple (>>=)": "// bindTuple (>>=) :: Monoid a => (a, a) -> (a -> (a, b)) -> (a, b)\nconst bindTuple = (tpl, f) => {\n    const t2 = f(tpl[1]);\n    return Tuple(\n        mappend(tpl[0], t2[0]),\n        t2[1]\n    );\n};",
  "break": "// break :: (a -> Bool) -> [a] -> ([a], [a])\nconst break_ = (p, xs) => {\n  for (var i = 0, lng = xs.length; (i < lng) && !p(xs[i]); i++) {};\n  return Tuple(xs.slice(0, i), xs.slice(i));\n};",
  "breakOn": "// Needle -> Haystack -> (prefix before match, match + rest)\n\n// breakOn :: String -> String -> (String, String)\nconst breakOn = (pat, src) =>\n    Boolean(pat) ? (() => {\n        const xs = src.split(pat);\n        return 1 < xs.length ? Tuple(\n            xs[0], src.slice(xs[0].length)\n        ) : Tuple(src, '');\n    })() : undefined;",
  "breakOnAll": "// breakOnAll \"::\" \"\"\n// ==> []\n// breakOnAll \"/\" \"a/b/c/\"\n// ==> [(\"a\", \"/b/c/\"), (\"a/b\", \"/c/\"), (\"a/b/c\", \"/\")]\n\n// breakOnAll :: String -> String -> [(String, String)]\nconst breakOnAll = (pat, src) =>\n    pat !== '' ? (\n        src.split(pat)\n        .reduce((a, x, i, xs) =>\n            0 < i ? (\n                a.concat([\n                    Tuple(xs.slice(0, i)\n                        .join(pat), pat + xs.slice(i)\n                        .join(pat)\n                    )\n                ])\n            ) : a, [])\n    ) : undefined;",
  "breakOnMay": "// Needle -> Haystack -> maybe (prefix before match, match + rest)\n\n// breakOnMay :: String -> String -> Maybe (String, String)\nconst breakOnMay = (pat, src) =>\n    Boolean(pat) ? (() => {\n        const xs = src.split(pat);\n        return Just(xs.length > 1 ? Tuple(\n            xs[0], src.slice(xs[0].length)\n        ) : Tuple(src, ''));\n    })() : Nothing();",
  "cartesianProduct": "// cartesianProduct :: [a] -> [b] -> [(a, b)]\nconst cartesianProduct = (xs, ys) =>\n    concatMap((x => concatMap(y => [\n        Tuple(x, y)\n    ], ys)), xs);",
  "caseOf": "// List of (Predicate, value) tuples -> Default value \n//                        -> Value to test -> Output value\n\n// caseOf :: [(a -> Bool, b)] -> b -> a ->  b\nconst caseOf = (pvs, otherwise, x) => {\n    const mb = pvs.reduce((a, pv) =>\n        a.Nothing ? (\n            pv[0](x) ? Just(pv[1]) : a\n        ) : a, Nothing());\n    return mb.Nothing ? otherwise : mb.Just;\n};",
  "catMaybes": "// catMaybes :: [Maybe a] -> [a]\nconst catMaybes = mbs =>\n    concatMap(m => m.Nothing ? [] : [m.Just], mbs);",
  "ceiling": "// The least integer not less than x\n\n// ceiling :: Num -> Int\nconst ceiling = x => {\n    const\n      nr = properFraction(x),\n      n = nr[0]\n    return 0 < nr[1] ? n + 1 : n;\n};",
  "center": "// Size of space -> filler Char -> String -> Centered String\n\n// center :: Int -> Char -> String -> String\nconst center = (n, c, s) => {\n  const\n    qr = quotRem(n - s.length, 2),\n    q = qr[0];\n  return replicateString(q, c) +\n    s + replicateString(q + qr[1], c);\n};",
  "chars": "// chars :: String -> [Char]\nconst chars = s => s.split('');",
  "chr": "// chr :: Int -> Char\nconst chr = String.fromCodePoint;",
  "chunksOf": "// chunksOf :: Int -> [a] -> [[a]]\nconst chunksOf = (n, xs) =>\n    xs.reduce((a, _, i, xs) =>\n        i % n ? a : a.concat([xs.slice(i, i + n)]), []);",
  "compare": "// compare :: a -> a -> Ordering\nconst compare = (a, b) => a < b ? -1 : (a > b ? 1 : 0);",
  "comparing": "// comparing :: (a -> b) -> (a -> a -> Ordering)\nconst comparing = f =>\n    (x, y) => {\n        const\n            a = f(x),\n            b = f(y);\n        return a < b ? -1 : (a > b ? 1 : 0);\n    };",
  "compose (<<<)": "// compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\nconst compose = (f, g) => x => f(g(x));",
  "composeList": "// composeList :: [(a -> a)] -> (a -> a)\nconst composeList = fs =>\n    x => fs.reduceRight((a, f) => f(a), x, fs);",
  "composeListR": "// composeListR :: [(a -> a)] -> (a -> a)\nconst composeListR = fs =>\n    x => fs.reduce((a, f) => f(a), x);",
  "composeR (>>>)": "// composeR (>>>) :: (a -> b) -> (b -> c) -> a -> c\nconst composeR = (f, g) => x => f(g(x));",
  "concat": "// concat :: [[a]] -> [a]\n// concat :: [String] -> String\nconst concat = xs =>\n    xs.length > 0 ? (() => {\n        const unit = 'string' === typeof xs[0] ? '' : [];\n        return unit.concat.apply(unit, xs);\n    })() : [];",
  "concatMap": "// concatMap :: (a -> [b]) -> [a] -> [b]\nconst concatMap = (f, xs) => []\n    .concat.apply(\n        [],\n        (Array.isArray(xs) ? (\n            xs\n        ) : xs.split('')).map(f)\n    );",
  "cons": "// cons :: a -> [a] -> [a]\nconst cons = (x, xs) =>  [x].concat(xs);",
  "const_": "// const_ :: a -> b -> a\nconst const_ = (k, _) => k;",
  "createDirectoryIfMissingLR": "// createDirectoryIfMissingLR :: Bool -> FilePath -> Either String String\nconst createDirectoryIfMissingLR = (blnParents, fp) =>\n    doesPathExist(fp) ? (\n        Right(`Found: '${fp}'`)\n    ) : (() => {\n        const\n            e = $(),\n            blnOK = $.NSFileManager.defaultManager[\n                'createDirectoryAtPath' +\n                'WithIntermediateDirectoriesAttributesError'\n            ]($(fp)\n                .stringByStandardizingPath,\n                blnParents, undefined, e\n            );\n        return blnOK ? (\n            Right(fp)\n        ) : Left(e.localizedDescription);\n    })();",
  "curry": "// Flexibly handles two or more arguments, applying\n// the function directly if the argument array is complete,\n// or recursing with a concatenation of any existing and\n// newly supplied arguments, if gaps remain.\n\n// curry :: ((a, b) -> c) -> a -> b -> c\nconst curry = (f, ...args) => {\n    const go = xs => xs.length >= f.length ? (\n        f.apply(null, xs)\n    ) : function () {\n        return go(xs.concat(Array.from(arguments)));\n    };\n    return go(args);\n};",
  "curry2": "// Simpler 2 argument only version of curry\n\n// curry2 :: ((a, b) -> c) -> a -> b -> c\nconst curry2 = f => a => b => f(a, b);",
  "delete": "// xs with first instance of x (if any) removed\n\n// delete :: Eq a => a -> [a] -> [a]\nconst delete_ = (x, xs) =>\n    0 < xs.length ? (\n        (x === xs[0]) ? (\n            xs.slice(1)\n        ) : [xs[0]].concat(delete_(x, xs.slice(1)))\n    ) : [];",
  "deleteAt": "// deleteAt :: Int -> [a] -> [a]\nconst deleteAt = (i, xs) =>\n    i <= xs.length ? (() => {\n        const lr = splitAt(i, xs);\n        return lr[0].concat(lr[1].slice(1));\n    })() : xs;",
  "deleteBy": "// deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]\nconst deleteBy = (f, x, xs) =>\n    0 < xs.length ? (\n        f(x, xs[0]) ? (\n            xs.slice(1)\n        ) : [xs[0]].concat(deleteBy(f, x, xs.slice(1)))\n    ) : [];",
  "deleteFirst": "// deleteFirst :: a -> [a] -> [a]\nconst deleteFirst = (x, xs) =>\n    0 < xs.length ? (\n        x === xs[0] ? (\n            xs.slice(1)\n        ) : [xs[0]].concat(deleteFirst(x, xs.slice(1)))\n    ) : [];",
  "deleteFirstsBy": "// deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst deleteFirstsBy = (fnEq, xs, ys) =>\n    ys.reduce((x, y) => deleteBy(fnEq, y, x), xs);",
  "deleteMap": "// deleteMap :: k -> Dict -> Dict\nconst deleteMap = (k, dct) =>\n    (delete dct[k], dct);",
  "difference": "// difference :: Eq a => [a] -> [a] -> [a]\nconst difference = (xs, ys) =>\n    xs.filter(x => -1 === ys.indexOf(x));",
  "div": "// div :: Int -> Int -> Int\nconst div = (x, y) => Math.floor(x / y);",
  "doesDirectoryExist": "// doesDirectoryExist :: FilePath -> IO Bool\nconst doesDirectoryExist = strPath => {\n    const ref = Ref();\n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            $(strPath)\n            .stringByStandardizingPath, ref\n        ) && (1 === ref[0]);\n};",
  "doesFileExist": "// doesFileExist :: FilePath -> IO Bool\nconst doesFileExist = strPath => {\n    const ref = Ref();\n    return $.NSFileManager.defaultManager\n        .fileExistsAtPathIsDirectory(\n            $(strPath)\n            .stringByStandardizingPath, ref\n        ) && 1 !== ref[0];\n};",
  "doesPathExist": "// doesPathExist :: FilePath -> IO Bool\nconst doesPathExist = strPath =>\n\t$.NSFileManager.defaultManager\n\t.fileExistsAtPath(\n\t\t$(strPath).stringByStandardizingPath\n\t);",
  "draw": "// draw :: Tree String -> [String]\nconst draw = node => {\n    // shift :: String -> String -> [String] -> [String]\n    const shift = (first, other, xs) =>\n        zipWith(\n            append,\n            cons(first, replicate(xs.length - 1, other)),\n            xs\n        );\n    // drawSubTrees :: [Tree String] -> [String]\n    const drawSubTrees = xs => {\n        const lng = xs.length;\n        return 0 < lng ? (\n            1 < lng ? append(\n                cons(\n                    '│',\n                    shift('├─ ', '│  ', draw(xs[0]))\n                ),\n                drawSubTrees(xs.slice(1))\n            ) : cons('│', shift('└─ ', '   ', draw(xs[0])))\n        ) : [];\n    };\n    return append(\n        lines(node.root.toString()),\n        drawSubTrees(node.nest)\n    );\n};",
  "drawForest": "// drawForest :: [Tree String] -> String\nconst drawForest = trees =>\n    trees.map(drawTree).join('\\n');",
  "drawTree": "// drawTree :: Tree String -> String\nconst drawTree = tree =>\n    unlines(draw(tree));",
  "drop": "// drop :: Int -> [a] -> [a]\n// drop :: Int -> String -> String\nconst drop = (n, xs) => xs.slice(n);",
  "dropAround": "// dropAround :: (a -> Bool) -> [a] -> [a]\n// dropAround :: (Char -> Bool) -> String -> String\nconst dropAround = (p, xs) => dropWhile(p, dropWhileEnd(p, xs));",
  "dropFileName": "// dropFileName :: FilePath -> FilePath\nconst dropFileName = strPath =>\n    strPath !== '' ? (() => {\n        const xs = (strPath.split('/'))\n            .slice(0, -1);\n        return xs.length > 0 ? (\n            xs.join('/') + '/'\n        ) : './';\n    })() : './';",
  "dropWhile": "// dropWhile :: (a -> Bool) -> [a] -> [a]\n// dropWhile :: (Char -> Bool) -> String -> String\nconst dropWhile = (p, xs) => {\n  let i = 0;\n  for (let lng = xs.length;\n    (i < lng) && p(xs[i]); i++) {}\n  return xs.slice(i);\n};",
  "dropWhileEnd": "// dropWhileEnd :: (a -> Bool) -> [a] -> [a]\n// dropWhileEnd :: (Char -> Bool) -> String -> String\nconst dropWhileEnd = (p, xs) => {\n    let i = xs.length;\n    while (i-- && p(xs[i])) {}\n    return xs.slice(0, i + 1);\n};",
  "either": "// either :: (a -> c) -> (b -> c) -> Either a b -> c\nconst either = (lf, rf, e) =>\n    'Either' === e.type ? (\n        undefined !== e.Left ? (\n            lf(e.Left)\n        ) : rf(e.Right)\n    ) : undefined;",
  "elem": "// elem :: Eq a => a -> [a] -> Bool\nconst elem = (x, xs) => xs.includes(x);",
  "elemAtMay": "// If x is a dictionary, then the Int is read as an \n// index into the lexically sorted keys of the Dict, \n// returning a Maybe (Key, Value) pair.\n// If x is a list, then returns a Maybe a.\n// (In either case, returns Nothing for an Int out of range)\n\n// elemAtMay :: Int -> Dict -> Maybe (String, a)\n// elemAtMay :: Int -> [a] -> Maybe a\nconst elemAtMay = (i, x) => {\n    const\n        bln = Array.isArray(x),\n        k = bln ? i : Object.keys(x)\n        .sort()[i],\n        v = x[k];\n    return (typeof v)[0] !== 'u' ? (\n        Just(bln ? v : Tuple(k, v))\n    ) : Nothing();\n};",
  "elemIndex": "// elemIndex :: Eq a => a -> [a] -> Maybe Int\nconst elemIndex = (x, xs) => {\n    const i = xs.indexOf(x);\n    return -1 === i ? (\n        Nothing()\n    ) : Just(i);\n};",
  "elemIndices": "// elemIndices :: Eq a => a -> [a] -> [Int]\nconst elemIndices = (x, xs) =>\n    concatMap((y, i) => y === x ? (\n        [i]\n    ) : [], xs);",
  "elems": "// elems :: Dict -> [a]\nconst elems = Object.values;",
  "enumFromThenTo": "// enumFromThenTo :: Enum a => a -> a -> a -> [a]\nconst enumFromThenTo = (x1, x2, y) =>\n    ('number' !== typeof x1 ? (\n        enumFromThenToChar\n    ) : enumFromThenToInt)\n    .apply(null, [x1, x2, y]);",
  "enumFromThenToChar": "// enumFromThenToChar :: Char -> Char -> Char -> [Char]\nconst enumFromThenToChar = (x1, x2, y) => {\n    const [i1, i2, iY] = Array.from([x1, x2, y])\n        .map(x => x.charCodeAt(0)),\n        d = i2 - i1;\n    return Array.from({\n        length: (Math.floor(iY - i2) / d) + 2\n    }, (_, i) => String.fromCodePoint(i1 + (d * i)));\n};",
  "enumFromThenToInt": "// enumFromThenToInt :: Int -> Int -> Int -> [Int]\nconst enumFromThenToInt = (x1, x2, y) => {\n    const d = x2 - x1;\n    return Array.from({\n        length: Math.floor(y - x2) / d + 2\n    }, (_, i) => x1 + (d * i));\n};",
  "enumFromTo": "// enumFromTo :: Enum a => a -> a -> [a]\nconst enumFromTo = (m, n) =>\n    ('number' !== typeof m ? (\n        enumFromToChar\n    ) : enumFromToInt).apply(null, [m, n]);",
  "enumFromToChar": "// enumFromToChar :: Char -> Char -> [Char]\nconst enumFromToChar = (m, n) => {\n    const [intM, intN] = [m, n].map(x => x.charCodeAt(0));\n    return Array.from({\n        length: Math.floor(intN - intM) + 1\n    }, (_, i) => String.fromCodePoint(intM + i));\n};",
  "enumFromToInt": "// enumFromToInt :: Int -> Int -> [Int]\nconst enumFromToInt = (m, n) =>\n    m <= n ? iterateUntil(\n        x => n <= x,\n        x => 1 + x,\n        m\n    ) : [];",
  "eq (==)": "// eq (==) :: Eq a => a -> a -> Bool\nconst eq = (a, b) => {\n    const t = typeof a;\n    return t !== typeof b ? (\n        false\n    ) : 'object' !== t ? (\n        a === b\n    ) : (() => {\n        const aks = Object.keys(a);\n        return aks.length !== Object.keys(b).length ? (\n            false\n        ) : aks.every(k => eq(a[k], b[k]));\n    })();\n};",
  "evalJSMay": "// evalJSMay :: String -> Maybe a\nconst evalJSMay = s => {\n    try {\n        return Just(eval('(' + s + ')'))\n    } catch (e) {\n        return Nothing();\n    };\n};",
  "even": "// even :: Int -> Bool\nconst even = n => 0 === n % 2;",
  "exp": "// exp :: Float -> Float\nconst exp = Math.exp;",
  "fanArrow (&&&)": "// Compose a function from a simple value to a tuple of\n// the separate outputs of two different functions\n\n// fanArrow (&&&) :: (a -> b) -> (a -> c) -> (a -> (b, c))\nconst fanArrow = (f, g) => x => Tuple(f(x), g(x));",
  "filePath": "// filePath :: String -> FilePath\nconst filePath = s =>\n    ObjC.unwrap(ObjC.wrap(s)\n        .stringByStandardizingPath);",
  "filePathTree": "// filePathTree :: filePath -> [Tree String] -> Tree FilePath\nconst filePathTree = (fpAnchor, trees) => {\n    const go = fp => tree => {\n        const path = `${fp}/${tree.root}`;\n        return Node(\n            path,\n            tree.nest.map(go(path))\n        );\n    };\n    return Node(fpAnchor, trees.map(go(fpAnchor)));\n};",
  "fileSize": "// fileSize :: FilePath -> Either String Int\nconst fileSize = fp =>\n  bindLR(\n    fileStatus(fp),\n    dct => Right(ObjC.unwrap(dct.NSFileSize))\n  );",
  "fileStatus": "// fileStatus :: FilePath -> Either String Dict\nconst fileStatus = fp => {\n  const\n    error = $(),\n    dct = $.NSFileManager.defaultManager\n    .attributesOfItemAtPathError(fp, error).js;\n  return dct !== undefined ? (\n    Right(dct)\n  ) : Left(ObjC.unwrap(error.localizedDescription));\n};",
  "filter": "// filter :: (a -> Bool) -> [a] -> [a]\nconst filter = (f, xs) => xs.filter(f);",
  "find": "// find :: (a -> Bool) -> [a] -> Maybe a\nconst find = (p, xs) => {\n    for (let i = 0, lng = xs.length; i < lng; i++) {\n        let x = xs[i];\n        if (p(x)) return Just(x);\n    }\n    return Nothing();\n};",
  "findIndex": "//  Takes a predicate function and a list and\n//  returns Just( the 0-based index of the first\n//  element ) in the list satisfying the predicate\n//  or Nothing if there is no such element.\n\n// findIndex(isSpace, \"hello world\")\n//-> {\"type\":\"Maybe\",\"Nothing\":false,\"Just\":5}\n\n// findIndex(even, [3, 5, 7, 8, 9])\n//-> {\"type\":\"Maybe\",\"Nothing\":false,\"Just\":3}\n\n// findIndex(isUpper, \"all lower case\")\n//-> {\"type\":\"Maybe\",\"Nothing\":true}\n\n// findIndex :: (a -> Bool) -> [a] -> Maybe Int\nconst findIndex = (p, xs) => {\n    const\n        i = (\n            'string' !== typeof xs ? (\n                xs\n            ) : xs.split('')\n        ).findIndex(p);\n    return -1 !== i ? (\n        Just(i)\n    ) : Nothing();\n};",
  "findIndexR": "// findIndexR :: (a -> Bool) -> [a] -> Maybe Int\nconst findIndexR = (p, xs) => {\n    const i = reverse(xs).findIndex(p);\n    return -1 !== i ? (\n        Just(xs.length - (1 + i))\n    ) : Nothing();\n};",
  "findIndices": "// findIndices :: (a -> Bool) -> [a] -> [Int]\nconst findIndices = (p, xs) =>\n    concatMap((x, i) => p(x) ? (\n        [i]\n    ) : [], xs);",
  "firstArrow": "// Lift a simple function to one which applies to a tuple, \n// transforming only the first item of the tuple\n\n// firstArrow :: (a -> b) -> ((a, c) -> (b, c))\nconst firstArrow = f => xy => Tuple(f(xy[0]), xy[1]);",
  "flatten": "// flatten :: NestedList a -> [a]\nconst flatten = t =>\n    Array.isArray(t) ? (\n        [].concat.apply([], t.map(flatten))\n    ): t;",
  "flattenTree": "// The root elements of a tree in pre-order.\n\n// flattenTree :: Tree a -> [a]\nconst flattenTree = t => {\n    const go = (xs, x) => [x.root]\n        .concat(x.nest.reduceRight(go, xs));\n    return go([], t);\n};",
  "flip": "// flip :: (a -> b -> c) -> b -> a -> c\nconst flip = f => (a, b) => f.apply(null, [b, a]);",
  "floor": "// floor :: Num -> Int\nconst floor = x => {\n    const\n      nr = properFraction(x),\n      n = nr[0];\n    return 0 > nr[1] ? n - 1 : n;\n};",
  "fmap (<$>)": "// fmap (<$>) :: Functor f => (a -> b) -> f a -> f b\nconst fmap = (f, fa) => {\n    const t = fa.type;\n    return (undefined !== t ? (\n        'Either' === t ? (\n            fmapLR\n        ) : 'Maybe' === t ? (\n            fmapMay\n        ) : 'Node' === t ? (\n            fmapTree\n        ) : fmapTuple\n    ) : map)(f, fa);\n};",
  "fmapLR (<$>)": "// fmapLR (<$>) :: (a -> b) -> Either a a -> Either a b\nconst fmapLR = (f, lr) =>\n    undefined === lr.Left ? (\n        Right(f(lr.Right))\n    ) : lr;",
  "fmapMay (<$>)": "// fmapMay (<$>) :: (a -> b) -> Maybe a -> Maybe b\nconst fmapMay = (f, mb) =>\n    mb.Nothing ? (\n        mb\n    ) : Just(f(mb.Just));",
  "fmapTree (<$>)": "// fmapTree :: (a -> b) -> Tree a -> Tree b\nconst fmapTree = (f, tree) => {\n    const go = node => Node(\n        f(node.root),\n        node.nest.map(go)\n    );\n    return go(tree);\n};",
  "fmapTuple (<$>)": "// fmapTuple (<$>) :: (a -> b) -> (a, a) -> (a, b)\nconst fmapTuple = (f, tpl) =>\n    Tuple(tpl[0], f(tpl[1]));",
  "foldMapTree": "// foldMapTree :: Monoid m => (a -> m) -> Tree a -> m\nconst foldMapTree = (f, node) => {\n    const go = x =>\n        0 < x.nest.length ? mappend(\n            f(x.root),\n            foldl1(mappend, x.nest.map(go))\n        ) : f(x.root);\n    return go(node);\n};",
  "foldTree": "// foldTree :: (a -> [b] -> b) -> Tree a -> b\nconst foldTree = (f, tree) => {\n    const go = node => f(node.root, node.nest.map(go));\n    return go(tree);\n};",
  "foldl": "// foldl :: (a -> b -> a) -> a -> [b] -> a\nconst foldl = (f, a, xs) => xs.reduce(f, a);",
  "foldl1": "// foldl1 :: (a -> a -> a) -> [a] -> a\nconst foldl1 = (f, xs) =>\n    1 < xs.length ? xs.slice(1)\n    .reduce(f, xs[0]) : xs[0];",
  "foldl1May": "// foldl1May :: (a -> a -> a) -> [a] -> Maybe a\nconst foldl1May = (f, xs) =>\n    0 < xs.length ? (\n        Just(xs.slice(1)\n            .reduce(f, xs[0]))\n    ) : Nothing();",
  "foldlTree": "// foldlTree :: (b -> a -> b) -> b -> Tree a -> b\nconst foldlTree = (f, acc, node) => {\n  const go = (a, x) =>\n    x.nest.reduce(go, f(a, x));\n  return go(acc, node);\n};",
  "foldr": "// Note that that the Haskell signature of foldr is different from that of\n// foldl - the positions of accumulator and current value are reversed\n\n// foldr :: (a -> b -> b) -> b -> [a] -> b\nconst foldr = (f, a, xs) => xs.reduceRight(flip(f), a);",
  "foldr1": "// foldr1 :: (a -> a -> a) -> [a] -> a\nconst foldr1 = (f, xs) =>\n    0 < xs.length ? init(xs)\n    .reduceRight(f, last(xs)) : [];",
  "foldr1May": "// foldr1May :: (a -> a -> a) -> [a] -> Maybe a\nconst foldr1May = (f, xs) =>\n    0 < xs.length ? (\n        Just(xs.slice(0, -1)\n            .reduceRight(f, xs.slice(-1)[0]))\n    ) : Nothing();",
  "fromEnum": "// fromEnum :: Enum a => a -> Int\nconst fromEnum = x => {\n    const type = typeof x;\n    return 'boolean' === type ? (\n        x ? 1 : 0\n    ) : 'string' === type ? x.charCodeAt(0) : x;\n};",
  "fromLeft": "// | Return the contents of a 'Left'-value or a default value otherwise.\n\n// fromLeft :: a -> Either a b -> a\nconst fromLeft = (def, lr) =>\n  isLeft(lr) ? lr.Left : def;",
  "fromMaybe": "// fromMaybe :: a -> Maybe a -> a\nconst fromMaybe = (def, mb) => mb.Nothing ? def : mb.Just;",
  "fromRight": "// | Return the contents of a 'Right'-value or a default value otherwise.\n\n// fromRight :: b -> Either a b -> b\nconst fromRight = (def, lr) =>\n  isRight(lr) ? lr.Right : def;",
  "fst": "// fst :: (a, b) -> a\nconst fst = tpl => tpl[0];",
  "gcd": "// gcd :: Int -> Int -> Int\nconst gcd = (x, y) => {\n    const\n        _gcd = (a, b) => (0 === b ? a : _gcd(b, a % b)),\n        abs = Math.abs;\n    return _gcd(abs(x), abs(y));\n};",
  "genericIndexMay": "// genericIndexMay :: [a] -> Int -> Maybe a\nconst genericIndexMay = (xs, i) =>\n    (i < xs.length && 0 <= i) ? Just(xs[i]) : Nothing();",
  "getCurrentDirectory": "// getCurrentDirectory :: IO FilePath\nconst getCurrentDirectory = () =>\n    ObjC.unwrap($.NSFileManager.defaultManager.currentDirectoryPath);",
  "getDirectoryContents": "// getDirectoryContents :: FilePath -> IO [FilePath]\nconst getDirectoryContents = strPath =>\n    ObjC.deepUnwrap(\n        $.NSFileManager.defaultManager\n        .contentsOfDirectoryAtPathError(\n            $(strPath)\n            .stringByStandardizingPath, null\n        )\n    );",
  "getFinderDirectory": "// getFinderDirectory :: IO FilePath\nconst getFinderDirectory = () =>\n    Application('Finder')\n    .insertionLocation()\n    .url()\n    .slice(7);",
  "getHomeDirectory": "// getHomeDirectory :: IO FilePath\nconst getHomeDirectory = () =>\n    ObjC.unwrap($.NSHomeDirectory());",
  "getTemporaryDirectory": "// getTemporaryDirectory :: IO FilePath\nconst getTemporaryDirectory = () =>\n    ObjC.unwrap($.NSTemporaryDirectory());",
  "group": "// group :: Eq a => [a] -> [[a]]\nconst group = xs => groupBy((a, b) => a === b, xs);",
  "groupBy": "// Typical usage: groupBy(on(eq, f), xs)\n\n// groupBy :: (a -> a -> Bool) -> [a] -> [[a]]\nconst groupBy = (f, xs) => {\n    const tpl = xs.slice(1)\n        .reduce((a, x) => {\n            const h = a[1].length > 0 ? a[1][0] : undefined;\n            return h !== undefined && f(h, x) ? (\n                Tuple(a[0], a[1].concat([x]))\n            ) : Tuple(a[0].concat([a[1]]), [x]);\n        }, Tuple([], xs.length > 0 ? [xs[0]] : []));\n    return tpl[0].concat([tpl[1]]);\n};",
  "groupSortOn": "// Sort and group a list by comparing the results of a key function\n// applied to each element. groupSortOn f is equivalent to\n// groupBy eq $ sortBy (comparing f),\n// but has the performance advantage of only evaluating f once for each\n// element in the input list.\n// This is a decorate-(group.sort)-undecorate pattern, as in the\n// so-called 'Schwartzian transform'.\n// Groups are arranged from from lowest to highest.\n\n// groupSortOn :: Ord b => (a -> b) -> [a] -> [a]\n// groupSortOn :: Ord b => [((a -> b), Bool)]  -> [a] -> [a]\nconst groupSortOn = (f, xs) => {\n    // Functions and matching bools derived from argument f\n    // which is a single key function\n    const fsbs = unzip(\n            flatten([f])\n            .reduceRight((a, x) =>\n                'boolean' === typeof x ? {\n                    asc: x,\n                    fbs: a.fbs\n                } : {\n                    asc: true,\n                    fbs: [\n                        [x, a.asc]\n                    ].concat(a.fbs)\n                }, {\n                    asc: true,\n                    fbs: []\n                })\n            .fbs\n        ),\n        [fs, bs] = [fsbs[0], fsbs[1]],\n        iLast = fs.length;\n    // decorate-sort-group-undecorate\n    return groupBy(\n            (p, q) => p[0] === q[0],\n            sortBy(\n                mappendComparing(\n                    // functions that access pre-calculated values by position\n                    // in the decorated ('Schwartzian') version of xs\n                    zip(fs.map((_, i) => x => x[i]), bs)\n                ), xs.map( // xs decorated with precalculated key function values\n                    x => fs.reduceRight(\n                        (a, g) => [g(x)].concat(a), [\n                            x\n                        ]\n                    )\n                )\n            )\n        )\n        .map(gp => gp.map(x => x[iLast])); // undecorated version of data, post sort\n};",
  "head": "// head :: [a] -> a\nconst head = xs => xs.length ? xs[0] : undefined;",
  "headMay": "// headMay :: [a] -> Maybe a\nconst headMay = xs =>\n    0 < xs.length ? Just(xs[0]) : Nothing();",
  "id": "// id :: a -> a\nconst id = x => x;",
  "indented": "// indented :: String -> String -> String\nconst indented = (strIndent, s) =>\n    unlines(map(\n        x => '' !== x ? strIndent + x : x,\n        lines(s)\n    ));",
  "index (!!)": "// index (!!) :: [a] -> Int -> a\nconst index = (xs, i) => xs[i];",
  "init": "// init :: [a] -> [a]\nconst init = xs =>\n    0 < xs.length ? (\n        xs.slice(0, -1)\n    ) : undefined;",
  "initMay": "// initMay :: [a] -> Maybe [a]\nconst initMay = xs =>\n    0 < xs.length ? Just(xs.slice(0, -1)) : Nothing();",
  "inits": "// inits([1, 2, 3]) -> [[], [1], [1, 2], [1, 2, 3]\n// inits('abc') -> [\"\", \"a\", \"ab\", \"abc\"]\n\n// inits :: [a] -> [[a]]\n// inits :: String -> [String]\nconst inits = xs => [\n        []\n    ]\n    .concat(('string' === typeof xs ? xs.split('') : xs)\n        .map((_, i, lst) => lst.slice(0, i + 1)));",
  "insert": "// insert :: Ord a => a -> [a] -> [a]\nconst insert = (x, ys) => {\n    const cmp = (a, b) => a < b ? -1 : (a > b ? 1 : 0);\n    for (var i = 0, lng = ys.length; i < lng && cmp(x, ys[i]) > 0; i++) {};\n    return ys.slice(0, i)\n        .concat(x)\n        .concat(ys.slice(i));\n};",
  "insertBy": "// insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]\nconst insertBy = (cmp, x, ys) => {\n    for (var i = 0, lng = ys.length; i < lng && cmp(x, ys[i]) > 0; i++) {};\n    return ys.slice(0, i)\n        .concat(x)\n        .concat(ys.slice(i));\n};",
  "insertMap": "// insertMap :: Dict -> String -> a -> Dict\nconst insertMap = (dct, k, v) =>\n  Object.assign(dct, {[k]: v});",
  "intToDigit": "// intToDigit :: Int -> Char\nconst intToDigit = n =>\n    n >= 0 && n < 16 ? (\n        '0123456789ABCDEF'.charAt(n)\n    ) : '?';",
  "intercalate": "// intercalate :: [a] -> [[a]] -> [a]\n// intercalate :: String -> [String] -> String\nconst intercalate = (sep, xs) =>\n    0 < xs.length && 'string' === typeof sep &&\n    'string' === typeof xs[0] ? (\n        xs.join(sep)\n    ) : concat(intersperse(sep, xs));",
  "intercalateS": "// intercalateS :: String -> [String] -> String\nconst intercalateS = (s, xs) =>\n    xs.join(s);",
  "intersect": "// intersect :: (Eq a) => [a] -> [a] -> [a]\nconst intersect = (xs, ys) => \n  xs.filter(x => -1 !== ys.indexOf(x));",
  "intersectBy": "// intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst intersectBy = (eq, xs, ys) => {\n    const ceq = curry(eq);\n    return (0 < xs.length && 0 < ys.length) ?\n    xs.filter(x => ys.some(ceq(x))) : [];\n};",
  "intersectionBy": "// intersectionBy :: (a -> a -> Bool) -> [[a]] -> [a]\nconst intersectionBy = (eq, xs) =>\n    foldr1(((a, x) => intersectBy(eq, a, x)), xs);",
  "intersperse": "// intersperse(0, [1,2,3]) -> [1, 0, 2, 0, 3]\n\n// intersperse :: a -> [a] -> [a]\n// intersperse :: Char -> String -> String\nconst intersperse = (sep, xs) => {\n    const bool = 'string' === typeof xs;\n    return xs.length > 1 ? (\n        (bool ? concat : x => x)(\n            (bool ? (\n                xs.split('')\n            ) : xs)\n            .slice(1)\n            .reduce((a, x) => a.concat([sep, x]), [xs[0]])\n        )) : xs;\n};",
  "isAlpha": "// isAlpha :: Char -> Bool\nconst isAlpha = c =>\n    /[A-Za-z0-9\\u00C0-\\u00FF]/.test(c);",
  "isChar": "// isChar :: a -> Bool\nconst isChar = x =>\n    ('string' === typeof x) && (1 === x.length);",
  "isDigit": "// isDigit :: Char -> Bool\nconst isDigit = c => {\n  const n = ord(c);\n  return 48 <= n && 57 >= n;\n};",
  "isInfixOf": "// isInfixOf :: Eq a => [a] -> [a] -> Bool\n// isInfixOf :: String -> String -> Bool\nconst isInfixOf = (needle, haystack) =>\n    haystack.includes(needle);",
  "isLeft": "// isLeft :: Either a b -> Bool\nconst isLeft = lr =>\n    ('Either' === lr.type) && (undefined !== lr.Left);",
  "isLower": "// isLower :: Char -> Bool\nconst isLower = c =>\n    /[a-z]/.test(c);",
  "isMaybe": "// isMaybe :: a -> Bool\nconst isMaybe = x =>\n    'Maybe' === x.type;",
  "isNull": "// isNull :: [a] -> Bool\n// isNull :: String -> Bool\nconst isNull = xs =>\n    Array.isArray(xs) || ('string' === typeof xs) ? (\n        1 > xs.length\n    ) : undefined;",
  "isPrefixOf": "// isPrefixOf takes two lists or strings and returns \n// true iff the first is a prefix of the second.\n\n// isPrefixOf :: [a] -> [a] -> Bool\n// isPrefixOf :: String -> String -> Bool\nconst isPrefixOf = (xs, ys) => {\n    const pfx = (xs, ys) => {\n        const intX = xs.length;\n        return 0 < intX ? (\n            ys.length >= intX ? xs[0] === ys[0] && pfx(\n                xs.slice(1), ys.slice(1)\n            ) : false\n        ) : true;\n    };\n    return 'string' !== typeof xs ? (\n        pfx(xs, ys)\n    ) : ys.startsWith(xs);\n};",
  "isRight": "// isRight :: Either a b -> Bool\nconst isRight = lr =>\n  ('undefined' !== typeof lr) && \n  ('Either' === lr.type) && (undefined !== lr.Right);",
  "isSortedBy": "// The 'isSortedBy' function returns true iff the predicate returns true\n// for all adjacent pairs of elements in the list.\n\n// isSortedBy :: (a -> a -> Bool) -> [a] -> Bool\nconst isSortedBy = (cmp, xs) =>\n    xs.length < 2 || all(x => x < 1, zipWith(cmp, xs, tail(xs)));",
  "isSpace": "// isSpace :: Char -> Bool\nconst isSpace = c => /\\s/.test(c);",
  "isSubsequenceOf": "// isSubsequenceOf :: Eq a => [a] -> [a] -> Bool\n// isSubsequenceOf :: String -> String -> Bool\nconst isSubsequenceOf = (xs, ys) => {\n    const iss = (a, b) =>\n        a.length > 0 ? (\n            b.length > 0 ? (\n                iss((a[0] === b[0] ? a.slice(1) : a), b.slice(1))\n            ) : false\n        ) : true;\n    return iss.apply(\n        null, 'string' === typeof xs ? [\n            xs.split(''), ys.split('')\n        ] : [xs, ys]\n    );\n};",
  "isSuffixOf": "// isSuffixOf :: Eq a => [a] -> [a] -> Bool\n// isSuffixOf :: String -> String -> Bool\nconst isSuffixOf = (suffix, main) =>\n    main.indexOf(suffix) === main.length - suffix.length;",
  "isUpper": "// isUpper :: Char -> Bool\nconst isUpper = c =>\n    /[A-Z]/.test(c);",
  "iso8601Local": "// iso8601Local :: Date -> String\nconst iso8601Local = dte =>\n    new Date(dte - (6E4 * dte.getTimezoneOffset()))\n    .toISOString();",
  "iterateUntil": "// iterateUntil :: (a -> Bool) -> (a -> a) -> a -> [a]\nconst iterateUntil = (p, f, x) => {\n    const vs = [x];\n    let h = x;\n    while (!p(h))(h = f(h), vs.push(h));\n    return vs;\n};",
  "jsonLog": "// jsonLog :: a -> IO ()\nconst jsonLog = (...args) =>\n    console.log(\n        args\n        .map(JSON.stringify)\n        .join(' -> ')\n    );",
  "jsonParseLR": "// jsonParseLR :: String -> Either String a\nconst jsonParseLR = s => {\n    try {\n        return Right(JSON.parse(s));\n    } catch (e) {\n        return Left(`${e.message} (line:${e.line} col:${e.column})`);\n    }\n};",
  "justifyLeft": "// justifyLeft :: Int -> Char -> String -> String\nconst justifyLeft = (n, cFiller, strText) =>\n    n > strText.length ? (\n        (strText + cFiller.repeat(n))\n        .substr(0, n)\n    ) : strText;",
  "justifyRight": "// justifyRight :: Int -> Char -> String -> String\nconst justifyRight = (n, cFiller, strText) =>\n    n > strText.length ? (\n        (cFiller.repeat(n) + strText)\n        .slice(-n)\n    ) : strText;",
  "keys": "// keys :: Dict -> [String]\nconst keys = Object.keys;",
  "kleisliCompose (>=>)": "// Kleisli composition LR\n\n// kleisliCompose (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)\nconst kleisliCompose = (f, g) =>\n    x => bind(f(x), g);",
  "last": "// last :: [a] -> a\nconst last = xs => 0 < xs.length ? xs.slice(-1)[0] : undefined;",
  "lastMay": "// lastMay :: [a] -> Maybe a\nconst lastMay = xs => 0 < xs.length ? (\n    Just(xs.slice(-1)[0])\n) : Nothing();",
  "lcm": "// lcm :: Int -> Int -> Int\nconst lcm = (x, y) =>\n   ( x === 0 || y === 0) ? 0 : Math.abs(Math.floor(x / gcd(x, y)) * y);",
  "lefts": "// lefts :: [Either a b] -> [a]\nconst lefts = xs =>\n    concatMap(\n        x => ('Either' === x.type) && (undefined !== x.Left) ? (\n            [x.Left]\n        ) : [], xs\n    );",
  "length": "// length :: [a] -> Int\nconst length = xs => xs.length;",
  "levelNodes": "// levelNodes :: Tree a -> [[Tree a]]\nconst levelNodes = tree =>\n  iterateUntil(\n    xs => 1 > xs.length,\n    xs => concatMap(x => x.nest, xs), [tree]\n  );",
  "levels": "// levels :: Tree a -> [[a]]\nconst levels = tree =>\n    map(xs => map(x => x.root, xs),\n        iterateUntil(\n            xs => 1 > xs.length,\n            xs => concatMap(x => x.nest, xs), [tree]\n        )\n    );",
  "liftA2": "// Lift a binary function to actions.\n// liftA2 f a b = fmap f a <*> b\n\n// liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\nconst liftA2 = (f, a, b) => {\n    const t = a.type;\n    return (\n        undefined !== t ? (\n            'Either' === t ? (\n                liftA2LR\n            ) : 'Maybe' === t ? (\n                liftA2May\n            ) : 'Tuple' === t ? (\n                liftA2Tuple\n            ) : 'Node' === t ? (\n                liftA2Tree\n            ) : liftA2List\n        ) : liftA2List\n    ).apply(null, [f, a, b]);\n};\n\n// const liftA2 = (f, x, y) => ap(fmap(curry(f), x), y);",
  "liftA2LR": "// liftA2LR :: (a -> b -> c) -> Either d a -> Either d b -> Either d c\nconst liftA2LR = (f, a, b) =>\n    undefined !== a.Left ? (\n        a\n    ) : undefined !== b.Left ? (\n        b\n    ) : Right(f(a.Right, b.Right));",
  "liftA2List": "// liftA2List :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst liftA2List = (f, xs, ys) =>\n    concatMap(x => concatMap(y => [f(x, y)], ys), xs);",
  "liftA2May": "// liftA2May :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\nconst liftA2May = (f, a, b) =>\n    a.Nothing ? a : b.Nothing ? b : Just(f(a.Just, b.Just));",
  "liftA2Tree": "// liftA2Tree :: Tree (a -> b -> c) -> Tree a -> Tree b -> Tree c\nconst liftA2Tree = (f, tx, ty) => {\n    const go = tx =>\n        Node(\n            f(tx.root, ty.root),\n            ty.nest.map(curry(fmapTree)(curry(f)(tx.root)))\n            .concat(\n                tx.nest.map(go)\n            )\n        );\n    return go(tx);\n};",
  "liftA2Tuple": "// liftA2Tuple :: Monoid m => (a -> b -> c) -> (m, a) -> (m, b) -> (m, c)\nconst liftA2Tuple = (f, a, b) =>\n    Tuple(mappend(a[0], b[0]), f(a[1], b[1]));",
  "liftM2": "// > liftM2 (+) [0,1] [0,2] = [0,2,1,3]\n// > liftM2 (+) (Just 1) Nothing = Nothing\n\n// Control.Monad : \n// \"Promote a function to a monad, scanning the monadic arguments \n// from left to right.\"\n\n// Add 7, 9, or 10,  to 100 or 1000\n// liftM2(plus, [7, 9, 10], [100, 1000])\n\n// --> [107, 1007, 109, 1009, 110, 1010]\n\n// liftM2 f xs ys = [f] <*> xs <*> ys\n\n// liftM2 :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst liftM2 = liftA2;",
  "liftMmay": "// liftMmay :: (a -> b) -> (Maybe a -> Maybe b)\nconst liftMmay = f =>\n    mb => mb.Nothing ? (\n        mb\n    ) : Just(f(mb.Just))",
  "lines": "// lines :: String -> [String]\nconst lines = s => s.split(/[\\r\\n]/);",
  "listDirectory": "// listDirectory :: FilePath -> [FilePath]\nconst listDirectory = strPath =>\n\tObjC.unwrap(\n\t\t$.NSFileManager.defaultManager\n\t\t.contentsOfDirectoryAtPathError(\n\t\t\tObjC.wrap(strPath)\n\t\t\t.stringByStandardizingPath,\n\t\t\tnull\n\t\t))\n\t.map(ObjC.unwrap);",
  "listFromTuple": "// listFromTuple :: (a, a ...) -> [a]\nconst listFromTuple = tpl =>\n    Object.keys(tpl)\n    .sort()\n    .reduce(\n        (a, k) => 'type' !== k ? (\n            a.concat(tpl[k])\n        ) : a, []\n    );",
  "listToMaybe": "// The listToMaybe function returns Nothing on \n// an empty list or Just the head of the list.\n\n// listToMaybe :: [a] -> Maybe a\nconst listToMaybe = xs =>\n    0 < xs.length ? (\n        Just(xs[0])\n    ) : Nothing();",
  "log": "// log :: Float -> Float\nconst log = Math.log;",
  "lookup": "// lookup :: Eq a => a -> Container -> Maybe b\nconst lookup = (k, m) =>\n    (Array.isArray(m) ? (\n        lookupTuples\n    ) : lookupDict)(k, m);",
  "lookupDict": "// lookupDict :: a -> Dict -> Maybe b\nconst lookupDict = (k, dct) => {\n    const v = dct[k];\n    return undefined !== v ? (\n        Just(v)\n    ) : Nothing();\n};",
  "lookupTuples": "// lookupTuples :: Eq a => a -> [(a, b)] -> Maybe b\nconst lookupTuples = (k, kvs) =>\n    bindMay(\n        find(x => k === fst(x), kvs),\n        x => Just(snd(x))\n    );",
  "mReturn": "// Not required in JS, which has first functions by default.\n// Included only for comparison with AS, which has to derive\n// first class functions by lifting 'handlers' into 'scripts'\n// as anonymous |λ|() functions.\n\n// In JS, mReturn is just an alternate name for id.\n\n// mReturn :: First-class m => (a -> b) -> m (a -> b)\nconst mReturn = id;",
  "map": "// map :: (a -> b) -> [a] -> [b]\nconst map = (f, xs) => xs.map(f);",
  "mapAccumL": "// 'The mapAccumL function behaves like a combination of map and foldl; \n// it applies a function to each element of a list, passing an accumulating \n// parameter from left to right, and returning a final value of this \n// accumulator together with the new list.' (See Hoogle)\n\n// mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\nconst mapAccumL = (f, acc, xs) =>\n    xs.reduce((a, x, i) => {\n        const pair = f(a[0], x, i);\n        return Tuple(pair[0], a[1].concat(pair[1]));\n    }, Tuple(acc, []));",
  "mapAccumL_Tree": "// mapAccumL_Tree :: (acc -> x -> (acc, y)) -> acc -> Tree -> (acc, Tree)\nconst mapAccumL_Tree = (f, acc, tree) => {\n    const go = (a, x) => {\n        const\n            pair = f(a, x.root),\n            tpl = mapAccumL(go, pair[0], x.nest);\n        return Tuple(tpl[0], Node(pair[1], tpl[1]));\n    };\n    return go(acc, tree);\n};",
  "mapAccumR": "// 'The mapAccumR function behaves like a combination of map and foldr; \n// it applies a function to each element of a list, passing an accumulating \n// parameter from right to left, and returning a final value of this \n// accumulator together with the new list.' (See Hoogle)\n\n// mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\nconst mapAccumR = (f, acc, xs) =>\n    xs.reduceRight((a, x, i) => {\n        const pair = f(a[0], x, i);\n        return Tuple(pair[0],\n            [pair[1]].concat(a[1])\n        );\n    }, Tuple(acc, []));",
  "mapFromList": "// mapFromList :: [(k, v)] -> Dict\nconst mapFromList = kvs =>\n    kvs.reduce(\n        (a, kv) => {\n            const k = kv[0];\n            return Object.assign(a, {\n                [(('string' === typeof k) && k) || show(k)]: kv[1]\n            });\n        }, {}\n    );",
  "mapKeys": "// A function mapped over the keys of a record\n\n// mapKeys :: (Key -> Key) -> IntMap a -> IntMap a\nconst mapKeys = (f, dct) =>\n    mapFromList(\n        map(\n            kv => [f(read(kv[0])), kv[1]],\n            zip(keys(dct), elems(dct))\n        )\n    );",
  "mapMaybe": "// The mapMaybe function is a version of map which can throw out\n// elements. In particular, the functional argument returns\n// something of type Maybe b. If this is Nothing, no element is\n// added on to the result list. If it just Just b, then b is\n// included in the result list.\n\n// mapMaybe :: (a -> Maybe b) -> [a] -> [b]\nconst mapMaybe = (mf, xs) =>\n    concatMap(compose(mf, maybeToList), xs);",
  "mappend (<>)": "// mappend (<>) :: Monoid a => a -> a -> a\nconst mappend = (a, b) => {\n    const t = a.type;\n    return (Boolean(t) ? (\n        'Maybe' === t ? (\n            mappendMaybe\n        ) : 'Ordering' === t ? (\n            mappendOrdering\n        ) : mappendTuple\n    ) : append)(a, b);\n};",
  "mappendComparing": "// mappendComparing :: [(a -> b)] -> (a -> a -> Ordering)\nconst mappendComparing = fs =>\n    (x, y) => fs.reduce(\n        (ordr, f) => (ordr || compare(f(x), f(y))),\n        0\n    );",
  "mappendComparing2": "// Expects functions in the argument list to be \n// paired with Bools:\n//     true  -> ascending sort on that key\n//     false -> descending sort on that key\n\n// mappendComparing2 :: [((a -> b), Bool)] -> (a -> a -> Ordering)\nconst mappendComparing2 = fboolPairs =>\n    (x, y) => fboolPairs.reduce(\n        (ordr, fb) => {\n            const f = fb[0];\n            return 0 !== ordr ? (\n                ordr\n            ) : fb[1] ? (\n                compare(f(x), f(y))\n            ) : compare(f(y), f(x));\n        }, 0\n    );",
  "mappendMaybe (<>)": "// mappendMaybe (<>) :: Maybe a -> Maybe a -> Maybe a\nconst mappendMaybe = (a, b) =>\n    a.Nothing ? b : b.Nothing ? a :\n    Just(mappend(a.Just, b.Just));",
  "mappendOrdering (<>)": "// mappendOrdering (<>) :: Ordering -> Ordering -> Ordering\nconst mappendOrdering = (a, b) => eqOrdering(EQ, a) ? b : a;",
  "mappendTuple (<>)": "// mappendTuple (<>) :: (a, b) -> (a, b) -> (a, b)\nconst mappendTuple = (t, t2) =>\n    Tuple(mappend(t[0], t1[0]), mappend(t[1], t1[1]));",
  "max": "// max :: Ord a => a -> a -> a\nconst max = (a, b) => b > a ? b : a;",
  "maximum": "// maximum :: Ord a => [a] -> a\nconst maximum = xs =>\n    0 < xs.length ? (\n        foldl1((a, x) => x > a ? x : a, xs)\n    ) : undefined;",
  "maximumBy": "//  Ordering: (LT|EQ|GT):\n//  GT: 1 (or other positive n)\n//\tEQ: 0\n//  LT: -1 (or other negative n) \n\n// maximumBy :: (a -> a -> Ordering) -> [a] -> a\nconst maximumBy = (f, xs) =>\n    0 < xs.length ? (\n        xs.slice(1)\n        .reduce((a, x) => 0 < f(x, a) ? x : a, xs[0])\n    ) : undefined;",
  "maximumByMay": "//Ordering: (LT|EQ|GT):\n//  GT: 1 (or other positive n)\n//\tEQ: 0\n//  LT: -1 (or other negative n) \n\n// maximumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\nconst maximumByMay = (f, xs) =>\n    xs.length > 0 ? (\n        Just(xs.slice(1)\n            .reduce((a, x) => 0 < f(x, a) ? x : a, xs[0]))\n    ) : Nothing();",
  "maximumMay": "// maximumMay :: Ord a => [a] -> Maybe a\nconst maximumMay = xs =>\n    0 < xs.length ? (\n        Just(xs.slice(1)\n            .reduce((a, x) => (x > a ? x : a), xs[0]))\n    ) : Nothing();",
  "maybe": "// Default value (v) if m.Nothing, or f(m.Just)\n\n// maybe :: b -> (a -> b) -> Maybe a -> b\nconst maybe = (v, f, m) =>\n    m.Nothing ? v : f(m.Just);",
  "maybeToList": "// The maybeToList function returns an empty list when given\n// Nothing or a singleton list when not given Nothing.”\n\n// maybeToList :: Maybe a -> [a]\nconst maybeToList = mb =>\n    mb.Nothing ? [] : [mb.Just];",
  "mean": "// mean :: [Num] -> Num\nconst mean = xs =>\n  xs.reduce((a, x) => a + x, 0) / xs.length;",
  "member": "// member :: Key -> Dict -> Bool\nconst member = (k, dct) => k in dct;",
  "min": "// min :: Ord a => a -> a -> a\nconst min = (a, b) => b < a ? b : a;",
  "minimum": "// minimum :: Ord a => [a] -> a\nconst minimum = xs =>\n    0 < xs.length ? (\n        foldl1((a, x) => x < a ? x : a, xs)\n    ) : undefined;",
  "minimumBy": "//Ordering: (LT|EQ|GT):\n//  GT: 1 (or other positive n)\n//\tEQ: 0\n//  LT: -1 (or other negative n)\n\n// minimumBy :: (a -> a -> Ordering) -> [a] -> a\nconst minimumBy = (f, xs) =>\n    xs.reduce((a, x) => undefined === a ? x : (\n        0 > f(x, a) ? x : a\n    ), undefined);",
  "minimumByMay": "// minimumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\nconst minimumByMay = (f, xs) =>\n    xs.reduce((a, x) => a.Nothing ? Just(x) : (\n        f(x, a.Just) < 0 ? Just(x) : a\n    ), Nothing());",
  "minimumMay": "// minimumMay :: [a] -> Maybe a\nconst minimumMay = xs =>\n    0 < xs.length ? (\n        Just(xs.slice(1)\n            .reduce((a, x) => x < a ? x : a, xs[0])\n        )\n    ) : Nothing();",
  "mod": "// mod :: Int -> Int -> Int\nconst mod = (n, d) => n % d;",
  "modificationTime": "// modificationTime :: FilePath -> Either String Date\nconst modificationTime = fp =>\n    bindLR(\n       fileStatus(fp),\n       dct => Right(ObjC.unwrap(dct.NSFileModificationDate))\n    );",
  "negate": "// negate :: Num -> Num\nconst negate = n => -n;",
  "newUUID": "// newUUID :: () -> IO UUID String\nconst newUUID = () =>\n    ObjC.unwrap($.NSUUID.UUID.UUIDString);",
  "not": "// not :: Bool -> Bool\nconst not = b => !b;",
  "notElem": "// notElem :: Eq a => a -> [a] -> Bool\nconst notElem = (x, xs) => -1 === xs.indexOf(x);",
  "nub": "// nub :: [a] -> [a]\nconst nub = xs => nubBy((a, b) => a === b, xs);",
  "nubBy": "// nubBy :: (a -> a -> Bool) -> [a] -> [a]\nconst nubBy = (p, xs) => {\n    const go = xs => 0 < xs.length ? (() => {\n        const x = xs[0];\n        return [x].concat(\n            go(xs.slice(1)\n                .filter(y => !p(x, y))\n            )\n        )\n    })() : [];\n    return go(xs);\n};",
  "odd": "// odd :: Int -> Bool\nconst odd = n => !even(n);",
  "on": "// e.g. sortBy(on(compare,length), xs)\n\n// on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\nconst on = (f, g) => (a, b) => f(g(a), g(b));",
  "or": "// or :: [Bool] -> Bool\nconst or = xs =>\n    xs.some(Boolean);",
  "ord": "// ord :: Char -> Int\nconst ord = c => c.codePointAt(0);",
  "outdented": "// All lines in the string outdented by the same amount\n// (just enough to ensure that the least indented lines \n//  have no remaining indent)\n// All relative indents are left unchanged\n\n// outdented :: String -> String\nconst outdented = s => {\n    const\n        rgx = /^ */, // Leading space characters.\n        xs = lines(s),\n        n = length(minimumBy( // size of minimum indent\n            comparing(length),\n            map(txt => rgx.exec(txt)[0], xs)\n        ));\n    return unlines(map(curry(drop)(n), xs));\n};",
  "partition": "// partition :: Predicate -> List -> (Matches, nonMatches)\n\n// partition :: (a -> Bool) -> [a] -> ([a], [a])\nconst partition = (p, xs) =>\n    xs.reduce(\n        (a, x) =>\n        p(x) ? (\n            Tuple(a[0].concat(x), a[1])\n        ) : Tuple(a[0], a[1].concat(x)),\n        Tuple([], [])\n    );",
  "partitionEithers": "// partitionEithers :: [Either a b] -> ([a],[b])\nconst partitionEithers = xs =>\n    xs.reduce((a, x) =>\n        x.Left !== undefined ? (\n            Tuple(a[0].concat(x.Left), a[1])\n        ) : Tuple(a[0], a[1].concat(x.Right)),\n        Tuple([], [])\n    );",
  "permutations": "// permutations :: [a] -> [[a]]\nconst permutations = xs =>\n    xs.length ? concatMap(x => concatMap(ys => [\n            [x].concat(ys)\n        ],\n        permutations(delete_(x, xs))), xs) : [\n        []\n    ];",
  "permutationsWithRepetition": "// permutationsWithRepetition :: Int -> [a] -> [[a]]\nconst permutationsWithRepetition = (n, xs) =>\n    xs.length > 0 ? (\n        map(flatten,\n            foldl1(\n                x => cartesianProduct(xs, x),\n                replicate(n, xs)\n            )\n        )\n    ) : [];",
  "pi": "// pi :: Float\nconst pi = Math.PI;",
  "plus": "// plus :: Num -> Num -> Num\nconst plus = (a, b) => a + b;",
  "postorder": "// Root elements of tree flattened bottom-up\n// into a postorder list.\n\n// postorder :: Tree a -> [a]\nconst postorder = t => {\n    const go = (xs, x) =>\n        x.nest.reduce(go, xs).concat(x.root);\n    return go([], t);\n};",
  "pred": "// pred :: Enum a => a -> a\nconst pred = x =>\n    isChar(x) ? (\n        chr(ord(x) - 1)\n    ) : isNaN(x) ? (\n        undefined\n    ) : x - 1;",
  "product": "// product :: [Num] -> Num\nconst product = xs => xs.reduce((a, x) => a * x, 1);",
  "properFraction": "// properFraction :: Real -> (Int, Real)\nconst properFraction = n => {\n    const i = Math.floor(n) + (n < 0 ? 1 : 0);\n    return Tuple(i, n - i);\n};",
  "pureLR": "// pureLR :: a -> Either e a\nconst pureLR = x => Right(x);",
  "pureList": "// pureList :: a -> [a]\nconst pureList = x => [x];",
  "pureMay": "// pureMay :: a -> Maybe a\nconst pureMay = x => Just(x);",
  "pureT": "// Given a type name string, returns a \n// specialised 'pure', where\n// 'pure' lifts a value into a particular functor.\n\n// pureT :: String -> f a -> (a -> f a)\nconst pureT = (t, x) =>\n    'List' !== t ? (\n        'Either' === t ? (\n            pureLR(x)\n        ) : 'Maybe' === t ? (\n            pureMay(x)\n        ) : 'Tree' === t ? (\n            pureTree(x)\n        ) : 'Tuple' === t ? (\n            pureTuple(x)\n        ) : pureList(x)\n    ) : pureList(x);",
  "pureTree": "// pureTree :: a -> Tree a\nconst pureTree = x => Node(x, []);",
  "pureTuple": "// pureTuple :: a -> (a, a)\nconst pureTuple = x => Tuple('', x);",
  "quickSort": "// Included only for comparison with AppleScript\n// sort and sortBy are faster and more flexible\n\n// quickSort :: (Ord a) => [a] -> [a]\nconst quickSort = xs =>\n    xs.length > 1 ? (() => {\n        const\n            h = xs[0],\n            lessMore = partition(x => x <= h, xs.slice(1));\n        return [].concat.apply(\n            [], [quickSort(lessMore[0]), h, quickSort(lessMore[1])]\n        );\n    })() : xs;",
  "quickSortBy": "// Included only for comparison with AppleScript\n// sort and sortBy are faster and more flexible\n\n// quickSortBy :: (a -> a -> Ordering) -> [a] -> [a]\nconst quickSortBy = (cmp, xs) =>\n    xs.length > 1 ? (() => {\n        const\n            h = xs[0],\n            lessMore = partition(\n                x => cmp(x, h) !== 1,\n                xs.slice(1)\n            );\n        return [].concat.apply(\n            [], [quickSortBy(cmp, lessMore[0]), h, quickSortBy(cmp, lessMore[1])]\n        );\n    })() : xs;",
  "quot": "// quot :: Int -> Int -> Int\nconst quot = (n, m) => Math.floor(n / m);",
  "quotRem": "// quotRem :: Int -> Int -> (Int, Int)\nconst quotRem = (m, n) => Tuple(Math.floor(m / n), m % n);",
  "raise": "// raise :: Num -> Int -> Num\nconst raise = (n, e) => Math.pow(n, e);",
  "randomRInt": "// randomRInt :: Int -> Int -> Int\nconst randomRInt = (low, high) =>\n    low + Math.floor(\n        (Math.random() * ((high - low) + 1))\n    );",
  "range": "// The list of values in the subrange defined by a bounding pair.\n\n// range([0, 2]) -> [0,1,2]\n// range([[0,0], [2,2]]) \n//  -> [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\n// range([[0,0,0],[1,1,1]])\n//  -> [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]\n\n// range :: Ix a => (a, a) -> [a]\nfunction range() {\n    const\n        args = Array.from(arguments),\n        ab = args.length !== 1 ? (\n            args\n        ) : args[0],\n        [as, bs] = [ab[0], ab[1]].map(\n            x => Array.isArray(x) ? (\n                x\n            ) : (x.type !== undefined) &&\n            (x.type.startsWith('Tuple')) ? (\n                listFromTuple(x)\n            ) : [x]\n        ),\n        an = as.length;\n    return (an === bs.length) ? (\n        an > 1 ? (\n            sequenceAList(as.map((_, i) => enumFromTo(as[i], bs[i])))\n        ) : enumFromTo(as[0], bs[0])\n    ) : [];\n};",
  "read": "// read :: Read a => String -> a\nconst read = JSON.parse;",
  "readFile": "// readFile :: FilePath -> IO String\nconst readFile = strPath => {\n    const\n        error = $(),\n        str = ObjC.unwrap(\n            $.NSString.stringWithContentsOfFileEncodingError(\n                $(strPath)\n                .stringByStandardizingPath,\n                $.NSUTF8StringEncoding,\n                error\n            )\n        );\n    return Boolean(error.code) ? (\n        ObjC.unwrap(error.localizedDescription)\n    ) : str;\n};",
  "readFileLR": "// readFileLR :: FilePath -> Either String String\nconst readFileLR = strPath => {\n    const\n        error = $(),\n        str = ObjC.unwrap(\n            $.NSString.stringWithContentsOfFileEncodingError(\n                $(strPath)\n                .stringByStandardizingPath,\n                $.NSUTF8StringEncoding,\n                error\n            )\n        );\n    return Boolean(error.code) ? (\n        Left(error.message)\n    ) : Right(str);\n};",
  "readLR": "// readLR :: Read a => String -> Either String a\nconst readLR = s => {\n    try {\n        return Just(JSON.parse(s))\n    } catch (e) {\n        return Nothing();\n    };\n};",
  "recip": "// recip :: Num -> Num\nconst recip = n =>\n    n !== 0 ? (1 / n) : undefined;",
  "recipMay": "// recipMay :: Num -> Maybe Num\nconst recipMay = n =>\n    0 === n ? (\n        Nothing()\n    ) : Just(1 / n);",
  "regexMatches": "// regexMatches :: String -> String -> [[String]]\nconst regexMatches = (strRgx, strHay) => {\n    const rgx = new RegExp(strRgx, 'g');\n    let m = rgx.exec(strHay),\n        xs = [];\n    while (m)(xs.push(m), m = rgx.exec(strHay));\n    return xs;\n};",
  "rem": "// rem :: Int -> Int -> Int\nconst rem = (n, m) => n % m;",
  "removeFile": "// removeFile :: FilePath -> Either String String\nconst removeFile = fp => {\n  const error = $();\n  return $.NSFileManager.defaultManager\n    .removeItemAtPathError(fp, error) ? (\n      Right('Removed: ' + fp)\n    ) : Left(ObjC.unwrap(error.localizedDescription));\n};",
  "replace": "// replace :: String -> String -> String -> String\n// replace :: Regex -> String -> String -> String\nconst replace = (needle, strNew, strHaystack) =>\n    strHaystack.replace(\n        typeof needle !== 'string' ? (\n            needle\n        ) : new RegExp(needle, 'g'),\n        strNew\n    );",
  "replicate": "// replicate :: Int -> a -> [a]\nconst replicate = (n, x) =>\n    Array.from({\n        length: n\n    }, () => x);",
  "replicateM": "// Instance for lists (arrays) only here\n\n// replicateM :: Int -> [a] -> [[a]]\nconst replicateM = (n, xs) => {\n    const loop = x => x <= 0 ? [\n        []\n    ] : liftA2(cons, xs, loop(x - 1));\n    return loop(n);\n};",
  "replicateString": "// replicateString :: Int -> String -> String\nconst replicateString = (n, s) => s.repeat(n);",
  "reverse": "// reverse :: [a] -> [a]\nconst reverse = xs =>\n    typeof xs === 'string' ? (\n        xs.split('')\n        .reverse()\n        .join('')\n    ) : xs.slice(0)\n    .reverse();",
  "rights": "// rights :: [Either a b] -> [b]\nconst rights = xs =>\n    concatMap(\n        x => ('Either' === x.type) && (undefined !== x.Right) ? (\n            [x.Right]\n        ) : [], xs\n    );",
  "rotate": "// rotate :: Int -> [a] -> [a]\nconst rotate = (n, xs) => {\n    const lng = xs.length;\n    return lng > 0 ? takeDropCycle(lng, n, xs) : [];\n};",
  "round": "// round :: a -> Int\nconst round = x => {\n    const\n        nr = properFraction(x),\n        [n, r] = [nr[0], nr[1]]\n        m = n + (r < 0 ? -1 : 1),\n        sign = signum(abs(r) - 0.5);\n    return (-1 === sign) ? n : (\n        0 === sign ? (even(n) ? n : m) : (\n            1 === sign ? m : undefined\n        )\n    );\n};",
  "safeMay": "// safeMay :: (a -> Bool) -> (a -> b) -> Maybe b\nconst safeMay = (p, f, x) =>\n    p(x) ? Just(f(x)) : Nothing();",
  "scanl": "// scanl :: (b -> a -> b) -> b -> [a] -> [b]\nconst scanl = (f, startValue, xs) =>\n    xs.reduce((a, x) => {\n        const v = f(a[0], x);\n        return Tuple(v, a[1].concat(v));\n    }, Tuple(startValue, [startValue]))[1];",
  "scanl1": "// scanl1 is a variant of scanl that has no starting value argument\n\n// scanl1 :: (a -> a -> a) -> [a] -> [a]\nconst scanl1 = (f, xs) =>\n    xs.length > 0 ? scanl(f, xs[0], xs.slice(1)) : [];",
  "scanr": "// scanr :: (b -> a -> b) -> b -> [a] -> [b]\nconst scanr = (f, startValue, xs) =>\n    xs.reduceRight((a, x) => {\n        const v = f(a.acc, x);\n        return {\n            acc: v,\n            scan: [v].concat(a.scan)\n        };\n    }, {\n        acc: startValue,\n        scan: [startValue]\n    })\n    .scan;",
  "scanr1": "// scanr1 is a variant of scanr that has no starting value argument\n\n// scanr1 :: (a -> a -> a) -> [a] -> [a]\nconst scanr1 = (f, xs) =>\n    xs.length > 0 ? scanr(f, xs.slice(-1)[0], xs.slice(0, -1)) : [];",
  "secondArrow": "// Lift a simple function to one which applies to a tuple, \n// transforming only the second item of the tuple\n\n// secondArrow :: (a -> b) -> ((c, a) -> (c, b))\nconst secondArrow = f => xy => Tuple(xy[0], f(xy[1]));",
  "sequenceAList": "// sequenceAList :: Applicative f => [f a] -> f [a]\nconst sequenceAList = xs =>\n    traverseList(x => x, xs);",
  "setCurrentDirectory": "// setCurrentDirectory :: String -> IO ()\nconst setCurrentDirectory = strPath =>\n    $.NSFileManager.defaultManager\n    .changeCurrentDirectoryPath(\n        ObjC.wrap(strPath)\n        .stringByStandardizingPath\n    );",
  "show": "// show :: a -> String\n// show :: a -> Int -> Indented String\nconst show = (x, n) => {\n    const\n        e = ('function' !== typeof x) ? (\n            x\n        ) : {\n            type: 'Function',\n            f: x\n        };\n    return JSON.stringify(e, (_, v) => {\n        const\n            f = (v !== null && v !== undefined) ? (() => {\n                const t = v.type;\n                return 'Either' === t ? (\n                    showLR\n                ) : 'Function' === t ? (\n                    dct => 'λ' + dct.f.toString()\n                ) : 'Maybe' === t ? (\n                    showMaybe\n                ) : 'Ordering' === t ? (\n                    showOrdering\n                ) : 'Ratio' === t ? (\n                    showRatio\n                ) : 'Tuple' === t ? (\n                    showTuple\n                ) : 'Tuple3' === t ? (\n                    showTuple3\n                ) : 'Tuple4' === t ? (\n                    showTuple4\n                ) : undefined;\n            })() : showUndefined;\n        return Boolean(f) ? (\n            f(v)\n        ) : 'string' !== typeof v ? (\n            v\n        ) : \"'\" + v + \"'\";\n    }, n)\n};",
  "showBinary": "// showBinary :: Int -> String\nconst showBinary = n => {\n    const binaryChar = n => 0 !== n ? '1' : '0';\n    return showIntAtBase(2, binaryChar, n, '');\n};",
  "showDate": "// showDate :: Date -> String\nconst showDate = JSON.stringify;",
  "showDict": "// showDict :: Dict -> String\nconst showDict = show;",
  "showHex": "// showHex :: Int -> String\nconst showHex = n =>\n    showIntAtBase(16, intToDigit, n, '');",
  "showIntAtBase": "// showIntAtBase :: Int -> (Int -> Char) -> Int -> String -> String\nconst showIntAtBase = (base, toChr, n, rs) => {\n    const showIt = ([n, d], r) => {\n        const r_ = toChr(d) + r;\n        return 0 !== n ? (\n            showIt(quotRem(n, base), r_)\n        ) : r_;\n    };\n    return 1 >= base ? (\n        'error: showIntAtBase applied to unsupported base'\n    ) : 0 > n ? (\n        'error: showIntAtBase applied to negative number'\n    ) : showIt(quotRem(n, base), rs);\n};",
  "showJSON": "// showJSON :: a -> String\nconst showJSON = x => JSON.stringify(x, null, 2);",
  "showLR": "// showLR :: Either a b -> String\nconst showLR = lr => {\n    const k = lr.Left !== undefined ? (\n        'Left'\n    ) : 'Right';\n    return k + '(' + unQuoted(show(lr[k])) + ')';\n};",
  "showList": "// showList :: [a] -> String\nconst showList = show;",
  "showLog": "// showLog :: a -> IO ()\nconst showLog = (...args) =>\n    console.log(\n        args\n        .map(JSON.stringify)\n        .join(' -> ')\n    );",
  "showMaybe": "// showMaybe :: Maybe a -> String\nconst showMaybe = mb =>\n    mb.Nothing ? (\n        'Nothing'\n    ) : 'Just(' + unQuoted(show(mb.Just)) + ')';",
  "showOrdering": "// showOrdering :: Ordering -> String\nconst showOrdering = e =>\n    e.value > 0 ? (\n        'GT'\n    ) : e.value < 0 ? (\n        'LT'\n    ) : 'EQ';",
  "showRatio": "// showRatio :: Ratio -> String\nconst showRatio = nd =>\n    nd.n.toString() + '/' + nd.d.toString();",
  "showTuple": "// showTuple :: Tuple -> String\nconst showTuple = tpl =>\n    '(' + [0, 1].map(x => unQuoted(show(tpl[x])))\n    .join(',') + ')';",
  "showTuple3": "// showTuple3 :: Tuple3 -> String\nconst showTuple3 = tpl =>\n    '(' + [0, 1, 2].map(x => unQuoted(show(tpl[x])))\n    .join(',') + ')';",
  "showTuple4": "// showTuple4 :: Tuple4 -> String\nconst showTuple4 = tpl =>\n    '(' + [0, 1, 2, 3].map(x => unQuoted(show(tpl[x])))\n    .join(',') + ')';",
  "showUndefined": "// showUndefined :: () -> String\nconst showUndefined = () => '(⊥)';",
  "signum": "// | Sign of a number.\n// The functions 'abs' and 'signum' should satisfy the law:\n//\n// > abs x * signum x == x\n//\n// For real numbers, the 'signum' is either @-1@ (negative), @0@ (zero)\n// or @1@ (positive).\n\n// signum :: Num -> Num\nconst signum = n => 0 > n ? -1 : (0 < n ? 1 : 0);",
  "snd": "// snd :: (a, b) -> b\nconst snd = tpl => tpl[1];",
  "snoc": "// Mirror image of cons\n// New copy of the list, with an atom added at the end\n\n// snoc :: [a] -> a -> [a]\nconst snoc = (xs, x) => xs.concat(x);",
  "sort": "// sort :: Ord a => [a] -> [a]\nconst sort = xs => xs.slice()\n    .sort((a, b) => a < b ? -1 : (a > b ? 1 : 0));",
  "sortBy": "// sortBy :: (a -> a -> Ordering) -> [a] -> [a]\nconst sortBy = (f, xs) =>\n    xs.slice()\n    .sort(f);",
  "sortOn": "// Sort a list by comparing the results of a key function applied to each\n// element. sortOn f is equivalent to sortBy (comparing f), but has the\n// performance advantage of only evaluating f once for each element in\n// the input list. This is called the decorate-sort-undecorate paradigm,\n// or Schwartzian transform.\n// Elements are arranged from from lowest to highest.\n\n// sortOn :: Ord b => (a -> b) -> [a] -> [a]\nconst sortOn = (f, xs) => {\n    // Functions and matching bools derived from argument f\n    // which may be a single key function, or a list of key functions\n    // each of which may or may not be followed by a direction bool.\n    const fsbs = unzip(\n            flatten([f])\n            .reduceRight((a, x) =>\n                ('boolean' === typeof x) ? {\n                    asc: x,\n                    fbs: a.fbs\n                } : {\n                    asc: true,\n                    fbs: [\n                        [x, a.asc]\n                    ].concat(a.fbs)\n                }, {\n                    asc: true,\n                    fbs: []\n                })\n            .fbs\n        ),\n        [fs, bs] = [fsbs[0], fsbs[1]],\n        iLast = fs.length;\n    // decorate-sort-undecorate\n    return sortBy(mappendComparing_(\n            // functions that access pre-calculated values\n            // by position in the decorated ('Schwartzian')\n            // version of xs\n            zip(fs.map((_, i) => x => x[i]), bs)\n        ), xs.map( // xs decorated with precalculated values\n            x => fs.reduceRight(\n                (a, g) => [g(x)].concat(a), [\n                    x\n                ])))\n        .map(x => x[iLast]); // undecorated version of data, post sort.\n};",
  "span": "// span, applied to a predicate p and a list xs, returns a tuple of xs of \n// elements that satisfy p and second element is the remainder of the list:\n//\n// > span (< 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])\n// > span (< 9) [1,2,3] == ([1,2,3],[])\n// > span (< 0) [1,2,3] == ([],[1,2,3])\n//\n// span p xs is equivalent to (takeWhile p xs, dropWhile p xs) \n\n// span :: (a -> Bool) -> [a] -> ([a], [a])\nconst span = (f, xs) =>\n    splitAt(until(\n        i => !f(xs[i]),\n        i => i + 1,\n        0\n    ), xs);",
  "splitArrow (***)": "// Compose a function (from a tuple to a tuple), \n// (with separate transformations for fst and snd)\n\n// splitArrow (***) :: (a -> b) -> (c -> d) -> ((a, c) -> (b, d))\nconst splitArrow = (f, g) => tpl => Tuple(f(tpl[0]), g(tpl[1]));",
  "splitAt": "// splitAt :: Int -> [a] -> ([a],[a])\nconst splitAt = (n, xs) => Tuple(xs.slice(0, n), xs.slice(n));",
  "splitBy": "// Splitting not on a delimiter, but whenever the relationship between\n// two consecutive items matches a supplied predicate function\n\n// splitBy :: (a -> a -> Bool) -> [a] -> [[a]]\n// splitBy :: (String -> String -> Bool) -> String -> [String]\nconst splitBy = (p, xs) =>\n    (xs.length < 2) ? [xs] : (() => {\n        const\n            bln = 'string' === typeof xs,\n            ys = bln ? xs.split('') : xs,\n            h = ys[0],\n            parts = ys.slice(1)\n            .reduce(([acc, active, prev], x) =>\n                p(prev, x) ? (\n                    [acc.concat([active]), [x], x]\n                ) : [acc, active.concat(x), x], [\n                    [],\n                    [h],\n                    h\n                ]);\n        return (bln ? (\n            ps => ps.map(cs => ''.concat.apply('', cs))\n        ) : x => x)(parts[0].concat([parts[1]]));\n    })();",
  "splitEvery": "// splitEvery :: Int -> [a] -> [[a]]\nconst splitEvery = (n, xs) => {\n    if (xs.length <= n) return [xs];\n    const [h, t] = [xs.slice(0, n), xs.slice(n)];\n    return [h].concat(splitEvery(n, t));\n};",
  "splitFileName": "// Split a filename into directory and file. combine is the inverse.\n\n// splitFileName :: FilePath -> (String, String)\nconst splitFileName = strPath =>\n    ('' !== strPath) ? (\n         ('/' !== strPath[strPath.length - 1]) ? (() => {\n            const\n                xs = strPath.split('/'),\n                stem = xs.slice(0, -1);\n            return stem.length > 0 ? (\n                Tuple(stem.join('/') + '/', xs.slice(-1)[0])\n            ) : Tuple('./', xs.slice(-1)[0]);\n        })() : Tuple(strPath, '')\n    ) : Tuple('./', '');",
  "splitOn": "// splitOn(\"\\r\\n\", \"a\\r\\nb\\r\\nd\\r\\ne\") //--> [\"a\", \"b\", \"d\", \"e\"]\n// splitOn(\"aaa\", \"aaaXaaaXaaaXaaa\") //--> [\"\", \"X\", \"X\", \"X\", \"\"]\n// splitOn(\"x\", \"x\") //--> [\"\", \"\"]\n// splitOn(5, [1, 5, 9, 2, 6, 5, 3, 5]) //--> [[1], [9, 2, 6], [3], []]\n\n// splitOn :: a -> [a] -> [[a]]\n// splitOn :: String -> String -> [String]\nconst splitOn = (needle, haystack) =>\n    ('string' === typeof haystack) ? (\n        haystack.split(needle)\n    ) : (() => {\n        const tpl = haystack.reduce(\n            (a, x) => eq(needle, x) ? Tuple(\n                a[0].concat([a[1]]), []\n            ) : Tuple(a[0], a[1].concat(x)),\n            Tuple([], [])\n        );\n        return tpl[0].concat([tpl[1]]);\n    })();",
  "splitRegex": "// splitRegex :: Regex -> String -> [String]\nconst splitRegex = (needle, haystack) =>\n    haystack.split(needle);",
  "sqrt": "// sqrt :: Num -> Num\nconst sqrt = n =>\n    (0 <= n) ? Math.sqrt(n) : undefined;",
  "sqrtLR": "// sqrtLR :: Num -> Either String Num\nconst sqrtLR = n =>\n    0 > n ? (\n        Left('Square root of negative number: ' + n)\n    ) : Right(Math.sqrt(n));",
  "sqrtMay": "// sqrtMay :: Num -> Maybe Num\nconst sqrtMay = n =>\n    0 > n ? (\n        Nothing()\n    ) : Just(Math.sqrt(n));",
  "strip": "// strip :: String -> String\nconst strip = s => s.trim();",
  "stripEnd": "// stripEnd :: String -> String\nconst stripEnd = s => dropWhileEnd(isSpace, s);",
  "stripPrefix": "// stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]\nconst stripPrefix = (pfx, s) => {\n    const\n        blnString = 'string' === typeof pfx,\n        [xs, ys] = blnString ? (\n            [pfx.split(''), s.split('')]\n        ) : [pfx, s];\n    const\n        sp_ = (xs, ys) => 0 === xs.length ? (\n            Just(blnString ? ys.join('') : ys)\n        ) : (0 === ys.length || xs[0] !== ys[0]) ? (\n            Nothing()\n        ) : sp_(xs.slice(1), ys.slice(1));\n    return sp_(xs, ys);\n};",
  "stripStart": "// stripStart :: String -> String\nconst stripStart = s => dropWhile(isSpace, s);",
  "subsequences": "// subsequences([1,2,3]) -> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n// subsequences('abc') -> [\"\",\"a\",\"b\",\"ab\",\"c\",\"ac\",\"bc\",\"abc\"]\n\n// subsequences :: [a] -> [[a]]\n// subsequences :: String -> [String]\nconst subsequences = xs => {\n    const\n        cons = (x, xs) => [x].concat(xs),\n        // nonEmptySubsequences :: [a] -> [[a]]\n        nonEmptySubsequences = xxs => {\n            if (xxs.length < 1) return [];\n            const [x, xs] = [xxs[0], xxs.slice(1)];\n            const f = (r, ys) => cons(ys, cons(cons(x, ys), r));\n            return cons([x], nonEmptySubsequences(xs)\n                .reduceRight(f, []));\n        };\n    return ('string' === typeof xs) ? (\n        cons('', nonEmptySubsequences(xs.split(''))\n            .map(x => ''.concat.apply('', x))) // map(concat)\n    ) : cons([], nonEmptySubsequences(xs));\n};",
  "subtract": "// subtract :: Num -> Num -> Num\nconst subtract = (x, y) => y - x;",
  "succ": "// succ :: Enum a => a -> a\nconst succ = x =>\n    isChar(x) ? (\n        chr(ord(x) + 1)\n    ) : isNaN(x) ? (\n        undefined\n    ) : x + 1;",
  "sum": "// sum :: [Num] -> Num\nconst sum = xs => xs.reduce((a, x) => a + x, 0);",
  "swap": "// swap :: (a, b) -> (b, a)\nconst swap = ab =>\n    Tuple(ab[1], ab[0]);",
  "tail": "// tail :: [a] -> [a]\nconst tail = xs => xs.length > 0 ? xs.slice(1) : [];",
  "tailMay": "// tailMay :: [a] -> Maybe [a]\nconst tailMay = xs =>\n    xs.length > 0 ? (\n        Just(xs.slice(1))\n    ) : Nothing();",
  "tails": "// tails :: [a] -> [[a]]\nconst tails = xs => {\n    const xs_ = ('string' === typeof xs) ? (\n        xs.split('')\n    ) : xs;\n    return xs_.map((_, i) => xs_.slice(i))\n        .concat([\n            []\n        ]);\n};",
  "take": "// take :: Int -> [a] -> [a]\nconst take = (n, xs) => xs.slice(0, n);",
  "takeAround": "// takeAround :: (a -> Bool) -> [a] -> [a]\nconst takeAround = (p, xs) => {\n    const ys = takeWhile(p, xs);\n    return ys.length < xs.length ? (\n        ys.concat(takeWhileR(p, xs))\n    ) : ys;\n};",
  "takeBaseName": "// takeBaseName :: FilePath -> String\nconst takeBaseName = strPath =>\n  ('' !== strPath) ? (\n    ('/' !== strPath[strPath.length - 1]) ? (() => {\n      const fn = strPath.split('/').slice(-1)[0];\n      return fn.includes('.') ? (\n        fn.split('.').slice(0, -1).join('.')\n      ) : fn;\n    })() : ''\n  ) : '';",
  "takeCycle": "// First n members of an infinite cycle of xs\n\n// takeCycle :: Int -> [a] -> [a]\nconst takeCycle = (n, xs) => {\n  const lng = xs.length;\n  return (lng >= n ? xs : concat(replicate(Math.ceil(n / lng), xs)))\n  .slice(0, n)\n};",
  "takeDirectory": "// takeDirectory :: FilePath -> FilePath\nconst takeDirectory = strPath =>\n    ('' !== strPath) ? (() => {\n        const xs = (strPath.split('/'))\n            .slice(0, -1);\n        return xs.length > 0 ? (\n            xs.join('/')\n        ) : '.';\n    })() : '.';",
  "takeDropCycle": "// take N Members of an infinite cycle of xs, starting from index I\n\n// takeDropCycle :: Int -> [a] -> [a]\nconst takeDropCycle = (n, i, xs) => {\n    const\n        lng = xs.length,\n        m = n + i;\n    return drop(i,\n        take(m,\n            (lng >= m ? xs : concat(replicate(Math.ceil(m / lng), xs)))\n        )\n    );\n};",
  "takeExtension": "// takeExtension :: FilePath -> String\nconst takeExtension = strPath => {\n    const\n        xs = strPath.split('.'),\n        lng = xs.length;\n    return 1 < lng ? (\n        '.' + xs[lng - 1]\n    ) : '';\n};",
  "takeFileName": "// takeFileName :: FilePath -> FilePath\nconst takeFileName = strPath =>\n    '' !== strPath ? (\n        ('/' !== strPath[strPath.length - 1]) ? (\n            strPath.split('/')\n            .slice(-1)[0]\n        ) : ''\n    ) : '';",
  "takeIterate": "// takeIterate n f x == [x, f x, f (f x), ...]\n\n// takeIterate :: Int -> (a -> a) -> a -> [a]\nconst takeIterate = (n, f, x) =>\n    snd(mapAccumL((a, _, i) => {\n        const v = 0 !== i ? f(a) : x;\n        return [v, v];\n    }, x, Array.from({\n        length: n\n    })));",
  "takeWhile": "// takeWhile :: (a -> Bool) -> [a] -> [a]\nconst takeWhile = (p, xs) => {\n    let i = 0;\n    const lng = xs.length;\n    while ((i < lng) && p(xs[i])) (i = i + 1);\n    return xs.slice(0, i);\n};",
  "takeWhileR": "// takeWhileR :: (a -> Bool) -> [a] -> [a]\nconst takeWhileR = (p, xs) => {\n    let i = xs.length;\n    while (i-- && p(xs[i])) {}\n    return xs.slice(i + 1);\n};",
  "tempFilePath": "// File name template -> temporary path\n// (Random digit sequence inserted between template base and extension)\n\n// tempFilePath :: String -> IO FilePath\nconst tempFilePath = template =>\n    ObjC.unwrap($.NSTemporaryDirectory()) +\n    takeBaseName(template) + Math.random()\n    .toString()\n    .substring(3) + takeExtension(template);",
  "then (>>)": "// then (>>) :: Monad m => m a -> m b -> m b\nconst then = (ma, mb) =>\n    (Array.isArray(ma) ? (\n        thenList\n    ) : isMaybe(ma) ? (\n        thenMay\n    ) : thenIO)\n    .apply(null, [ma, mb]);",
  "thenIO (>>)": "// thenIO (>>) :: IO a -> IO b -> IO b\nconst thenIO = (ma, mb) => mb;",
  "thenList (>>)": "// thenList (>>) :: [a] -> [b] -> [b]\nconst thenList = (xs, ys) =>\n    concatMap(_ => ys, xs);",
  "thenMay (>>)": "// thenMay (>>) :: Maybe a -> Maybe b -> Maybe b\nconst thenMay = (mbx, mby) =>\n    mbx.Nothing ? mbx : mby;",
  "toListTree": "// toListTree :: Tree a -> [a]\nconst toListTree = tree => {\n    const go = x => [\n      x.root,\n      ...[].concat.apply([], x.nest.map(go))\n    ];\n    return go(tree);\n};",
  "toLower": "// toLower :: String -> String\nconst toLower = s => s.toLowerCase();",
  "toRatio": "// toRatio :: Real -> Ratio\nconst toRatio = n =>\n    approxRatio(1e-12, n);",
  "toSentence": "// Sentence case - initial string capitalized and rest lowercase\n\n// toSentence :: String -> String\nconst toSentence = s =>\n    (0 < s.length) ? (\n        s[0].toUpperCase() + s.slice(1)\n        .toLowerCase()\n    ) : s;",
  "toTitle": "// NB this does not model any regional or cultural conventions.\n// It simply simply capitalizes the first character of each word.\n\n// toTitle :: String -> String\nconst toTitle = s =>\n    regexMatches(/(\\w)(\\w*)(\\b[\\W]*|$)/g, s)\n    .map(ms => ms[1].toUpperCase() + ms[2].toLowerCase() + ms[3])\n    .join('');",
  "toUpper": "// toUpper :: String -> String\nconst toUpper = s => s.toUpperCase();",
  "transpose": "// If some of the rows are shorter than the following rows, \n// their elements are skipped:\n// > transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]\n// transpose :: [[a]] -> [[a]]\n\n// transpose :: [[a]] -> [[a]]\nconst transpose = tbl => {\n    const\n        gaps = replicate(\n            length(maximumBy(comparing(length), tbl)), []\n        ),\n        rows = map(xs => xs.concat(gaps.slice(xs.length)), tbl);\n    return map(\n        (_, col) => concatMap(row => [row[col]], rows),\n        rows[0]\n    );\n};",
  "traverse": "// traverse :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)\nconst traverse = (f, tx) => {\n    const t = tx.type;\n    return (\n        undefined !== t ? (\n            'Either' === t ? (\n                traverseLR\n            ) : 'Maybe' === t ? (\n                traverseMay\n            ) : 'Node' === t ? (\n                traverseTree\n            ) : 'Tuple' === t ? (\n                traverseTuple\n            ) : traverseList\n        ) : traverseList\n    )(f, tx)\n};",
  "traverseLR": "// traverseLR :: Applicative f => (t -> f b) -> Either a t -> f (Either a b)\nconst traverseLR = (f, lr) =>\n    lr.Left !== undefined ? (\n        [lr]\n    ) : fmap(Right, f(lr.Right));",
  "traverseList": "// - Map each element of a structure to an action,\n// - evaluate these actions from left to right,\n// - and collect the results.\n\n//    traverse f = List.foldr cons_f (pure [])\n//      where cons_f x ys = liftA2 (:) (f x) ys\n\n// traverseList :: (Applicative f) => (a -> f b) -> [a] -> f [b]\nconst traverseList = (f, xs) => {\n    const lng = xs.length;\n    return 0 < lng ? (() => {\n        const\n            vLast = f(xs[lng - 1]),\n            t = vLast.type || 'List';\n        return xs.slice(0, -1).reduceRight(\n            (ys, x) => liftA2(cons, f(x), ys),\n            liftA2(cons, vLast, pureT(t, []))\n        );\n    })() : [[]];\n};",
  "traverseMay": "// traverseMay :: Applicative f => (t -> f a) -> Maybe t -> f (Maybe a)\nconst traverseMay = (f, mb) =>\n    mb.Nothing ? (\n        [mb]\n    ) : fmap(Just, f(mb.Just));",
  "traverseTree": "// traverse f (Node x ts) = liftA2 Node (f x) (traverse (traverse f) ts)\nconst traverseTree = (f, node) => {\n    const go = x =>\n        liftA2(\n            Node, f(x.root),\n            traverseList(go, x.nest)\n        );\n    return go(node);\n};",
  "traverseTuple": "// traverseTuple :: Functor f => (t -> f b) -> (a, t) -> f (a, b)\nconst traverseTuple = (f, tpl) =>\n    fmap(curry(Tuple)(tpl[0]), f(tpl[1]));",
  "treeLeaves": "// treeLeaves :: Tree -> [Tree]\nconst treeLeaves = oNode => {\n  const nest = oNode.nest;\n  return (0 < nest.length) ? (\n    concatMap(treeLeaves, nest)\n  ) : [oNode];\n};",
  "truncate": "// truncate :: Num -> Int\nconst truncate = x => {\n    const [m, _] = properFraction(x);\n    return m;\n};",
  "tupleFromArray": "// tupleFromArray :: [a] -> (a, a ...)\nconst tupleFromArray = xs => {\n    const lng = xs.length;\n    return 1 < lng ? xs.reduce(\n        (a, x, i) => Object.assign(a, {\n            [i.toString()]: x\n        }), {\n            type: 'Tuple' + (2 < lng ? lng.toString() : '')\n        }\n    ) : undefined;\n};",
  "typeName": "// typeName :: a -> String\nconst typeName = v => {\n    const t = typeof v;\n    return 'object' === t ? (\n        Array.isArray(v) ? (\n            'List'\n        ) : null !== v ? (\n            v.type || 'Dict'\n        ) : 'Bottom'\n    ) : {\n        'boolean': 'Bool',\n        'number' : 'Num',\n        'string' : 'String'\n    }[t] || 'Bottom';\n};",
  "unQuoted": "// unQuoted :: String -> String\nconst unQuoted = s =>\n    dropAround(x => 34 === x.codePointAt(0), s);",
  "uncons": "// uncons :: [a] -> Maybe (a, [a])\nconst uncons = xs =>\n    (0 < xs.length) ? (\n        Just(Tuple(xs[0], xs.slice(1)))\n    ) : Nothing();",
  "uncurry": "// Converts a function of more than one argument\n// to a function on Tuple type (Tuple ... TupleN)\n// or array which contains those arguments.\n// This implementation uses the fact that the Tuple\n// constructors create an object with a private .length property\n\n// uncurry :: (a -> b -> c) -> ((a, b) -> c)\nconst uncurry = f => args => f.apply(null, args);",
  "unfoldForest": "// | Build a forest from a list of seed values\n\n// unfoldForest :: (b -> (a, [b])) -> [b] -> [Tree]\nconst unfoldForest = (f, xs) =>\n    xs.map(b => unfoldTree(f, b));",
  "unfoldTree": "// | Build a tree from a seed value\n\n// unfoldTree :: (b -> (a, [b])) -> b -> Tree a\nconst unfoldTree = (f, b) => {\n    const tpl = f(b);\n    return Node(tpl[0], unfoldForest(f, tpl[1]));\n};",
  "unfoldl": "// (x => Maybe [value, remainder] -> initial value -> values\n\n// unfoldl :: (b -> Maybe (a, b)) -> b -> [a]\nconst unfoldl = (f, v) => {\n    let xs = [];\n    return (\n        until(\n            mb => mb.Nothing,\n            mb => (\n                xs = [mb.Just[1]].concat(xs),\n                f(mb.Just[1])\n            ), Just(Tuple(v, v))\n        ),\n        xs.slice(1)\n    );\n};",
  "unfoldr": "// The 'unfoldr' function is a \\`dual\\' to 'foldr': while 'foldr'\n// reduces a list to a summary value, 'unfoldr' builds a list from\n// a seed value.  The function takes the element and returns 'Nothing'\n// if it is done producing the list or returns 'Just' @(a,b)@, in which\n// case, @a@ is a prepended to the list and @b@ is used as the next\n// element in a recursive call.\n//\n// unfoldr(b => b === 0 ? Nothing() : Just(Tuple(b, b - 1)), 10);\n// --> [10,9,8,7,6,5,4,3,2,1]\n\n// (x => Maybe [value, remainder] -> initial value -> values\n\n// unfoldr :: (b -> Maybe (a, b)) -> b -> [a]\nconst unfoldr = (f, v) => {\n    let xs = [];\n    return (\n        until(\n            mb => mb.Nothing,\n            mb => (\n                xs.push(mb.Just[0]),\n                f(mb.Just[1])\n            ), Just(Tuple(v, v))\n        ),\n        xs.slice(1)\n    );\n};",
  "union": "// union :: [a] -> [a] -> [a]\nconst union = (xs, ys) =>\n  unionBy((a, b) => a === b, xs, ys);",
  "unionBy": "// unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nconst unionBy = (fnEq, xs, ys) => {\n    const sx = nubBy(fnEq, xs);\n    return sx.concat(\n        sx.reduce(\n            (a, x) => deleteBy(fnEq, x, a),\n            nubBy(fnEq, ys)\n        )\n    );\n};",
  "unlines": "// unlines :: [String] -> String\nconst unlines = xs => xs.join('\\n');",
  "unsnoc": "// If the list is empty returns Nothing, otherwise returns \n// Just the init and the last.\n\n// unsnoc :: [a] -> Maybe ([a], a)\nconst unsnoc = xs =>\n    (0 < xs.length) ? (\n        Just(Tuple(xs.slice(0, -1), xs.slice(-1)[0]))\n    ) : Nothing();",
  "until": "// until :: (a -> Bool) -> (a -> a) -> a -> a\nconst until = (p, f, x) => {\n    let v = x;\n    while (!p(v)) v = f(v);\n    return v;\n};",
  "unwords": "// unwords :: [String] -> String\nconst unwords = xs => xs.join(' ');",
  "unwrap": "// unwrap :: NSObject -> a\nconst unwrap = ObjC.unwrap;",
  "unzip": "// unzip :: [(a,b)] -> ([a],[b])\nconst unzip = xys =>\n    xys.reduce(\n        (a, x) => Tuple.apply(null, [0, 1].map(\n            i => a[i].concat(x[i])\n        )),\n        Tuple([], [])\n    );",
  "unzip3": "// unzip3 :: [(a,b,c)] -> ([a],[b],[c])\nconst unzip3 = xyzs =>\n    xyzs.reduce(\n        (a, x) => Tuple3.apply(null, [0, 1, 2].map(\n            i => a[i].concat(x[i])\n        )),\n        Tuple3([], [], [])\n    );",
  "unzip4": "// unzip4 :: [(a,b,c,d)] -> ([a],[b],[c],[d])\nconst unzip4 = wxyzs =>\n    wxyzs.reduce(\n        (a, x) => Tuple4.apply(null, [0, 1, 2, 3].map(\n            i => a[i].concat(x[i])\n        )),\n        Tuple4([], [], [], [])\n    );",
  "variance": "// variance :: [Num] -> Num\nconst variance = xs => {\n    const\n        lng = xs.length,\n        mean = xs.reduce((a, b) => a + b, 0) / lng;\n    return xs.reduce(\n        (a, b) => a + Math.pow(b - mean, 2),\n        0\n    ) / (lng - 1);\n};",
  "words": "// words :: String -> [String]\nconst words = s => s.split(/\\s+/);",
  "wrap": "// wrap :: a -> NSObject\nconst wrap = ObjC.wrap;",
  "writeFile": "// writeFile :: FilePath -> String -> IO ()\nconst writeFile = (strPath, strText) =>\n    $.NSString.alloc.initWithUTF8String(strText)\n    .writeToFileAtomicallyEncodingError(\n        $(strPath)\n        .stringByStandardizingPath, false,\n        $.NSUTF8StringEncoding, null\n    );",
  "writeFileLR": "// writeFileLR :: FilePath -> Either String IO FilePath\nconst writeFileLR = (strPath, strText) => {\n    const\n        e = $(),\n        fp = $(strPath)\n        .stringByStandardizingPath;\n    return $.NSString.alloc.initWithUTF8String(strText)\n        .writeToFileAtomicallyEncodingError(\n            fp, false,\n            $.NSUTF8StringEncoding, e\n        ) ? (\n            Right(ObjC.unwrap(fp))\n        ) : Left(ObjC.unwrap(e.localizedDescription));\n};",
  "writeTempFile": "// File name template -> string data -> IO temporary path\n\n// writeTempFile :: String -> String -> IO FilePath\nconst writeTempFile = (template, txt) => {\n    const\n        strPath = ObjC.unwrap($.NSTemporaryDirectory()) +\n        takeBaseName(template) + Math.random()\n        .toString()\n        .substring(3) + takeExtension(template);\n    return (writeFile(strPath, txt), strPath);\n};",
  "zip": "// zip :: [a] -> [b] -> [(a, b)]\nconst zip = (xs, ys) =>\n    xs.slice(0, Math.min(xs.length, ys.length))\n    .map((x, i) => Tuple(x, ys[i]));",
  "zip3": "// zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]\nconst zip3 = (xs, ys, zs) =>\n    xs.slice(0, Math.min(xs.length, ys.length, zs.length))\n    .map((x, i) => Tuple3(x, ys[i], zs[i]));",
  "zip4": "// zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]\nconst zip4 = (ws, xs, ys, zs) =>\n    ws.slice(0, Math.min(\n        xs.length, xs.length, ys.length, zs.length\n    ))\n    .map((w, i) => Tuple4(w, xs[i], ys[i], zs[i]));",
  "zipWith": "// zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\nconst zipWith = (f, xs, ys) =>\n    Array.from({\n        length: Math.min(xs.length, ys.length)\n    }, (_, i) => f(xs[i], ys[i], i));",
  "zipWith3": "// zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]\nconst zipWith3 = (f, xs, ys, zs) =>\n    Array.from({\n        length: Math.min(xs.length, ys.length, zs.length)\n    }, (_, i) => f(xs[i], ys[i], zs[i]));",
  "zipWith4": "// zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]\nconst zipWith4 = (f, ws, xs, ys, zs) =>\n    Array.from({\n        length: Math.min(ws.length, xs.length, ys.length, zs.length)\n    }, (_, i) => f(ws[i], xs[i], ys[i], zs[i]));"
}